begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|statics
package|;
end_package

begin_comment
comment|/* ====================================================================  * The Apache Software License, Version 1.1  *  * Copyright (c) 2001 The Apache Software Foundation.  All rights  * reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. The end-user documentation included with the redistribution,  *    if any, must include the following acknowledgment:  *       "This product includes software developed by the  *        Apache Software Foundation (http://www.apache.org/)."  *    Alternately, this acknowledgment may appear in the software itself,  *    if and wherever such third-party acknowledgments normally appear.  *  * 4. The names "Apache" and "Apache Software Foundation" and  *    "Apache BCEL" must not be used to endorse or promote products  *    derived from this software without prior written permission. For  *    written permission, please contact apache@apache.org.  *  * 5. Products derived from this software may not be called "Apache",  *    "Apache BCEL", nor may "Apache" appear in their name, without  *    prior written permission of the Apache Software Foundation.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * ====================================================================  *  * This software consists of voluntary contributions made by many  * individuals on behalf of the Apache Software Foundation.  For more  * information on the Apache Software Foundation, please see  *<http://www.apache.org/>.  */
end_comment

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|exc
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_comment
comment|/**  * This PassVerifier verifies a class file according to  * pass 3, static part as described in The Java Virtual  * Machine Specification, 2nd edition.  * More detailed information is to be found at the do_verify()  * method's documentation.   *  * @version $Id$  * @author<A HREF="http://www.inf.fu-berlin.de/~ehaase"/>Enver Haase</A>  * @see #do_verify()  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|Pass3aVerifier
extends|extends
name|PassVerifier
block|{
comment|/** The Verifier that created this. */
specifier|private
name|Verifier
name|myOwner
decl_stmt|;
comment|/**  	 * The method number to verify. 	 * This is the index in the array returned 	 * by JavaClass.getMethods(). 	 */
specifier|private
name|int
name|method_no
decl_stmt|;
comment|/** The one and only InstructionList object used by an instance of this class. It's here for performance reasons by do_verify() and its callees. */
name|InstructionList
name|instructionList
decl_stmt|;
comment|/** The one and only Code object used by an instance of this class. It's here for performance reasons by do_verify() and its callees. */
name|Code
name|code
decl_stmt|;
comment|/** Should only be instantiated by a Verifier. */
specifier|public
name|Pass3aVerifier
parameter_list|(
name|Verifier
name|owner
parameter_list|,
name|int
name|method_no
parameter_list|)
block|{
name|myOwner
operator|=
name|owner
expr_stmt|;
name|this
operator|.
name|method_no
operator|=
name|method_no
expr_stmt|;
block|}
comment|/** 	 * Pass 3a is the verification of static constraints of 	 * JVM code (such as legal targets of branch instructions). 	 * This is the part of pass 3 where you do not need data 	 * flow analysis. 	 * JustIce also delays the checks for a correct exception 	 * table of a Code attribute and correct line number entries 	 * in a LineNumberTable attribute of a Code attribute (which 	 * conceptually belong to pass 2) to this pass. Also, most 	 * of the check for valid local variable entries in a 	 * LocalVariableTable attribute of a Code attribute is 	 * delayed until this pass. 	 * All these checks need access to the code array of the 	 * Code attribute. 	 * 	 * @throws InvalidMethodException if the method to verify does not exist. 	 */
specifier|public
name|VerificationResult
name|do_verify
parameter_list|()
block|{
if|if
condition|(
name|myOwner
operator|.
name|doPass2
argument_list|()
operator|.
name|equals
argument_list|(
name|VerificationResult
operator|.
name|VR_OK
argument_list|)
condition|)
block|{
comment|// Okay, class file was loaded correctly by Pass 1
comment|// and satisfies static constraints of Pass 2.
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|Method
index|[]
name|methods
init|=
name|jc
operator|.
name|getMethods
argument_list|()
decl_stmt|;
if|if
condition|(
name|method_no
operator|>=
name|methods
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|InvalidMethodException
argument_list|(
literal|"METHOD DOES NOT EXIST!"
argument_list|)
throw|;
block|}
name|Method
name|method
init|=
name|methods
index|[
name|method_no
index|]
decl_stmt|;
name|code
operator|=
name|method
operator|.
name|getCode
argument_list|()
expr_stmt|;
comment|// No Code? Nothing to verify!
if|if
condition|(
name|method
operator|.
name|isAbstract
argument_list|()
operator|||
name|method
operator|.
name|isNative
argument_list|()
condition|)
block|{
comment|// IF mg HAS NO CODE (static constraint of Pass 2)
return|return
name|VerificationResult
operator|.
name|VR_OK
return|;
block|}
comment|// TODO:
comment|// We want a very sophisticated code examination here with good explanations
comment|// on where to look for an illegal instruction or such.
comment|// Only after that we should try to build an InstructionList and throw an
comment|// AssertionViolatedException if after our examination InstructionList building
comment|// still fails.
comment|// That examination should be implemented in a byte-oriented way, i.e. look for
comment|// an instruction, make sure its validity, count its length, find the next
comment|// instruction and so on.
try|try
block|{
name|instructionList
operator|=
operator|new
name|InstructionList
argument_list|(
name|method
operator|.
name|getCode
argument_list|()
operator|.
name|getCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|re
parameter_list|)
block|{
return|return
operator|new
name|VerificationResult
argument_list|(
name|VerificationResult
operator|.
name|VERIFIED_REJECTED
argument_list|,
literal|"Bad bytecode in the code array of the Code attribute of method '"
operator|+
name|method
operator|+
literal|"'."
argument_list|)
return|;
block|}
name|instructionList
operator|.
name|setPositions
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Start verification.
name|VerificationResult
name|vr
init|=
name|VerificationResult
operator|.
name|VR_OK
decl_stmt|;
comment|//default
try|try
block|{
name|delayedPass2Checks
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassConstraintException
name|cce
parameter_list|)
block|{
name|vr
operator|=
operator|new
name|VerificationResult
argument_list|(
name|VerificationResult
operator|.
name|VERIFIED_REJECTED
argument_list|,
name|cce
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vr
return|;
block|}
try|try
block|{
name|pass3StaticInstructionChecks
argument_list|()
expr_stmt|;
name|pass3StaticInstructionOperandsChecks
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StaticCodeConstraintException
name|scce
parameter_list|)
block|{
name|vr
operator|=
operator|new
name|VerificationResult
argument_list|(
name|VerificationResult
operator|.
name|VERIFIED_REJECTED
argument_list|,
name|scce
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|vr
return|;
block|}
else|else
block|{
comment|//did not pass Pass 2.
return|return
name|VerificationResult
operator|.
name|VR_NOTYET
return|;
block|}
block|}
comment|/** 	 * These are the checks that could be done in pass 2 but are delayed to pass 3 	 * for performance reasons. Also, these checks need access to the code array 	 * of the Code attribute of a Method so it's okay to perform them here. 	 * Also see the description of the do_verify() method. 	 * 	 * @throws ClassConstraintException if the verification fails. 	 * @see #do_verify() 	 */
specifier|private
name|void
name|delayedPass2Checks
parameter_list|()
block|{
name|int
index|[]
name|instructionPositions
init|=
name|instructionList
operator|.
name|getInstructionPositions
argument_list|()
decl_stmt|;
name|int
name|codeLength
init|=
name|code
operator|.
name|getCode
argument_list|()
operator|.
name|length
decl_stmt|;
comment|/////////////////////
comment|// LineNumberTable //
comment|/////////////////////
name|LineNumberTable
name|lnt
init|=
name|code
operator|.
name|getLineNumberTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|lnt
operator|!=
literal|null
condition|)
block|{
name|LineNumber
index|[]
name|lineNumbers
init|=
name|lnt
operator|.
name|getLineNumberTable
argument_list|()
decl_stmt|;
name|IntList
name|offsets
init|=
operator|new
name|IntList
argument_list|()
decl_stmt|;
name|lineNumber_loop
label|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lineNumbers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// may appear in any order.
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|instructionPositions
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
comment|// TODO: Make this a binary search! The instructionPositions array is naturally ordered!
name|int
name|offset
init|=
name|lineNumbers
index|[
name|i
index|]
operator|.
name|getStartPC
argument_list|()
decl_stmt|;
if|if
condition|(
name|instructionPositions
index|[
name|j
index|]
operator|==
name|offset
condition|)
block|{
if|if
condition|(
name|offsets
operator|.
name|contains
argument_list|(
name|offset
argument_list|)
condition|)
block|{
name|addMessage
argument_list|(
literal|"LineNumberTable attribute '"
operator|+
name|code
operator|.
name|getLineNumberTable
argument_list|()
operator|+
literal|"' refers to the same code offset ('"
operator|+
name|offset
operator|+
literal|"') more than once which is violating the semantics [but is sometimes produced by IBM's 'jikes' compiler]."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offsets
operator|.
name|add
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
continue|continue
name|lineNumber_loop
continue|;
block|}
block|}
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|code
operator|+
literal|"' has a LineNumberTable attribute '"
operator|+
name|code
operator|.
name|getLineNumberTable
argument_list|()
operator|+
literal|"' referring to a code offset ('"
operator|+
name|lineNumbers
index|[
name|i
index|]
operator|.
name|getStartPC
argument_list|()
operator|+
literal|"') that does not exist."
argument_list|)
throw|;
block|}
block|}
comment|///////////////////////////
comment|// LocalVariableTable(s) //
comment|///////////////////////////
comment|/* We cannot use code.getLocalVariableTable() because there could be more 		   than only one. This is a bug in BCEL. */
name|Attribute
index|[]
name|atts
init|=
name|code
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|atts
operator|.
name|length
condition|;
name|a
operator|++
control|)
block|{
if|if
condition|(
name|atts
index|[
name|a
index|]
operator|instanceof
name|LocalVariableTable
condition|)
block|{
name|LocalVariableTable
name|lvt
init|=
operator|(
name|LocalVariableTable
operator|)
name|atts
index|[
name|a
index|]
decl_stmt|;
if|if
condition|(
name|lvt
operator|!=
literal|null
condition|)
block|{
name|LocalVariable
index|[]
name|localVariables
init|=
name|lvt
operator|.
name|getLocalVariableTable
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|localVariables
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|startpc
init|=
name|localVariables
index|[
name|i
index|]
operator|.
name|getStartPC
argument_list|()
decl_stmt|;
name|int
name|length
init|=
name|localVariables
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|contains
argument_list|(
name|instructionPositions
argument_list|,
name|startpc
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|code
operator|+
literal|"' has a LocalVariableTable attribute '"
operator|+
name|code
operator|.
name|getLocalVariableTable
argument_list|()
operator|+
literal|"' referring to a code offset ('"
operator|+
name|startpc
operator|+
literal|"') that does not exist."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
operator|!
name|contains
argument_list|(
name|instructionPositions
argument_list|,
name|startpc
operator|+
name|length
argument_list|)
operator|)
operator|&&
operator|(
name|startpc
operator|+
name|length
operator|!=
name|codeLength
operator|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|code
operator|+
literal|"' has a LocalVariableTable attribute '"
operator|+
name|code
operator|.
name|getLocalVariableTable
argument_list|()
operator|+
literal|"' referring to a code offset start_pc+length ('"
operator|+
operator|(
name|startpc
operator|+
name|length
operator|)
operator|+
literal|"') that does not exist."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
comment|////////////////////
comment|// ExceptionTable //
comment|////////////////////
comment|// In BCEL's "classfile" API, the startPC/endPC-notation is
comment|// inclusive/exclusive as in the Java Virtual Machine Specification.
comment|// WARNING: This is not true for BCEL's "generic" API.
name|CodeException
index|[]
name|exceptionTable
init|=
name|code
operator|.
name|getExceptionTable
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exceptionTable
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|startpc
init|=
name|exceptionTable
index|[
name|i
index|]
operator|.
name|getStartPC
argument_list|()
decl_stmt|;
name|int
name|endpc
init|=
name|exceptionTable
index|[
name|i
index|]
operator|.
name|getEndPC
argument_list|()
decl_stmt|;
name|int
name|handlerpc
init|=
name|exceptionTable
index|[
name|i
index|]
operator|.
name|getHandlerPC
argument_list|()
decl_stmt|;
if|if
condition|(
name|startpc
operator|>=
name|endpc
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|code
operator|+
literal|"' has an exception_table entry '"
operator|+
name|exceptionTable
index|[
name|i
index|]
operator|+
literal|"' that has its start_pc ('"
operator|+
name|startpc
operator|+
literal|"') not smaller than its end_pc ('"
operator|+
name|endpc
operator|+
literal|"')."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|contains
argument_list|(
name|instructionPositions
argument_list|,
name|startpc
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|code
operator|+
literal|"' has an exception_table entry '"
operator|+
name|exceptionTable
index|[
name|i
index|]
operator|+
literal|"' that has a non-existant bytecode offset as its start_pc ('"
operator|+
name|startpc
operator|+
literal|"')."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
operator|!
name|contains
argument_list|(
name|instructionPositions
argument_list|,
name|endpc
argument_list|)
operator|)
operator|&&
operator|(
name|endpc
operator|!=
name|codeLength
operator|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|code
operator|+
literal|"' has an exception_table entry '"
operator|+
name|exceptionTable
index|[
name|i
index|]
operator|+
literal|"' that has a non-existant bytecode offset as its end_pc ('"
operator|+
name|startpc
operator|+
literal|"') [that is also not equal to code_length ('"
operator|+
name|codeLength
operator|+
literal|"')]."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|contains
argument_list|(
name|instructionPositions
argument_list|,
name|handlerpc
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|code
operator|+
literal|"' has an exception_table entry '"
operator|+
name|exceptionTable
index|[
name|i
index|]
operator|+
literal|"' that has a non-existant bytecode offset as its handler_pc ('"
operator|+
name|handlerpc
operator|+
literal|"')."
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** 	 * These are the checks if constraints are satisfied which are described in the 	 * Java Virtual Machine Specification, Second Edition as Static Constraints on 	 * the instructions of Java Virtual Machine Code (chapter 4.8.1). 	 * 	 * @throws StaticCodeConstraintException if the verification fails. 	 */
specifier|private
name|void
name|pass3StaticInstructionChecks
parameter_list|()
block|{
comment|// Code array must not be empty:
comment|// Enforced in pass 2 (also stated in the static constraints of the Code
comment|// array in vmspec2), together with pass 1 (reading code_length bytes and
comment|// interpreting them as code[]). So this must not be checked again here.
if|if
condition|(
operator|!
operator|(
name|code
operator|.
name|getCode
argument_list|()
operator|.
name|length
operator|<
literal|65536
operator|)
condition|)
block|{
comment|// contradicts vmspec2 page 152 ("Limitations"), but is on page 134.
throw|throw
operator|new
name|StaticCodeInstructionConstraintException
argument_list|(
literal|"Code array in code attribute '"
operator|+
name|code
operator|+
literal|"' too big: must be smaller than 65536 bytes."
argument_list|)
throw|;
block|}
comment|// First opcode at offset 0: okay, that's clear. Nothing to do.
comment|// Only instances of the instructions documented in Section 6.4 may appear in
comment|// the code array.
comment|// For BCEL's sake, we cannot handle WIDE stuff, but hopefully BCEL does its job right :)
comment|// The last byte of the last instruction in the code array must be the byte at index
comment|// code_length-1 : See the do_verify() comments. We actually don't iterate through the
comment|// byte array, but use an InstructionList so we cannot check for this. But BCEL does
comment|// things right, so it's implicitely okay.
comment|// TODO: Check how BCEL handles (and will handle) instructions like IMPDEP1, IMPDEP2,
comment|//       BREAKPOINT... that BCEL knows about but which are illegal anyway.
comment|//       We currently go the safe way here.
name|InstructionHandle
name|ih
init|=
name|instructionList
operator|.
name|getStart
argument_list|()
decl_stmt|;
while|while
condition|(
name|ih
operator|!=
literal|null
condition|)
block|{
name|Instruction
name|i
init|=
name|ih
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|instanceof
name|IMPDEP1
condition|)
block|{
throw|throw
operator|new
name|StaticCodeInstructionConstraintException
argument_list|(
literal|"IMPDEP1 must not be in the code, it is an illegal instruction for _internal_ JVM use!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|i
operator|instanceof
name|IMPDEP2
condition|)
block|{
throw|throw
operator|new
name|StaticCodeInstructionConstraintException
argument_list|(
literal|"IMPDEP2 must not be in the code, it is an illegal instruction for _internal_ JVM use!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|i
operator|instanceof
name|BREAKPOINT
condition|)
block|{
throw|throw
operator|new
name|StaticCodeInstructionConstraintException
argument_list|(
literal|"BREAKPOINT must not be in the code, it is an illegal instruction for _internal_ JVM use!"
argument_list|)
throw|;
block|}
name|ih
operator|=
name|ih
operator|.
name|getNext
argument_list|()
expr_stmt|;
block|}
comment|// The original verifier seems to do this check here, too.
comment|// An unreachable last instruction may also not fall through the
comment|// end of the code, which is stupid -- but with the original
comment|// verifier's subroutine semantics one cannot predict reachability.
name|Instruction
name|last
init|=
name|instructionList
operator|.
name|getEnd
argument_list|()
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|last
operator|instanceof
name|ReturnInstruction
operator|)
operator|||
operator|(
name|last
operator|instanceof
name|RET
operator|)
operator|||
operator|(
name|last
operator|instanceof
name|GotoInstruction
operator|)
operator|||
operator|(
name|last
operator|instanceof
name|ATHROW
operator|)
operator|)
condition|)
comment|// JSR / JSR_W would possibly RETurn and then fall off the code!
throw|throw
operator|new
name|StaticCodeInstructionConstraintException
argument_list|(
literal|"Execution must not fall off the bottom of the code array. This constraint is enforced statically as some existing verifiers do - so it may be a false alarm if the last instruction is not reachable."
argument_list|)
throw|;
block|}
comment|/** 	 * These are the checks for the satisfaction of constraints which are described in the 	 * Java Virtual Machine Specification, Second Edition as Static Constraints on 	 * the operands of instructions of Java Virtual Machine Code (chapter 4.8.1). 	 * BCEL parses the code array to create an InstructionList and therefore has to check 	 * some of these constraints. Additional checks are also implemented here. 	 * 	 * @throws StaticCodeConstraintException if the verification fails. 	 */
specifier|private
name|void
name|pass3StaticInstructionOperandsChecks
parameter_list|()
block|{
comment|// When building up the InstructionList, BCEL has already done all those checks
comment|// mentioned in The Java Virtual Machine Specification, Second Edition, as
comment|// "static constraints on the operands of instructions in the code array".
comment|// TODO: see the do_verify() comments. Maybe we should really work on the
comment|//       byte array first to give more comprehensive messages.
comment|// TODO: Review Exception API, possibly build in some "offending instruction" thing
comment|//       when we're ready to insulate the offending instruction by doing the
comment|//       above thing.
comment|// TODO: Implement as much as possible here. BCEL does _not_ check everything.
name|ConstantPoolGen
name|cpg
init|=
operator|new
name|ConstantPoolGen
argument_list|(
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|getConstantPool
argument_list|()
argument_list|)
decl_stmt|;
name|InstOperandConstraintVisitor
name|v
init|=
operator|new
name|InstOperandConstraintVisitor
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
comment|// Checks for the things BCEL does _not_ handle itself.
name|InstructionHandle
name|ih
init|=
name|instructionList
operator|.
name|getStart
argument_list|()
decl_stmt|;
while|while
condition|(
name|ih
operator|!=
literal|null
condition|)
block|{
name|Instruction
name|i
init|=
name|ih
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
comment|// An "own" constraint, due to JustIce's new definition of what "subroutine" means.
if|if
condition|(
name|i
operator|instanceof
name|JsrInstruction
condition|)
block|{
name|InstructionHandle
name|target
init|=
operator|(
operator|(
name|JsrInstruction
operator|)
name|i
operator|)
operator|.
name|getTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|instructionList
operator|.
name|getStart
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|StaticCodeInstructionOperandConstraintException
argument_list|(
literal|"Due to JustIce's clear definition of subroutines, no JSR or JSR_W may have a top-level instruction (such as the very first instruction, which is targeted by instruction '"
operator|+
name|ih
operator|+
literal|"' as its target."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|target
operator|.
name|getInstruction
argument_list|()
operator|instanceof
name|ASTORE
operator|)
condition|)
block|{
throw|throw
operator|new
name|StaticCodeInstructionOperandConstraintException
argument_list|(
literal|"Due to JustIce's clear definition of subroutines, no JSR or JSR_W may target anything else than an ASTORE instruction. Instruction '"
operator|+
name|ih
operator|+
literal|"' targets '"
operator|+
name|target
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
comment|// vmspec2, page 134-137
name|ih
operator|.
name|accept
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|ih
operator|=
name|ih
operator|.
name|getNext
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** A small utility method returning if a given int i is in the given int[] ints. */
specifier|private
specifier|static
name|boolean
name|contains
parameter_list|(
name|int
index|[]
name|ints
parameter_list|,
name|int
name|i
parameter_list|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|ints
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|ints
index|[
name|j
index|]
operator|==
name|i
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/** Returns the method number as supplied when instantiating. */
specifier|public
name|int
name|getMethodNo
parameter_list|()
block|{
return|return
name|method_no
return|;
block|}
comment|/** 	 * This visitor class does the actual checking for the instruction 	 * operand's constraints. 	 */
specifier|private
class|class
name|InstOperandConstraintVisitor
extends|extends
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|EmptyVisitor
block|{
comment|/** The ConstantPoolGen instance this Visitor operates on. */
specifier|private
name|ConstantPoolGen
name|cpg
decl_stmt|;
comment|/** The only Constructor. */
name|InstOperandConstraintVisitor
parameter_list|(
name|ConstantPoolGen
name|cpg
parameter_list|)
block|{
name|this
operator|.
name|cpg
operator|=
name|cpg
expr_stmt|;
block|}
comment|/** 		 * Utility method to return the max_locals value of the method verified 		 * by the surrounding Pass3aVerifier instance. 		 */
specifier|private
name|int
name|max_locals
parameter_list|()
block|{
return|return
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|getMethods
argument_list|()
index|[
name|method_no
index|]
operator|.
name|getCode
argument_list|()
operator|.
name|getMaxLocals
argument_list|()
return|;
block|}
comment|/** 		 * A utility method to always raise an exeption. 		 */
specifier|private
name|void
name|constraintViolated
parameter_list|(
name|Instruction
name|i
parameter_list|,
name|String
name|message
parameter_list|)
block|{
throw|throw
operator|new
name|StaticCodeInstructionOperandConstraintException
argument_list|(
literal|"Instruction "
operator|+
name|i
operator|+
literal|" constraint violated: "
operator|+
name|message
argument_list|)
throw|;
block|}
comment|/** 		 * A utility method to raise an exception if the index is not 		 * a valid constant pool index. 		 */
specifier|private
name|void
name|indexValid
parameter_list|(
name|Instruction
name|i
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|cpg
operator|.
name|getSize
argument_list|()
condition|)
block|{
name|constraintViolated
argument_list|(
name|i
argument_list|,
literal|"Illegal constant pool index '"
operator|+
name|idx
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
comment|///////////////////////////////////////////////////////////
comment|// The Java Virtual Machine Specification, pages 134-137 //
comment|///////////////////////////////////////////////////////////
comment|/** 		 * Assures the generic preconditions of a LoadClass instance. 		 * The referenced class is loaded and pass2-verified. 		 */
specifier|public
name|void
name|visitLoadClass
parameter_list|(
name|LoadClass
name|o
parameter_list|)
block|{
name|ObjectType
name|t
init|=
name|o
operator|.
name|getLoadClassType
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
comment|// null means "no class is loaded"
name|Verifier
name|v
init|=
name|VerifierFactory
operator|.
name|getVerifier
argument_list|(
name|t
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|VerificationResult
name|vr
init|=
name|v
operator|.
name|doPass1
argument_list|()
decl_stmt|;
if|if
condition|(
name|vr
operator|.
name|getStatus
argument_list|()
operator|!=
name|VerificationResult
operator|.
name|VERIFIED_OK
condition|)
block|{
name|constraintViolated
argument_list|(
operator|(
name|Instruction
operator|)
name|o
argument_list|,
literal|"Class '"
operator|+
name|o
operator|.
name|getLoadClassType
argument_list|(
name|cpg
argument_list|)
operator|.
name|getClassName
argument_list|()
operator|+
literal|"' is referenced, but cannot be loaded: '"
operator|+
name|vr
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// The target of each jump and branch instruction [...] must be the opcode [...]
comment|// BCEL _DOES_ handle this.
comment|// tableswitch: BCEL will do it, supposedly.
comment|// lookupswitch: BCEL will do it, supposedly.
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
comment|// LDC and LDC_W (LDC_W is a subclass of LDC in BCEL's model)
specifier|public
name|void
name|visitLDC
parameter_list|(
name|LDC
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|c
operator|instanceof
name|ConstantInteger
operator|)
operator|||
operator|(
name|c
operator|instanceof
name|ConstantFloat
operator|)
operator|||
operator|(
name|c
operator|instanceof
name|ConstantString
operator|)
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Operand of LDC or LDC_W must be one of CONSTANT_Integer, CONSTANT_Float or CONSTANT_String, but is '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
comment|// LDC2_W
specifier|public
name|void
name|visitLDC2_W
parameter_list|(
name|LDC2_W
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|c
operator|instanceof
name|ConstantLong
operator|)
operator|||
operator|(
name|c
operator|instanceof
name|ConstantDouble
operator|)
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Operand of LDC2_W must be CONSTANT_Long or CONSTANT_Double, but is '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StaticCodeInstructionOperandConstraintException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"OOPS: Does not BCEL handle that? LDC2_W operand has a problem."
argument_list|)
throw|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
comment|//getfield, putfield, getstatic, putstatic
specifier|public
name|void
name|visitFieldInstruction
parameter_list|(
name|FieldInstruction
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantFieldref
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Indexing a constant that's not a CONSTANT_Fieldref but a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitInvokeInstruction
parameter_list|(
name|InvokeInstruction
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|instanceof
name|INVOKEVIRTUAL
operator|)
operator|||
operator|(
name|o
operator|instanceof
name|INVOKESPECIAL
operator|)
operator|||
operator|(
name|o
operator|instanceof
name|INVOKESTATIC
operator|)
condition|)
block|{
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantMethodref
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Indexing a constant that's not a CONSTANT_Methodref but a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Constants are okay due to pass2.
name|ConstantNameAndType
name|cnat
init|=
operator|(
name|ConstantNameAndType
operator|)
operator|(
name|cpg
operator|.
name|getConstant
argument_list|(
operator|(
operator|(
name|ConstantMethodref
operator|)
name|c
operator|)
operator|.
name|getNameAndTypeIndex
argument_list|()
argument_list|)
operator|)
decl_stmt|;
name|ConstantUtf8
name|cutf8
init|=
operator|(
name|ConstantUtf8
operator|)
operator|(
name|cpg
operator|.
name|getConstant
argument_list|(
name|cnat
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|cutf8
operator|.
name|getBytes
argument_list|()
operator|.
name|equals
argument_list|(
name|Constants
operator|.
name|CONSTRUCTOR_NAME
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|o
operator|instanceof
name|INVOKESPECIAL
operator|)
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Only INVOKESPECIAL is allowed to invoke instance initialization methods."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
operator|(
name|cutf8
operator|.
name|getBytes
argument_list|()
operator|.
name|equals
argument_list|(
name|Constants
operator|.
name|CONSTRUCTOR_NAME
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|cutf8
operator|.
name|getBytes
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"<"
argument_list|)
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"No method with a name beginning with '<' other than the instance initialization methods may be called by the method invocation instructions."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|//if (o instanceof INVOKEINTERFACE){
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantInterfaceMethodref
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Indexing a constant that's not a CONSTANT_InterfaceMethodref but a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
comment|// TODO: From time to time check if BCEL allows to detect if the
comment|// 'count' operand is consistent with the information in the
comment|// CONSTANT_InterfaceMethodref and if the last operand is zero.
comment|// By now, BCEL hides those two operands because they're superfluous.
comment|// Invoked method must not be<init> or<clinit>
name|ConstantNameAndType
name|cnat
init|=
operator|(
name|ConstantNameAndType
operator|)
operator|(
name|cpg
operator|.
name|getConstant
argument_list|(
operator|(
operator|(
name|ConstantInterfaceMethodref
operator|)
name|c
operator|)
operator|.
name|getNameAndTypeIndex
argument_list|()
argument_list|)
operator|)
decl_stmt|;
name|String
name|name
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
operator|(
name|cpg
operator|.
name|getConstant
argument_list|(
name|cnat
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|Constants
operator|.
name|CONSTRUCTOR_NAME
argument_list|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Method to invoke must not be '"
operator|+
name|Constants
operator|.
name|CONSTRUCTOR_NAME
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|Constants
operator|.
name|STATIC_INITIALIZER_NAME
argument_list|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Method to invoke must not be '"
operator|+
name|Constants
operator|.
name|STATIC_INITIALIZER_NAME
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// The LoadClassType is the method-declaring class, so we have to check the other types.
name|Type
name|t
init|=
name|o
operator|.
name|getReturnType
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
block|{
name|t
operator|=
operator|(
operator|(
name|ArrayType
operator|)
name|t
operator|)
operator|.
name|getBasicType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|instanceof
name|ObjectType
condition|)
block|{
name|Verifier
name|v
init|=
name|VerifierFactory
operator|.
name|getVerifier
argument_list|(
operator|(
operator|(
name|ObjectType
operator|)
name|t
operator|)
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|VerificationResult
name|vr
init|=
name|v
operator|.
name|doPass2
argument_list|()
decl_stmt|;
if|if
condition|(
name|vr
operator|.
name|getStatus
argument_list|()
operator|!=
name|VerificationResult
operator|.
name|VERIFIED_OK
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Return type class/interface could not be verified successfully: '"
operator|+
name|vr
operator|.
name|getMessage
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
name|Type
index|[]
name|ts
init|=
name|o
operator|.
name|getArgumentTypes
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|ts
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
block|{
name|t
operator|=
operator|(
operator|(
name|ArrayType
operator|)
name|t
operator|)
operator|.
name|getBasicType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|instanceof
name|ObjectType
condition|)
block|{
name|Verifier
name|v
init|=
name|VerifierFactory
operator|.
name|getVerifier
argument_list|(
operator|(
operator|(
name|ObjectType
operator|)
name|t
operator|)
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|VerificationResult
name|vr
init|=
name|v
operator|.
name|doPass2
argument_list|()
decl_stmt|;
if|if
condition|(
name|vr
operator|.
name|getStatus
argument_list|()
operator|!=
name|VerificationResult
operator|.
name|VERIFIED_OK
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Argument type class/interface could not be verified successfully: '"
operator|+
name|vr
operator|.
name|getMessage
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitINSTANCEOF
parameter_list|(
name|INSTANCEOF
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantClass
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Expecting a CONSTANT_Class operand, but found a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitCHECKCAST
parameter_list|(
name|CHECKCAST
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantClass
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Expecting a CONSTANT_Class operand, but found a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitNEW
parameter_list|(
name|NEW
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantClass
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Expecting a CONSTANT_Class operand, but found a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ConstantUtf8
name|cutf8
init|=
operator|(
name|ConstantUtf8
operator|)
operator|(
name|cpg
operator|.
name|getConstant
argument_list|(
operator|(
operator|(
name|ConstantClass
operator|)
name|c
operator|)
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
decl_stmt|;
name|Type
name|t
init|=
name|Type
operator|.
name|getType
argument_list|(
literal|"L"
operator|+
name|cutf8
operator|.
name|getBytes
argument_list|()
operator|+
literal|";"
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"NEW must not be used to create an array."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitMULTIANEWARRAY
parameter_list|(
name|MULTIANEWARRAY
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantClass
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Expecting a CONSTANT_Class operand, but found a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
name|int
name|dimensions2create
init|=
name|o
operator|.
name|getDimensions
argument_list|()
decl_stmt|;
if|if
condition|(
name|dimensions2create
operator|<
literal|1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Number of dimensions to create must be greater than zero."
argument_list|)
expr_stmt|;
block|}
name|Type
name|t
init|=
name|o
operator|.
name|getType
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
block|{
name|int
name|dimensions
init|=
operator|(
operator|(
name|ArrayType
operator|)
name|t
operator|)
operator|.
name|getDimensions
argument_list|()
decl_stmt|;
if|if
condition|(
name|dimensions
operator|<
name|dimensions2create
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Not allowed to create array with more dimensions ('+dimensions2create+') than the one referenced by the CONSTANT_Class '"
operator|+
name|t
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Expecting a CONSTANT_Class referencing an array type. [Constraint not found in The Java Virtual Machine Specification, Second Edition, 4.8.1]"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitANEWARRAY
parameter_list|(
name|ANEWARRAY
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantClass
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Expecting a CONSTANT_Class operand, but found a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
name|Type
name|t
init|=
name|o
operator|.
name|getType
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
block|{
name|int
name|dimensions
init|=
operator|(
operator|(
name|ArrayType
operator|)
name|t
operator|)
operator|.
name|getDimensions
argument_list|()
decl_stmt|;
if|if
condition|(
name|dimensions
operator|>=
literal|255
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Not allowed to create an array with more than 255 dimensions."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitNEWARRAY
parameter_list|(
name|NEWARRAY
name|o
parameter_list|)
block|{
name|byte
name|t
init|=
name|o
operator|.
name|getTypecode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|t
operator|==
name|Constants
operator|.
name|T_BOOLEAN
operator|)
operator|||
operator|(
name|t
operator|==
name|Constants
operator|.
name|T_CHAR
operator|)
operator|||
operator|(
name|t
operator|==
name|Constants
operator|.
name|T_FLOAT
operator|)
operator|||
operator|(
name|t
operator|==
name|Constants
operator|.
name|T_DOUBLE
operator|)
operator|||
operator|(
name|t
operator|==
name|Constants
operator|.
name|T_BYTE
operator|)
operator|||
operator|(
name|t
operator|==
name|Constants
operator|.
name|T_SHORT
operator|)
operator|||
operator|(
name|t
operator|==
name|Constants
operator|.
name|T_INT
operator|)
operator|||
operator|(
name|t
operator|==
name|Constants
operator|.
name|T_LONG
operator|)
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Illegal type code '+t+' for 'atype' operand."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitILOAD
parameter_list|(
name|ILOAD
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitFLOAD
parameter_list|(
name|FLOAD
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitALOAD
parameter_list|(
name|ALOAD
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitISTORE
parameter_list|(
name|ISTORE
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitFSTORE
parameter_list|(
name|FSTORE
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitASTORE
parameter_list|(
name|ASTORE
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitIINC
parameter_list|(
name|IINC
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitRET
parameter_list|(
name|RET
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitLLOAD
parameter_list|(
name|LLOAD
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus2
init|=
name|max_locals
argument_list|()
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus2
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-2 '"
operator|+
name|maxminus2
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitDLOAD
parameter_list|(
name|DLOAD
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus2
init|=
name|max_locals
argument_list|()
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus2
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-2 '"
operator|+
name|maxminus2
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitLSTORE
parameter_list|(
name|LSTORE
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus2
init|=
name|max_locals
argument_list|()
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus2
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-2 '"
operator|+
name|maxminus2
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitDSTORE
parameter_list|(
name|DSTORE
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative. [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus2
init|=
name|max_locals
argument_list|()
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus2
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-2 '"
operator|+
name|maxminus2
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitLOOKUPSWITCH
parameter_list|(
name|LOOKUPSWITCH
name|o
parameter_list|)
block|{
name|int
index|[]
name|matchs
init|=
name|o
operator|.
name|getMatchs
argument_list|()
decl_stmt|;
name|int
name|max
init|=
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|matchs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matchs
index|[
name|i
index|]
operator|==
name|max
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Match '"
operator|+
name|matchs
index|[
name|i
index|]
operator|+
literal|"' occurs more than once."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|matchs
index|[
name|i
index|]
operator|<
name|max
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Lookup table must be sorted but isn't."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
name|matchs
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitTABLESWITCH
parameter_list|(
name|TABLESWITCH
name|o
parameter_list|)
block|{
comment|// "high" must be>= "low". We cannot check this, as BCEL hides
comment|// it from us.
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitPUTSTATIC
parameter_list|(
name|PUTSTATIC
name|o
parameter_list|)
block|{
name|String
name|field_name
init|=
name|o
operator|.
name|getFieldName
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|o
operator|.
name|getClassType
argument_list|(
name|cpg
argument_list|)
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|Field
index|[]
name|fields
init|=
name|jc
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|Field
name|f
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fields
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|field_name
argument_list|)
condition|)
block|{
name|f
operator|=
name|fields
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Field not found?!?"
argument_list|)
throw|;
block|}
if|if
condition|(
name|f
operator|.
name|isFinal
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|myOwner
operator|.
name|getClassName
argument_list|()
operator|.
name|equals
argument_list|(
name|o
operator|.
name|getClassType
argument_list|(
name|cpg
argument_list|)
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced field '"
operator|+
name|f
operator|+
literal|"' is final and must therefore be declared in the current class '"
operator|+
name|myOwner
operator|.
name|getClassName
argument_list|()
operator|+
literal|"' which is not the case: it is declared in '"
operator|+
name|o
operator|.
name|getClassType
argument_list|(
name|cpg
argument_list|)
operator|.
name|getClassName
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|f
operator|.
name|isStatic
argument_list|()
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced field '"
operator|+
name|f
operator|+
literal|"' is not static which it should be."
argument_list|)
expr_stmt|;
block|}
name|String
name|meth_name
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|getMethods
argument_list|()
index|[
name|method_no
index|]
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// If it's an interface, it can be set only in<clinit>.
if|if
condition|(
operator|(
operator|!
operator|(
name|jc
operator|.
name|isClass
argument_list|()
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|meth_name
operator|.
name|equals
argument_list|(
name|Constants
operator|.
name|STATIC_INITIALIZER_NAME
argument_list|)
operator|)
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Interface field '"
operator|+
name|f
operator|+
literal|"' must be set in a '"
operator|+
name|Constants
operator|.
name|STATIC_INITIALIZER_NAME
operator|+
literal|"' method."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitGETSTATIC
parameter_list|(
name|GETSTATIC
name|o
parameter_list|)
block|{
name|String
name|field_name
init|=
name|o
operator|.
name|getFieldName
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|o
operator|.
name|getClassType
argument_list|(
name|cpg
argument_list|)
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|Field
index|[]
name|fields
init|=
name|jc
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|Field
name|f
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fields
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|field_name
argument_list|)
condition|)
block|{
name|f
operator|=
name|fields
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Field not found?!?"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|f
operator|.
name|isStatic
argument_list|()
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced field '"
operator|+
name|f
operator|+
literal|"' is not static which it should be."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Checks if the constraints of operands of the said instruction(s) are satisfied. */
comment|//public void visitPUTFIELD(PUTFIELD o){
comment|// for performance reasons done in Pass 3b
comment|//}
comment|/* Checks if the constraints of operands of the said instruction(s) are satisfied. */
comment|//public void visitGETFIELD(GETFIELD o){
comment|// for performance reasons done in Pass 3b
comment|//}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitINVOKEINTERFACE
parameter_list|(
name|INVOKEINTERFACE
name|o
parameter_list|)
block|{
comment|// INVOKEINTERFACE is a LoadClass; the Class where the referenced method is declared in,
comment|// is therefore resolved/verified.
comment|// INVOKEINTERFACE is an InvokeInstruction, the argument and return types are resolved/verified,
comment|// too. So are the allowed method names.
name|String
name|classname
init|=
name|o
operator|.
name|getClassName
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|classname
argument_list|)
decl_stmt|;
name|Method
index|[]
name|ms
init|=
name|jc
operator|.
name|getMethods
argument_list|()
decl_stmt|;
name|Method
name|m
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ms
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ms
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|Type
operator|.
name|getReturnType
argument_list|(
name|ms
index|[
name|i
index|]
operator|.
name|getSignature
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|o
operator|.
name|getReturnType
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|objarrayequals
argument_list|(
name|Type
operator|.
name|getArgumentTypes
argument_list|(
name|ms
index|[
name|i
index|]
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|o
operator|.
name|getArgumentTypes
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|m
operator|=
name|ms
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced method '"
operator|+
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' with expected signature not found in class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"'. The native verfier does allow the method to be declared in some superinterface, which the Java Virtual Machine Specification, Second Edition does not."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|jc
operator|.
name|isClass
argument_list|()
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"' is a class, but not an interface as expected."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitINVOKESPECIAL
parameter_list|(
name|INVOKESPECIAL
name|o
parameter_list|)
block|{
comment|// INVOKESPECIAL is a LoadClass; the Class where the referenced method is declared in,
comment|// is therefore resolved/verified.
comment|// INVOKESPECIAL is an InvokeInstruction, the argument and return types are resolved/verified,
comment|// too. So are the allowed method names.
name|String
name|classname
init|=
name|o
operator|.
name|getClassName
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|classname
argument_list|)
decl_stmt|;
name|Method
index|[]
name|ms
init|=
name|jc
operator|.
name|getMethods
argument_list|()
decl_stmt|;
name|Method
name|m
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ms
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ms
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|Type
operator|.
name|getReturnType
argument_list|(
name|ms
index|[
name|i
index|]
operator|.
name|getSignature
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|o
operator|.
name|getReturnType
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|objarrayequals
argument_list|(
name|Type
operator|.
name|getArgumentTypes
argument_list|(
name|ms
index|[
name|i
index|]
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|o
operator|.
name|getArgumentTypes
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|m
operator|=
name|ms
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced method '"
operator|+
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' with expected signature not found in class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"'. The native verfier does allow the method to be declared in some superclass or implemented interface, which the Java Virtual Machine Specification, Second Edition does not."
argument_list|)
expr_stmt|;
block|}
name|JavaClass
name|current
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|.
name|isSuper
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|Repository
operator|.
name|instanceOf
argument_list|(
name|current
argument_list|,
name|jc
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|current
operator|.
name|equals
argument_list|(
name|jc
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
operator|.
name|equals
argument_list|(
name|Constants
operator|.
name|CONSTRUCTOR_NAME
argument_list|)
operator|)
condition|)
block|{
comment|// Special lookup procedure for ACC_SUPER classes.
name|int
name|supidx
init|=
operator|-
literal|1
decl_stmt|;
name|Method
name|meth
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|supidx
operator|!=
literal|0
condition|)
block|{
name|supidx
operator|=
name|current
operator|.
name|getSuperclassNameIndex
argument_list|()
expr_stmt|;
name|current
operator|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|current
operator|.
name|getSuperclassName
argument_list|()
argument_list|)
expr_stmt|;
name|Method
index|[]
name|meths
init|=
name|current
operator|.
name|getMethods
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|meths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|meths
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|Type
operator|.
name|getReturnType
argument_list|(
name|meths
index|[
name|i
index|]
operator|.
name|getSignature
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|o
operator|.
name|getReturnType
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|objarrayequals
argument_list|(
name|Type
operator|.
name|getArgumentTypes
argument_list|(
name|meths
index|[
name|i
index|]
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|o
operator|.
name|getArgumentTypes
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|meth
operator|=
name|meths
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|meth
operator|!=
literal|null
condition|)
break|break;
block|}
if|if
condition|(
name|meth
operator|==
literal|null
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"ACC_SUPER special lookup procedure not successful: method '"
operator|+
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' with proper signature not declared in superclass hierarchy."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitINVOKESTATIC
parameter_list|(
name|INVOKESTATIC
name|o
parameter_list|)
block|{
comment|// INVOKESTATIC is a LoadClass; the Class where the referenced method is declared in,
comment|// is therefore resolved/verified.
comment|// INVOKESTATIC is an InvokeInstruction, the argument and return types are resolved/verified,
comment|// too. So are the allowed method names.
name|String
name|classname
init|=
name|o
operator|.
name|getClassName
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|classname
argument_list|)
decl_stmt|;
name|Method
index|[]
name|ms
init|=
name|jc
operator|.
name|getMethods
argument_list|()
decl_stmt|;
name|Method
name|m
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ms
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ms
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|Type
operator|.
name|getReturnType
argument_list|(
name|ms
index|[
name|i
index|]
operator|.
name|getSignature
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|o
operator|.
name|getReturnType
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|objarrayequals
argument_list|(
name|Type
operator|.
name|getArgumentTypes
argument_list|(
name|ms
index|[
name|i
index|]
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|o
operator|.
name|getArgumentTypes
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|m
operator|=
name|ms
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced method '"
operator|+
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' with expected signature not found in class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"'. The native verifier possibly allows the method to be declared in some superclass or implemented interface, which the Java Virtual Machine Specification, Second Edition does not."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|m
operator|.
name|isStatic
argument_list|()
operator|)
condition|)
block|{
comment|// implies it's not abstract, verified in pass 2.
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced method '"
operator|+
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' has ACC_STATIC unset."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
specifier|public
name|void
name|visitINVOKEVIRTUAL
parameter_list|(
name|INVOKEVIRTUAL
name|o
parameter_list|)
block|{
comment|// INVOKEVIRTUAL is a LoadClass; the Class where the referenced method is declared in,
comment|// is therefore resolved/verified.
comment|// INVOKEVIRTUAL is an InvokeInstruction, the argument and return types are resolved/verified,
comment|// too. So are the allowed method names.
name|String
name|classname
init|=
name|o
operator|.
name|getClassName
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|classname
argument_list|)
decl_stmt|;
name|Method
index|[]
name|ms
init|=
name|jc
operator|.
name|getMethods
argument_list|()
decl_stmt|;
name|Method
name|m
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ms
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ms
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|Type
operator|.
name|getReturnType
argument_list|(
name|ms
index|[
name|i
index|]
operator|.
name|getSignature
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|o
operator|.
name|getReturnType
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|objarrayequals
argument_list|(
name|Type
operator|.
name|getArgumentTypes
argument_list|(
name|ms
index|[
name|i
index|]
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|o
operator|.
name|getArgumentTypes
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|m
operator|=
name|ms
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced method '"
operator|+
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' with expected signature not found in class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"'. The native verfier does allow the method to be declared in some superclass or implemented interface, which the Java Virtual Machine Specification, Second Edition does not."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|jc
operator|.
name|isClass
argument_list|()
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"' is an interface, but not a class as expected."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// WIDE stuff is BCEL-internal and cannot be checked here.
comment|/** 		 * A utility method like equals(Object) for arrays. 		 * The equality of the elements is based on their equals(Object) 		 * method instead of their object identity. 		 */
specifier|private
name|boolean
name|objarrayequals
parameter_list|(
name|Object
index|[]
name|o
parameter_list|,
name|Object
index|[]
name|p
parameter_list|)
block|{
if|if
condition|(
name|o
operator|.
name|length
operator|!=
name|p
operator|.
name|length
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|o
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
end_class

end_unit

