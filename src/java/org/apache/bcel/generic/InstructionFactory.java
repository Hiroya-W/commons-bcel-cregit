begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
package|;
end_package

begin_comment
comment|/* ====================================================================  * The Apache Software License, Version 1.1  *  * Copyright (c) 2001 The Apache Software Foundation.  All rights  * reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. The end-user documentation included with the redistribution,  *    if any, must include the following acknowledgment:  *       "This product includes software developed by the  *        Apache Software Foundation (http://www.apache.org/)."  *    Alternately, this acknowledgment may appear in the software itself,  *    if and wherever such third-party acknowledgments normally appear.  *  * 4. The names "Apache" and "Apache Software Foundation" and  *    "Apache BCEL" must not be used to endorse or promote products  *    derived from this software without prior written permission. For  *    written permission, please contact apache@apache.org.  *  * 5. Products derived from this software may not be called "Apache",  *    "Apache BCEL", nor may "Apache" appear in their name, without  *    prior written permission of the Apache Software Foundation.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * ====================================================================  *  * This software consists of voluntary contributions made by many  * individuals on behalf of the Apache Software Foundation.  For more  * information on the Apache Software Foundation, please see  *<http://www.apache.org/>.  */
end_comment

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|Constants
import|;
end_import

begin_comment
comment|/**   * Instances of this class may be used, e.g., to generate typed  * versions of instructions. Its main purpose is to be used as the  * byte code generating backend of a compiler. You can subclass it to  * add your own create methods.  *  * @version $Id$  * @author<A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>  * @see Constants  */
end_comment

begin_class
specifier|public
class|class
name|InstructionFactory
implements|implements
name|InstructionConstants
implements|,
name|java
operator|.
name|io
operator|.
name|Serializable
block|{
specifier|protected
name|ClassGen
name|cg
decl_stmt|;
specifier|protected
name|ConstantPoolGen
name|cp
decl_stmt|;
specifier|public
name|InstructionFactory
parameter_list|(
name|ClassGen
name|cg
parameter_list|,
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
name|this
operator|.
name|cg
operator|=
name|cg
expr_stmt|;
name|this
operator|.
name|cp
operator|=
name|cp
expr_stmt|;
block|}
comment|/** Initialize with ClassGen object    */
specifier|public
name|InstructionFactory
parameter_list|(
name|ClassGen
name|cg
parameter_list|)
block|{
name|this
argument_list|(
name|cg
argument_list|,
name|cg
operator|.
name|getConstantPool
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Initialize just with ConstantPoolGen object    */
specifier|public
name|InstructionFactory
parameter_list|(
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/** Create an invoke instruction.    *    * @param class_name name of the called class    * @param name name of the called method    * @param ret_type return type of method    * @param arg_types argument types of method    * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL,    * or INVOKESPECIAL    * @see Constants    */
specifier|public
name|InvokeInstruction
name|createInvoke
parameter_list|(
name|String
name|class_name
parameter_list|,
name|String
name|name
parameter_list|,
name|Type
name|ret_type
parameter_list|,
name|Type
index|[]
name|arg_types
parameter_list|,
name|short
name|kind
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|int
name|nargs
init|=
literal|0
decl_stmt|;
name|String
name|signature
init|=
name|Type
operator|.
name|getMethodSignature
argument_list|(
name|ret_type
argument_list|,
name|arg_types
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arg_types
operator|.
name|length
condition|;
name|i
operator|++
control|)
comment|// Count size of arguments
name|nargs
operator|+=
name|arg_types
index|[
name|i
index|]
operator|.
name|getSize
argument_list|()
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|Constants
operator|.
name|INVOKEINTERFACE
condition|)
name|index
operator|=
name|cp
operator|.
name|addInterfaceMethodref
argument_list|(
name|class_name
argument_list|,
name|name
argument_list|,
name|signature
argument_list|)
expr_stmt|;
else|else
name|index
operator|=
name|cp
operator|.
name|addMethodref
argument_list|(
name|class_name
argument_list|,
name|name
argument_list|,
name|signature
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|Constants
operator|.
name|INVOKESPECIAL
case|:
return|return
operator|new
name|INVOKESPECIAL
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Constants
operator|.
name|INVOKEVIRTUAL
case|:
return|return
operator|new
name|INVOKEVIRTUAL
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Constants
operator|.
name|INVOKESTATIC
case|:
return|return
operator|new
name|INVOKESTATIC
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Constants
operator|.
name|INVOKEINTERFACE
case|:
return|return
operator|new
name|INVOKEINTERFACE
argument_list|(
name|index
argument_list|,
name|nargs
operator|+
literal|1
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Oops: Unknown invoke kind:"
operator|+
name|kind
argument_list|)
throw|;
block|}
block|}
comment|/** Create a call to the most popular System.out.println() method.    *    * @param s the string to print    */
specifier|public
name|InstructionList
name|createPrintln
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|InstructionList
name|il
init|=
operator|new
name|InstructionList
argument_list|()
decl_stmt|;
name|int
name|out
init|=
name|cp
operator|.
name|addFieldref
argument_list|(
literal|"java.lang.System"
argument_list|,
literal|"out"
argument_list|,
literal|"Ljava/io/PrintStream;"
argument_list|)
decl_stmt|;
name|int
name|println
init|=
name|cp
operator|.
name|addMethodref
argument_list|(
literal|"java.io.PrintStream"
argument_list|,
literal|"println"
argument_list|,
literal|"(Ljava/lang/String;)V"
argument_list|)
decl_stmt|;
name|il
operator|.
name|append
argument_list|(
operator|new
name|GETSTATIC
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
operator|new
name|PUSH
argument_list|(
name|cp
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
operator|new
name|INVOKEVIRTUAL
argument_list|(
name|println
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|il
return|;
block|}
comment|/** Uses PUSH to push a constant value onto the stack.    * @param value must be of type Number, Boolean, Character or String    */
specifier|public
name|Instruction
name|createConstant
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
name|PUSH
name|push
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
name|push
operator|=
operator|new
name|PUSH
argument_list|(
name|cp
argument_list|,
operator|(
name|Number
operator|)
name|value
argument_list|)
expr_stmt|;
if|else if
condition|(
name|value
operator|instanceof
name|String
condition|)
name|push
operator|=
operator|new
name|PUSH
argument_list|(
name|cp
argument_list|,
operator|(
name|String
operator|)
name|value
argument_list|)
expr_stmt|;
if|else if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
name|push
operator|=
operator|new
name|PUSH
argument_list|(
name|cp
argument_list|,
operator|(
name|Boolean
operator|)
name|value
argument_list|)
expr_stmt|;
if|else if
condition|(
name|value
operator|instanceof
name|Character
condition|)
name|push
operator|=
operator|new
name|PUSH
argument_list|(
name|cp
argument_list|,
operator|(
name|Character
operator|)
name|value
argument_list|)
expr_stmt|;
else|else
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Illegal type: "
operator|+
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
return|return
name|push
operator|.
name|getInstruction
argument_list|()
return|;
block|}
specifier|private
specifier|static
class|class
name|MethodObject
block|{
name|Type
index|[]
name|arg_types
decl_stmt|;
name|Type
name|result_type
decl_stmt|;
name|String
index|[]
name|arg_names
decl_stmt|;
name|String
name|class_name
decl_stmt|;
name|String
name|name
decl_stmt|;
name|int
name|access
decl_stmt|;
name|MethodObject
parameter_list|(
name|String
name|c
parameter_list|,
name|String
name|n
parameter_list|,
name|Type
name|r
parameter_list|,
name|Type
index|[]
name|a
parameter_list|,
name|int
name|acc
parameter_list|)
block|{
name|class_name
operator|=
name|c
expr_stmt|;
name|name
operator|=
name|n
expr_stmt|;
name|result_type
operator|=
name|r
expr_stmt|;
name|arg_types
operator|=
name|a
expr_stmt|;
name|access
operator|=
name|acc
expr_stmt|;
block|}
block|}
specifier|private
name|InvokeInstruction
name|createInvoke
parameter_list|(
name|MethodObject
name|m
parameter_list|,
name|short
name|kind
parameter_list|)
block|{
return|return
name|createInvoke
argument_list|(
name|m
operator|.
name|class_name
argument_list|,
name|m
operator|.
name|name
argument_list|,
name|m
operator|.
name|result_type
argument_list|,
name|m
operator|.
name|arg_types
argument_list|,
name|kind
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|MethodObject
index|[]
name|append_mos
init|=
block|{
operator|new
name|MethodObject
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"append"
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|STRING
block|}
argument_list|,
name|Constants
operator|.
name|ACC_PUBLIC
argument_list|)
block|,
operator|new
name|MethodObject
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"append"
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|OBJECT
block|}
argument_list|,
name|Constants
operator|.
name|ACC_PUBLIC
argument_list|)
block|,
literal|null
block|,
literal|null
block|,
comment|// indices 2, 3
operator|new
name|MethodObject
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"append"
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|BOOLEAN
block|}
argument_list|,
name|Constants
operator|.
name|ACC_PUBLIC
argument_list|)
block|,
operator|new
name|MethodObject
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"append"
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|CHAR
block|}
argument_list|,
name|Constants
operator|.
name|ACC_PUBLIC
argument_list|)
block|,
operator|new
name|MethodObject
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"append"
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|FLOAT
block|}
argument_list|,
name|Constants
operator|.
name|ACC_PUBLIC
argument_list|)
block|,
operator|new
name|MethodObject
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"append"
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|DOUBLE
block|}
argument_list|,
name|Constants
operator|.
name|ACC_PUBLIC
argument_list|)
block|,
operator|new
name|MethodObject
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"append"
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|INT
block|}
argument_list|,
name|Constants
operator|.
name|ACC_PUBLIC
argument_list|)
block|,
operator|new
name|MethodObject
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"append"
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
comment|// No append(byte)
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|INT
block|}
argument_list|,
name|Constants
operator|.
name|ACC_PUBLIC
argument_list|)
block|,
operator|new
name|MethodObject
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"append"
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
comment|// No append(short)
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|INT
block|}
argument_list|,
name|Constants
operator|.
name|ACC_PUBLIC
argument_list|)
block|,
operator|new
name|MethodObject
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"append"
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|LONG
block|}
argument_list|,
name|Constants
operator|.
name|ACC_PUBLIC
argument_list|)
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|isString
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
return|return
operator|(
operator|(
name|type
operator|instanceof
name|ObjectType
operator|)
operator|&&
operator|(
operator|(
name|ObjectType
operator|)
name|type
operator|)
operator|.
name|getClassName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"java.lang.String"
argument_list|)
operator|)
return|;
block|}
specifier|public
name|Instruction
name|createAppend
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
name|byte
name|t
init|=
name|type
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|isString
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|createInvoke
argument_list|(
name|append_mos
index|[
literal|0
index|]
argument_list|,
name|Constants
operator|.
name|INVOKEVIRTUAL
argument_list|)
return|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|Constants
operator|.
name|T_BOOLEAN
case|:
case|case
name|Constants
operator|.
name|T_CHAR
case|:
case|case
name|Constants
operator|.
name|T_FLOAT
case|:
case|case
name|Constants
operator|.
name|T_DOUBLE
case|:
case|case
name|Constants
operator|.
name|T_BYTE
case|:
case|case
name|Constants
operator|.
name|T_SHORT
case|:
case|case
name|Constants
operator|.
name|T_INT
case|:
case|case
name|Constants
operator|.
name|T_LONG
case|:
return|return
name|createInvoke
argument_list|(
name|append_mos
index|[
name|t
index|]
argument_list|,
name|Constants
operator|.
name|INVOKEVIRTUAL
argument_list|)
return|;
case|case
name|Constants
operator|.
name|T_ARRAY
case|:
case|case
name|Constants
operator|.
name|T_OBJECT
case|:
return|return
name|createInvoke
argument_list|(
name|append_mos
index|[
literal|1
index|]
argument_list|,
name|Constants
operator|.
name|INVOKEVIRTUAL
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Oops: No append for this type? "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/** Create a field instruction.    *    * @param class_name name of the accessed class    * @param name name of the referenced field    * @param type  type of field    * @param kind how to access, i.e., GETFIELD, PUTFIELD, GETSTATIC, PUTSTATIC    * @see Constants    */
specifier|public
name|FieldInstruction
name|createFieldAccess
parameter_list|(
name|String
name|class_name
parameter_list|,
name|String
name|name
parameter_list|,
name|Type
name|type
parameter_list|,
name|short
name|kind
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|String
name|signature
init|=
name|type
operator|.
name|getSignature
argument_list|()
decl_stmt|;
name|index
operator|=
name|cp
operator|.
name|addFieldref
argument_list|(
name|class_name
argument_list|,
name|name
argument_list|,
name|signature
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|Constants
operator|.
name|GETFIELD
case|:
return|return
operator|new
name|GETFIELD
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Constants
operator|.
name|PUTFIELD
case|:
return|return
operator|new
name|PUTFIELD
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Constants
operator|.
name|GETSTATIC
case|:
return|return
operator|new
name|GETSTATIC
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Constants
operator|.
name|PUTSTATIC
case|:
return|return
operator|new
name|PUTSTATIC
argument_list|(
name|index
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Oops: Unknown getfield kind:"
operator|+
name|kind
argument_list|)
throw|;
block|}
block|}
comment|/** Create reference to `this'    */
specifier|public
specifier|static
name|Instruction
name|createThis
parameter_list|()
block|{
return|return
operator|new
name|ALOAD
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/** Create typed return    */
specifier|public
specifier|static
name|ReturnInstruction
name|createReturn
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Constants
operator|.
name|T_ARRAY
case|:
case|case
name|Constants
operator|.
name|T_OBJECT
case|:
return|return
name|ARETURN
return|;
case|case
name|Constants
operator|.
name|T_INT
case|:
case|case
name|Constants
operator|.
name|T_SHORT
case|:
case|case
name|Constants
operator|.
name|T_BOOLEAN
case|:
case|case
name|Constants
operator|.
name|T_CHAR
case|:
case|case
name|Constants
operator|.
name|T_BYTE
case|:
return|return
name|IRETURN
return|;
case|case
name|Constants
operator|.
name|T_FLOAT
case|:
return|return
name|FRETURN
return|;
case|case
name|Constants
operator|.
name|T_DOUBLE
case|:
return|return
name|DRETURN
return|;
case|case
name|Constants
operator|.
name|T_LONG
case|:
return|return
name|LRETURN
return|;
case|case
name|Constants
operator|.
name|T_VOID
case|:
return|return
name|RETURN
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid type: "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|ArithmeticInstruction
name|createBinaryIntOp
parameter_list|(
name|char
name|first
parameter_list|,
name|String
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|first
condition|)
block|{
case|case
literal|'-'
case|:
return|return
name|ISUB
return|;
case|case
literal|'+'
case|:
return|return
name|IADD
return|;
case|case
literal|'%'
case|:
return|return
name|IREM
return|;
case|case
literal|'*'
case|:
return|return
name|IMUL
return|;
case|case
literal|'/'
case|:
return|return
name|IDIV
return|;
case|case
literal|'&'
case|:
return|return
name|IAND
return|;
case|case
literal|'|'
case|:
return|return
name|IOR
return|;
case|case
literal|'^'
case|:
return|return
name|IXOR
return|;
case|case
literal|'<'
case|:
return|return
name|ISHL
return|;
case|case
literal|'>'
case|:
return|return
name|op
operator|.
name|equals
argument_list|(
literal|">>>"
argument_list|)
condition|?
operator|(
name|ArithmeticInstruction
operator|)
name|IUSHR
else|:
operator|(
name|ArithmeticInstruction
operator|)
name|ISHR
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid operand "
operator|+
name|op
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|ArithmeticInstruction
name|createBinaryLongOp
parameter_list|(
name|char
name|first
parameter_list|,
name|String
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|first
condition|)
block|{
case|case
literal|'-'
case|:
return|return
name|LSUB
return|;
case|case
literal|'+'
case|:
return|return
name|LADD
return|;
case|case
literal|'%'
case|:
return|return
name|LREM
return|;
case|case
literal|'*'
case|:
return|return
name|LMUL
return|;
case|case
literal|'/'
case|:
return|return
name|LDIV
return|;
case|case
literal|'&'
case|:
return|return
name|LAND
return|;
case|case
literal|'|'
case|:
return|return
name|LOR
return|;
case|case
literal|'^'
case|:
return|return
name|LXOR
return|;
case|case
literal|'<'
case|:
return|return
name|LSHL
return|;
case|case
literal|'>'
case|:
return|return
name|op
operator|.
name|equals
argument_list|(
literal|">>>"
argument_list|)
condition|?
operator|(
name|ArithmeticInstruction
operator|)
name|LUSHR
else|:
operator|(
name|ArithmeticInstruction
operator|)
name|LSHR
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid operand "
operator|+
name|op
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|ArithmeticInstruction
name|createBinaryFloatOp
parameter_list|(
name|char
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'-'
case|:
return|return
name|FSUB
return|;
case|case
literal|'+'
case|:
return|return
name|FADD
return|;
case|case
literal|'*'
case|:
return|return
name|FMUL
return|;
case|case
literal|'/'
case|:
return|return
name|FDIV
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid operand "
operator|+
name|op
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|ArithmeticInstruction
name|createBinaryDoubleOp
parameter_list|(
name|char
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'-'
case|:
return|return
name|DSUB
return|;
case|case
literal|'+'
case|:
return|return
name|DADD
return|;
case|case
literal|'*'
case|:
return|return
name|DMUL
return|;
case|case
literal|'/'
case|:
return|return
name|DDIV
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid operand "
operator|+
name|op
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create binary operation for simple basic types, such as int and float.    *    * @param op operation, such as "+", "*", "<<", etc.    */
specifier|public
specifier|static
name|ArithmeticInstruction
name|createBinaryOperation
parameter_list|(
name|String
name|op
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
name|char
name|first
init|=
name|op
operator|.
name|toCharArray
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
switch|switch
condition|(
name|type
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Constants
operator|.
name|T_BYTE
case|:
case|case
name|Constants
operator|.
name|T_SHORT
case|:
case|case
name|Constants
operator|.
name|T_INT
case|:
case|case
name|Constants
operator|.
name|T_CHAR
case|:
return|return
name|createBinaryIntOp
argument_list|(
name|first
argument_list|,
name|op
argument_list|)
return|;
case|case
name|Constants
operator|.
name|T_LONG
case|:
return|return
name|createBinaryLongOp
argument_list|(
name|first
argument_list|,
name|op
argument_list|)
return|;
case|case
name|Constants
operator|.
name|T_FLOAT
case|:
return|return
name|createBinaryFloatOp
argument_list|(
name|first
argument_list|)
return|;
case|case
name|Constants
operator|.
name|T_DOUBLE
case|:
return|return
name|createBinaryDoubleOp
argument_list|(
name|first
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/**    * @param size size of operand, either 1 (int, e.g.) or 2 (double)    */
specifier|public
specifier|static
name|StackInstruction
name|createPop
parameter_list|(
name|int
name|size
parameter_list|)
block|{
return|return
operator|(
name|size
operator|==
literal|2
operator|)
condition|?
operator|(
name|StackInstruction
operator|)
name|POP2
else|:
operator|(
name|StackInstruction
operator|)
name|POP
return|;
block|}
comment|/**    * @param size size of operand, either 1 (int, e.g.) or 2 (double)    */
specifier|public
specifier|static
name|StackInstruction
name|createDup
parameter_list|(
name|int
name|size
parameter_list|)
block|{
return|return
operator|(
name|size
operator|==
literal|2
operator|)
condition|?
operator|(
name|StackInstruction
operator|)
name|DUP2
else|:
operator|(
name|StackInstruction
operator|)
name|DUP
return|;
block|}
comment|/**    * @param size size of operand, either 1 (int, e.g.) or 2 (double)    */
specifier|public
specifier|static
name|StackInstruction
name|createDup_2
parameter_list|(
name|int
name|size
parameter_list|)
block|{
return|return
operator|(
name|size
operator|==
literal|2
operator|)
condition|?
operator|(
name|StackInstruction
operator|)
name|DUP2_X2
else|:
operator|(
name|StackInstruction
operator|)
name|DUP_X2
return|;
block|}
comment|/**    * @param size size of operand, either 1 (int, e.g.) or 2 (double)    */
specifier|public
specifier|static
name|StackInstruction
name|createDup_1
parameter_list|(
name|int
name|size
parameter_list|)
block|{
return|return
operator|(
name|size
operator|==
literal|2
operator|)
condition|?
operator|(
name|StackInstruction
operator|)
name|DUP2_X1
else|:
operator|(
name|StackInstruction
operator|)
name|DUP_X1
return|;
block|}
comment|/**    * @param index index of local variable    */
specifier|public
specifier|static
name|LocalVariableInstruction
name|createStore
parameter_list|(
name|Type
name|type
parameter_list|,
name|int
name|index
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Constants
operator|.
name|T_BOOLEAN
case|:
case|case
name|Constants
operator|.
name|T_CHAR
case|:
case|case
name|Constants
operator|.
name|T_BYTE
case|:
case|case
name|Constants
operator|.
name|T_SHORT
case|:
case|case
name|Constants
operator|.
name|T_INT
case|:
return|return
operator|new
name|ISTORE
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Constants
operator|.
name|T_FLOAT
case|:
return|return
operator|new
name|FSTORE
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Constants
operator|.
name|T_DOUBLE
case|:
return|return
operator|new
name|DSTORE
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Constants
operator|.
name|T_LONG
case|:
return|return
operator|new
name|LSTORE
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Constants
operator|.
name|T_ARRAY
case|:
case|case
name|Constants
operator|.
name|T_OBJECT
case|:
return|return
operator|new
name|ASTORE
argument_list|(
name|index
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/**    * @param index index of local variable    */
specifier|public
specifier|static
name|LocalVariableInstruction
name|createLoad
parameter_list|(
name|Type
name|type
parameter_list|,
name|int
name|index
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Constants
operator|.
name|T_BOOLEAN
case|:
case|case
name|Constants
operator|.
name|T_CHAR
case|:
case|case
name|Constants
operator|.
name|T_BYTE
case|:
case|case
name|Constants
operator|.
name|T_SHORT
case|:
case|case
name|Constants
operator|.
name|T_INT
case|:
return|return
operator|new
name|ILOAD
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Constants
operator|.
name|T_FLOAT
case|:
return|return
operator|new
name|FLOAD
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Constants
operator|.
name|T_DOUBLE
case|:
return|return
operator|new
name|DLOAD
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Constants
operator|.
name|T_LONG
case|:
return|return
operator|new
name|LLOAD
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Constants
operator|.
name|T_ARRAY
case|:
case|case
name|Constants
operator|.
name|T_OBJECT
case|:
return|return
operator|new
name|ALOAD
argument_list|(
name|index
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/**    * @param type type of elements of array, i.e., array.getElementType()    */
specifier|public
specifier|static
name|ArrayInstruction
name|createArrayLoad
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Constants
operator|.
name|T_BOOLEAN
case|:
case|case
name|Constants
operator|.
name|T_BYTE
case|:
return|return
name|BALOAD
return|;
case|case
name|Constants
operator|.
name|T_CHAR
case|:
return|return
name|CALOAD
return|;
case|case
name|Constants
operator|.
name|T_SHORT
case|:
return|return
name|SALOAD
return|;
case|case
name|Constants
operator|.
name|T_INT
case|:
return|return
name|IALOAD
return|;
case|case
name|Constants
operator|.
name|T_FLOAT
case|:
return|return
name|FALOAD
return|;
case|case
name|Constants
operator|.
name|T_DOUBLE
case|:
return|return
name|DALOAD
return|;
case|case
name|Constants
operator|.
name|T_LONG
case|:
return|return
name|LALOAD
return|;
case|case
name|Constants
operator|.
name|T_ARRAY
case|:
case|case
name|Constants
operator|.
name|T_OBJECT
case|:
return|return
name|AALOAD
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/**    * @param type type of elements of array, i.e., array.getElementType()    */
specifier|public
specifier|static
name|ArrayInstruction
name|createArrayStore
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Constants
operator|.
name|T_BOOLEAN
case|:
case|case
name|Constants
operator|.
name|T_BYTE
case|:
return|return
name|BASTORE
return|;
case|case
name|Constants
operator|.
name|T_CHAR
case|:
return|return
name|CASTORE
return|;
case|case
name|Constants
operator|.
name|T_SHORT
case|:
return|return
name|SASTORE
return|;
case|case
name|Constants
operator|.
name|T_INT
case|:
return|return
name|IASTORE
return|;
case|case
name|Constants
operator|.
name|T_FLOAT
case|:
return|return
name|FASTORE
return|;
case|case
name|Constants
operator|.
name|T_DOUBLE
case|:
return|return
name|DASTORE
return|;
case|case
name|Constants
operator|.
name|T_LONG
case|:
return|return
name|LASTORE
return|;
case|case
name|Constants
operator|.
name|T_ARRAY
case|:
case|case
name|Constants
operator|.
name|T_OBJECT
case|:
return|return
name|AASTORE
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/** Create conversion operation for two stack operands, this may be an I2C, instruction, e.g.,    * if the operands are basic types and CHECKCAST if they are reference types.    */
specifier|public
name|Instruction
name|createCast
parameter_list|(
name|Type
name|src_type
parameter_list|,
name|Type
name|dest_type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|src_type
operator|instanceof
name|BasicType
operator|)
operator|&&
operator|(
name|dest_type
operator|instanceof
name|BasicType
operator|)
condition|)
block|{
name|byte
name|dest
init|=
name|dest_type
operator|.
name|getType
argument_list|()
decl_stmt|;
name|byte
name|src
init|=
name|src_type
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|dest
operator|==
name|Constants
operator|.
name|T_LONG
operator|&&
operator|(
name|src
operator|==
name|Constants
operator|.
name|T_CHAR
operator|||
name|src
operator|==
name|Constants
operator|.
name|T_BYTE
operator|||
name|src
operator|==
name|Constants
operator|.
name|T_SHORT
operator|)
condition|)
name|src
operator|=
name|Constants
operator|.
name|T_INT
expr_stmt|;
name|String
index|[]
name|short_names
init|=
block|{
literal|"C"
block|,
literal|"F"
block|,
literal|"D"
block|,
literal|"B"
block|,
literal|"S"
block|,
literal|"I"
block|,
literal|"L"
block|}
decl_stmt|;
name|String
name|name
init|=
literal|"org.apache.bcel.generic."
operator|+
name|short_names
index|[
name|src
operator|-
name|Constants
operator|.
name|T_CHAR
index|]
operator|+
literal|"2"
operator|+
name|short_names
index|[
name|dest
operator|-
name|Constants
operator|.
name|T_CHAR
index|]
decl_stmt|;
name|Instruction
name|i
init|=
literal|null
decl_stmt|;
try|try
block|{
name|i
operator|=
operator|(
name|Instruction
operator|)
name|java
operator|.
name|lang
operator|.
name|Class
operator|.
name|forName
argument_list|(
name|name
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not find instruction: "
operator|+
name|name
argument_list|)
throw|;
block|}
return|return
name|i
return|;
block|}
if|else if
condition|(
operator|(
name|src_type
operator|instanceof
name|ReferenceType
operator|)
operator|&&
operator|(
name|dest_type
operator|instanceof
name|ReferenceType
operator|)
condition|)
block|{
if|if
condition|(
name|dest_type
operator|instanceof
name|ArrayType
condition|)
return|return
operator|new
name|CHECKCAST
argument_list|(
name|cp
operator|.
name|addArrayClass
argument_list|(
operator|(
name|ArrayType
operator|)
name|dest_type
argument_list|)
argument_list|)
return|;
else|else
return|return
operator|new
name|CHECKCAST
argument_list|(
name|cp
operator|.
name|addClass
argument_list|(
operator|(
operator|(
name|ObjectType
operator|)
name|dest_type
operator|)
operator|.
name|getClassName
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
else|else
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Can not cast "
operator|+
name|src_type
operator|+
literal|" to "
operator|+
name|dest_type
argument_list|)
throw|;
block|}
specifier|public
name|GETFIELD
name|createGetField
parameter_list|(
name|String
name|class_name
parameter_list|,
name|String
name|name
parameter_list|,
name|Type
name|t
parameter_list|)
block|{
return|return
operator|new
name|GETFIELD
argument_list|(
name|cp
operator|.
name|addFieldref
argument_list|(
name|class_name
argument_list|,
name|name
argument_list|,
name|t
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|GETSTATIC
name|createGetStatic
parameter_list|(
name|String
name|class_name
parameter_list|,
name|String
name|name
parameter_list|,
name|Type
name|t
parameter_list|)
block|{
return|return
operator|new
name|GETSTATIC
argument_list|(
name|cp
operator|.
name|addFieldref
argument_list|(
name|class_name
argument_list|,
name|name
argument_list|,
name|t
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|PUTFIELD
name|createPutField
parameter_list|(
name|String
name|class_name
parameter_list|,
name|String
name|name
parameter_list|,
name|Type
name|t
parameter_list|)
block|{
return|return
operator|new
name|PUTFIELD
argument_list|(
name|cp
operator|.
name|addFieldref
argument_list|(
name|class_name
argument_list|,
name|name
argument_list|,
name|t
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|PUTSTATIC
name|createPutStatic
parameter_list|(
name|String
name|class_name
parameter_list|,
name|String
name|name
parameter_list|,
name|Type
name|t
parameter_list|)
block|{
return|return
operator|new
name|PUTSTATIC
argument_list|(
name|cp
operator|.
name|addFieldref
argument_list|(
name|class_name
argument_list|,
name|name
argument_list|,
name|t
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|CHECKCAST
name|createCheckCast
parameter_list|(
name|ReferenceType
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
return|return
operator|new
name|CHECKCAST
argument_list|(
name|cp
operator|.
name|addArrayClass
argument_list|(
operator|(
name|ArrayType
operator|)
name|t
argument_list|)
argument_list|)
return|;
else|else
return|return
operator|new
name|CHECKCAST
argument_list|(
name|cp
operator|.
name|addClass
argument_list|(
operator|(
name|ObjectType
operator|)
name|t
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|INSTANCEOF
name|createInstanceOf
parameter_list|(
name|ReferenceType
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
return|return
operator|new
name|INSTANCEOF
argument_list|(
name|cp
operator|.
name|addArrayClass
argument_list|(
operator|(
name|ArrayType
operator|)
name|t
argument_list|)
argument_list|)
return|;
else|else
return|return
operator|new
name|INSTANCEOF
argument_list|(
name|cp
operator|.
name|addClass
argument_list|(
operator|(
name|ObjectType
operator|)
name|t
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|NEW
name|createNew
parameter_list|(
name|ObjectType
name|t
parameter_list|)
block|{
return|return
operator|new
name|NEW
argument_list|(
name|cp
operator|.
name|addClass
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|NEW
name|createNew
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|createNew
argument_list|(
operator|new
name|ObjectType
argument_list|(
name|s
argument_list|)
argument_list|)
return|;
block|}
comment|/** Create new array of given size and type.    * @return an instruction that creates the corresponding array at runtime, i.e. is an AllocationInstruction    */
specifier|public
name|Instruction
name|createNewArray
parameter_list|(
name|Type
name|t
parameter_list|,
name|short
name|dim
parameter_list|)
block|{
if|if
condition|(
name|dim
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|ObjectType
condition|)
return|return
operator|new
name|ANEWARRAY
argument_list|(
name|cp
operator|.
name|addClass
argument_list|(
operator|(
name|ObjectType
operator|)
name|t
argument_list|)
argument_list|)
return|;
if|else if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
return|return
operator|new
name|ANEWARRAY
argument_list|(
name|cp
operator|.
name|addArrayClass
argument_list|(
operator|(
name|ArrayType
operator|)
name|t
argument_list|)
argument_list|)
return|;
else|else
return|return
operator|new
name|NEWARRAY
argument_list|(
operator|(
operator|(
name|BasicType
operator|)
name|t
operator|)
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|ArrayType
name|at
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
name|at
operator|=
operator|(
name|ArrayType
operator|)
name|t
expr_stmt|;
else|else
name|at
operator|=
operator|new
name|ArrayType
argument_list|(
name|t
argument_list|,
name|dim
argument_list|)
expr_stmt|;
return|return
operator|new
name|MULTIANEWARRAY
argument_list|(
name|cp
operator|.
name|addArrayClass
argument_list|(
name|at
argument_list|)
argument_list|,
name|dim
argument_list|)
return|;
block|}
block|}
comment|/** Create "null" value for reference types, 0 for basic types like int    */
specifier|public
specifier|static
name|Instruction
name|createNull
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Constants
operator|.
name|T_ARRAY
case|:
case|case
name|Constants
operator|.
name|T_OBJECT
case|:
return|return
name|ACONST_NULL
return|;
case|case
name|Constants
operator|.
name|T_INT
case|:
case|case
name|Constants
operator|.
name|T_SHORT
case|:
case|case
name|Constants
operator|.
name|T_BOOLEAN
case|:
case|case
name|Constants
operator|.
name|T_CHAR
case|:
case|case
name|Constants
operator|.
name|T_BYTE
case|:
return|return
name|ICONST_0
return|;
case|case
name|Constants
operator|.
name|T_FLOAT
case|:
return|return
name|FCONST_0
return|;
case|case
name|Constants
operator|.
name|T_DOUBLE
case|:
return|return
name|DCONST_0
return|;
case|case
name|Constants
operator|.
name|T_LONG
case|:
return|return
name|LCONST_0
return|;
case|case
name|Constants
operator|.
name|T_VOID
case|:
return|return
name|NOP
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid type: "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/** Create branch instruction by given opcode, except LOOKUPSWITCH and TABLESWITCH.    * For those you should use the SWITCH compound instruction.    */
specifier|public
specifier|static
name|BranchInstruction
name|createBranchInstruction
parameter_list|(
name|short
name|opcode
parameter_list|,
name|InstructionHandle
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|Constants
operator|.
name|IFEQ
case|:
return|return
operator|new
name|IFEQ
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IFNE
case|:
return|return
operator|new
name|IFNE
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IFLT
case|:
return|return
operator|new
name|IFLT
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IFGE
case|:
return|return
operator|new
name|IFGE
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IFGT
case|:
return|return
operator|new
name|IFGT
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IFLE
case|:
return|return
operator|new
name|IFLE
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IF_ICMPEQ
case|:
return|return
operator|new
name|IF_ICMPEQ
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IF_ICMPNE
case|:
return|return
operator|new
name|IF_ICMPNE
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IF_ICMPLT
case|:
return|return
operator|new
name|IF_ICMPLT
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IF_ICMPGE
case|:
return|return
operator|new
name|IF_ICMPGE
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IF_ICMPGT
case|:
return|return
operator|new
name|IF_ICMPGT
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IF_ICMPLE
case|:
return|return
operator|new
name|IF_ICMPLE
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IF_ACMPEQ
case|:
return|return
operator|new
name|IF_ACMPEQ
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IF_ACMPNE
case|:
return|return
operator|new
name|IF_ACMPNE
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|GOTO
case|:
return|return
operator|new
name|GOTO
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|JSR
case|:
return|return
operator|new
name|JSR
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IFNULL
case|:
return|return
operator|new
name|IFNULL
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|IFNONNULL
case|:
return|return
operator|new
name|IFNONNULL
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|GOTO_W
case|:
return|return
operator|new
name|GOTO_W
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Constants
operator|.
name|JSR_W
case|:
return|return
operator|new
name|JSR_W
argument_list|(
name|target
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid opcode: "
operator|+
name|opcode
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|setClassGen
parameter_list|(
name|ClassGen
name|c
parameter_list|)
block|{
name|cg
operator|=
name|c
expr_stmt|;
block|}
specifier|public
name|ClassGen
name|getClassGen
parameter_list|()
block|{
return|return
name|cg
return|;
block|}
specifier|public
name|void
name|setConstantPool
parameter_list|(
name|ConstantPoolGen
name|c
parameter_list|)
block|{
name|cp
operator|=
name|c
expr_stmt|;
block|}
specifier|public
name|ConstantPoolGen
name|getConstantPool
parameter_list|()
block|{
return|return
name|cp
return|;
block|}
block|}
end_class

end_unit

