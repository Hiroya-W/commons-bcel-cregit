begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright  2000-2004 The Apache Software Foundation  *  *  Licensed under the Apache License, Version 2.0 (the "License");   *  you may not use this file except in compliance with the License.  *  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.   *  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|util
operator|.
name|BCELComparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**   * Template class for building up a method. This is done by defining exception  * handlers, adding thrown exceptions, local variables and attributes, whereas  * the `LocalVariableTable' and `LineNumberTable' attributes will be set  * automatically for the code. Use stripAttributes() if you don't like this.  *  * While generating code it may be necessary to insert NOP operations. You can  * use the `removeNOPs' method to get rid off them.  * The resulting method object can be obtained via the `getMethod()' method.  *  * @version $Id$  * @author<A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>  * @author<A HREF="http://www.vmeng.com/beard">Patrick C. Beard</A> [setMaxStack()]  * @see     InstructionList  * @see     Method  */
end_comment

begin_class
specifier|public
class|class
name|MethodGen
extends|extends
name|FieldGenOrMethodGen
block|{
specifier|private
name|String
name|class_name
decl_stmt|;
specifier|private
name|Type
index|[]
name|arg_types
decl_stmt|;
specifier|private
name|String
index|[]
name|arg_names
decl_stmt|;
specifier|private
name|int
name|max_locals
decl_stmt|;
specifier|private
name|int
name|max_stack
decl_stmt|;
specifier|private
name|InstructionList
name|il
decl_stmt|;
specifier|private
name|boolean
name|strip_attributes
decl_stmt|;
specifier|private
name|ArrayList
name|variable_vec
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
specifier|private
name|ArrayList
name|line_number_vec
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
specifier|private
name|ArrayList
name|exception_vec
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
specifier|private
name|ArrayList
name|throws_vec
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
specifier|private
name|ArrayList
name|code_attrs_vec
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|BCELComparator
name|_cmp
init|=
operator|new
name|BCELComparator
argument_list|()
block|{
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
name|MethodGen
name|THIS
init|=
operator|(
name|MethodGen
operator|)
name|o1
decl_stmt|;
name|MethodGen
name|THAT
init|=
operator|(
name|MethodGen
operator|)
name|o2
decl_stmt|;
return|return
name|THIS
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|THAT
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|THIS
operator|.
name|getSignature
argument_list|()
operator|.
name|equals
argument_list|(
name|THAT
operator|.
name|getSignature
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|int
name|hashCode
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|MethodGen
name|THIS
init|=
operator|(
name|MethodGen
operator|)
name|o
decl_stmt|;
return|return
name|THIS
operator|.
name|getSignature
argument_list|()
operator|.
name|hashCode
argument_list|()
operator|^
name|THIS
operator|.
name|getName
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Declare method. If the method is non-static the constructor    * automatically declares a local variable `$this' in slot 0. The    * actual code is contained in the `il' parameter, which may further    * manipulated by the user. But he must take care not to remove any    * instruction (handles) that are still referenced from this object.    *    * For example one may not add a local variable and later remove the    * instructions it refers to without causing havoc. It is safe    * however if you remove that local variable, too.    *    * @param access_flags access qualifiers    * @param return_type  method type    * @param arg_types argument types    * @param arg_names argument names (if this is null, default names will be provided    * for them)    * @param method_name name of method    * @param class_name class name containing this method (may be null, if you don't care)    * @param il instruction list associated with this method, may be null only for    * abstract or native methods    * @param cp constant pool    */
specifier|public
name|MethodGen
parameter_list|(
name|int
name|access_flags
parameter_list|,
name|Type
name|return_type
parameter_list|,
name|Type
index|[]
name|arg_types
parameter_list|,
name|String
index|[]
name|arg_names
parameter_list|,
name|String
name|method_name
parameter_list|,
name|String
name|class_name
parameter_list|,
name|InstructionList
name|il
parameter_list|,
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
name|setAccessFlags
argument_list|(
name|access_flags
argument_list|)
expr_stmt|;
name|setType
argument_list|(
name|return_type
argument_list|)
expr_stmt|;
name|setArgumentTypes
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
name|setArgumentNames
argument_list|(
name|arg_names
argument_list|)
expr_stmt|;
name|setName
argument_list|(
name|method_name
argument_list|)
expr_stmt|;
name|setClassName
argument_list|(
name|class_name
argument_list|)
expr_stmt|;
name|setInstructionList
argument_list|(
name|il
argument_list|)
expr_stmt|;
name|setConstantPool
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|boolean
name|abstract_
init|=
name|isAbstract
argument_list|()
operator|||
name|isNative
argument_list|()
decl_stmt|;
name|InstructionHandle
name|start
init|=
literal|null
decl_stmt|;
name|InstructionHandle
name|end
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|abstract_
condition|)
block|{
name|start
operator|=
name|il
operator|.
name|getStart
argument_list|()
expr_stmt|;
name|end
operator|=
name|il
operator|.
name|getEnd
argument_list|()
expr_stmt|;
comment|/* Add local variables, namely the implicit `this' and the arguments        */
if|if
condition|(
operator|!
name|isStatic
argument_list|()
operator|&&
operator|(
name|class_name
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// Instance method -> `this' is local var 0
name|addLocalVariable
argument_list|(
literal|"this"
argument_list|,
operator|new
name|ObjectType
argument_list|(
name|class_name
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|arg_types
operator|!=
literal|null
condition|)
block|{
name|int
name|size
init|=
name|arg_types
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Type
operator|.
name|VOID
operator|==
name|arg_types
index|[
name|i
index|]
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"'void' is an illegal argument type for a method"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|arg_names
operator|!=
literal|null
condition|)
block|{
comment|// Names for variables provided?
if|if
condition|(
name|size
operator|!=
name|arg_names
operator|.
name|length
condition|)
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Mismatch in argument array lengths: "
operator|+
name|size
operator|+
literal|" vs. "
operator|+
name|arg_names
operator|.
name|length
argument_list|)
throw|;
block|}
else|else
block|{
comment|// Give them dummy names
name|arg_names
operator|=
operator|new
name|String
index|[
name|size
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|arg_names
index|[
name|i
index|]
operator|=
literal|"arg"
operator|+
name|i
expr_stmt|;
name|setArgumentNames
argument_list|(
name|arg_names
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|abstract_
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|addLocalVariable
argument_list|(
name|arg_names
index|[
name|i
index|]
argument_list|,
name|arg_types
index|[
name|i
index|]
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Instantiate from existing method.    *    * @param m method    * @param class_name class name containing this method    * @param cp constant pool    */
specifier|public
name|MethodGen
parameter_list|(
name|Method
name|m
parameter_list|,
name|String
name|class_name
parameter_list|,
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
name|this
argument_list|(
name|m
operator|.
name|getAccessFlags
argument_list|()
argument_list|,
name|Type
operator|.
name|getReturnType
argument_list|(
name|m
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|Type
operator|.
name|getArgumentTypes
argument_list|(
name|m
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
literal|null
comment|/* may be overridden anyway */
argument_list|,
name|m
operator|.
name|getName
argument_list|()
argument_list|,
name|class_name
argument_list|,
operator|(
operator|(
name|m
operator|.
name|getAccessFlags
argument_list|()
operator|&
operator|(
name|Constants
operator|.
name|ACC_ABSTRACT
operator||
name|Constants
operator|.
name|ACC_NATIVE
operator|)
operator|)
operator|==
literal|0
operator|)
condition|?
operator|new
name|InstructionList
argument_list|(
name|m
operator|.
name|getCode
argument_list|()
operator|.
name|getCode
argument_list|()
argument_list|)
else|:
literal|null
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|Attribute
index|[]
name|attributes
init|=
name|m
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attributes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Attribute
name|a
init|=
name|attributes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|a
operator|instanceof
name|Code
condition|)
block|{
name|Code
name|c
init|=
operator|(
name|Code
operator|)
name|a
decl_stmt|;
name|setMaxStack
argument_list|(
name|c
operator|.
name|getMaxStack
argument_list|()
argument_list|)
expr_stmt|;
name|setMaxLocals
argument_list|(
name|c
operator|.
name|getMaxLocals
argument_list|()
argument_list|)
expr_stmt|;
name|CodeException
index|[]
name|ces
init|=
name|c
operator|.
name|getExceptionTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|ces
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|ces
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|CodeException
name|ce
init|=
name|ces
index|[
name|j
index|]
decl_stmt|;
name|int
name|type
init|=
name|ce
operator|.
name|getCatchType
argument_list|()
decl_stmt|;
name|ObjectType
name|c_type
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|type
operator|>
literal|0
condition|)
block|{
name|String
name|cen
init|=
name|m
operator|.
name|getConstantPool
argument_list|()
operator|.
name|getConstantString
argument_list|(
name|type
argument_list|,
name|Constants
operator|.
name|CONSTANT_Class
argument_list|)
decl_stmt|;
name|c_type
operator|=
operator|new
name|ObjectType
argument_list|(
name|cen
argument_list|)
expr_stmt|;
block|}
name|int
name|end_pc
init|=
name|ce
operator|.
name|getEndPC
argument_list|()
decl_stmt|;
name|int
name|length
init|=
name|m
operator|.
name|getCode
argument_list|()
operator|.
name|getCode
argument_list|()
operator|.
name|length
decl_stmt|;
name|InstructionHandle
name|end
decl_stmt|;
if|if
condition|(
name|length
operator|==
name|end_pc
condition|)
block|{
comment|// May happen, because end_pc is exclusive
name|end
operator|=
name|il
operator|.
name|getEnd
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|end
operator|=
name|il
operator|.
name|findHandle
argument_list|(
name|end_pc
argument_list|)
expr_stmt|;
name|end
operator|=
name|end
operator|.
name|getPrev
argument_list|()
expr_stmt|;
comment|// Make it inclusive
block|}
name|addExceptionHandler
argument_list|(
name|il
operator|.
name|findHandle
argument_list|(
name|ce
operator|.
name|getStartPC
argument_list|()
argument_list|)
argument_list|,
name|end
argument_list|,
name|il
operator|.
name|findHandle
argument_list|(
name|ce
operator|.
name|getHandlerPC
argument_list|()
argument_list|)
argument_list|,
name|c_type
argument_list|)
expr_stmt|;
block|}
block|}
name|Attribute
index|[]
name|c_attributes
init|=
name|c
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|c_attributes
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|a
operator|=
name|c_attributes
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|a
operator|instanceof
name|LineNumberTable
condition|)
block|{
name|LineNumber
index|[]
name|ln
init|=
operator|(
operator|(
name|LineNumberTable
operator|)
name|a
operator|)
operator|.
name|getLineNumberTable
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|ln
operator|.
name|length
condition|;
name|k
operator|++
control|)
block|{
name|LineNumber
name|l
init|=
name|ln
index|[
name|k
index|]
decl_stmt|;
name|addLineNumber
argument_list|(
name|il
operator|.
name|findHandle
argument_list|(
name|l
operator|.
name|getStartPC
argument_list|()
argument_list|)
argument_list|,
name|l
operator|.
name|getLineNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|a
operator|instanceof
name|LocalVariableTable
condition|)
block|{
name|LocalVariable
index|[]
name|lv
init|=
operator|(
operator|(
name|LocalVariableTable
operator|)
name|a
operator|)
operator|.
name|getLocalVariableTable
argument_list|()
decl_stmt|;
name|removeLocalVariables
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|lv
operator|.
name|length
condition|;
name|k
operator|++
control|)
block|{
name|LocalVariable
name|l
init|=
name|lv
index|[
name|k
index|]
decl_stmt|;
name|InstructionHandle
name|start
init|=
name|il
operator|.
name|findHandle
argument_list|(
name|l
operator|.
name|getStartPC
argument_list|()
argument_list|)
decl_stmt|;
name|InstructionHandle
name|end
init|=
name|il
operator|.
name|findHandle
argument_list|(
name|l
operator|.
name|getStartPC
argument_list|()
operator|+
name|l
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
comment|// Repair malformed handles
if|if
condition|(
literal|null
operator|==
name|start
condition|)
block|{
name|start
operator|=
name|il
operator|.
name|getStart
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|==
name|end
condition|)
block|{
name|end
operator|=
name|il
operator|.
name|getEnd
argument_list|()
expr_stmt|;
block|}
name|addLocalVariable
argument_list|(
name|l
operator|.
name|getName
argument_list|()
argument_list|,
name|Type
operator|.
name|getType
argument_list|(
name|l
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|l
operator|.
name|getIndex
argument_list|()
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|addCodeAttribute
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|a
operator|instanceof
name|ExceptionTable
condition|)
block|{
name|String
index|[]
name|names
init|=
operator|(
operator|(
name|ExceptionTable
operator|)
name|a
operator|)
operator|.
name|getExceptionNames
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|names
operator|.
name|length
condition|;
name|j
operator|++
control|)
name|addException
argument_list|(
name|names
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|addAttribute
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Adds a local variable to this method.    *    * @param name variable name    * @param type variable type    * @param slot the index of the local variable, if type is long or double, the next available    * index is slot+2    * @param start from where the variable is valid    * @param end until where the variable is valid    * @return new local variable object    * @see LocalVariable    */
specifier|public
name|LocalVariableGen
name|addLocalVariable
parameter_list|(
name|String
name|name
parameter_list|,
name|Type
name|type
parameter_list|,
name|int
name|slot
parameter_list|,
name|InstructionHandle
name|start
parameter_list|,
name|InstructionHandle
name|end
parameter_list|)
block|{
name|byte
name|t
init|=
name|type
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|Constants
operator|.
name|T_ADDRESS
condition|)
block|{
name|int
name|add
init|=
name|type
operator|.
name|getSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|slot
operator|+
name|add
operator|>
name|max_locals
condition|)
name|max_locals
operator|=
name|slot
operator|+
name|add
expr_stmt|;
name|LocalVariableGen
name|l
init|=
operator|new
name|LocalVariableGen
argument_list|(
name|slot
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|variable_vec
operator|.
name|indexOf
argument_list|(
name|l
argument_list|)
operator|)
operator|>=
literal|0
condition|)
comment|// Overwrite if necessary
name|variable_vec
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|l
argument_list|)
expr_stmt|;
else|else
name|variable_vec
operator|.
name|add
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can not use "
operator|+
name|type
operator|+
literal|" as type for local variable"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Adds a local variable to this method and assigns an index automatically.    *    * @param name variable name    * @param type variable type    * @param start from where the variable is valid, if this is null,    * it is valid from the start    * @param end until where the variable is valid, if this is null,    * it is valid to the end    * @return new local variable object    * @see LocalVariable    */
specifier|public
name|LocalVariableGen
name|addLocalVariable
parameter_list|(
name|String
name|name
parameter_list|,
name|Type
name|type
parameter_list|,
name|InstructionHandle
name|start
parameter_list|,
name|InstructionHandle
name|end
parameter_list|)
block|{
return|return
name|addLocalVariable
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|max_locals
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
return|;
block|}
comment|/**    * Remove a local variable, its slot will not be reused, if you do not use addLocalVariable    * with an explicit index argument.    */
specifier|public
name|void
name|removeLocalVariable
parameter_list|(
name|LocalVariableGen
name|l
parameter_list|)
block|{
name|variable_vec
operator|.
name|remove
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove all local variables.    */
specifier|public
name|void
name|removeLocalVariables
parameter_list|()
block|{
name|variable_vec
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Sort local variables by index    */
specifier|private
specifier|static
specifier|final
name|void
name|sort
parameter_list|(
name|LocalVariableGen
index|[]
name|vars
parameter_list|,
name|int
name|l
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|int
name|i
init|=
name|l
decl_stmt|,
name|j
init|=
name|r
decl_stmt|;
name|int
name|m
init|=
name|vars
index|[
operator|(
name|l
operator|+
name|r
operator|)
operator|/
literal|2
index|]
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|LocalVariableGen
name|h
decl_stmt|;
do|do
block|{
while|while
condition|(
name|vars
index|[
name|i
index|]
operator|.
name|getIndex
argument_list|()
operator|<
name|m
condition|)
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|m
operator|<
name|vars
index|[
name|j
index|]
operator|.
name|getIndex
argument_list|()
condition|)
name|j
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<=
name|j
condition|)
block|{
name|h
operator|=
name|vars
index|[
name|i
index|]
expr_stmt|;
name|vars
index|[
name|i
index|]
operator|=
name|vars
index|[
name|j
index|]
expr_stmt|;
name|vars
index|[
name|j
index|]
operator|=
name|h
expr_stmt|;
comment|// Swap elements
name|i
operator|++
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
block|}
do|while
condition|(
name|i
operator|<=
name|j
condition|)
do|;
if|if
condition|(
name|l
operator|<
name|j
condition|)
name|sort
argument_list|(
name|vars
argument_list|,
name|l
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|r
condition|)
name|sort
argument_list|(
name|vars
argument_list|,
name|i
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/*    * If the range of the variable has not been set yet, it will be set to be valid from    * the start to the end of the instruction list.    *     * @return array of declared local variables sorted by index    */
specifier|public
name|LocalVariableGen
index|[]
name|getLocalVariables
parameter_list|()
block|{
name|int
name|size
init|=
name|variable_vec
operator|.
name|size
argument_list|()
decl_stmt|;
name|LocalVariableGen
index|[]
name|lg
init|=
operator|new
name|LocalVariableGen
index|[
name|size
index|]
decl_stmt|;
name|variable_vec
operator|.
name|toArray
argument_list|(
name|lg
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lg
index|[
name|i
index|]
operator|.
name|getStart
argument_list|()
operator|==
literal|null
condition|)
name|lg
index|[
name|i
index|]
operator|.
name|setStart
argument_list|(
name|il
operator|.
name|getStart
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|lg
index|[
name|i
index|]
operator|.
name|getEnd
argument_list|()
operator|==
literal|null
condition|)
name|lg
index|[
name|i
index|]
operator|.
name|setEnd
argument_list|(
name|il
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
literal|1
condition|)
name|sort
argument_list|(
name|lg
argument_list|,
literal|0
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|lg
return|;
block|}
comment|/**    * @return `LocalVariableTable' attribute of all the local variables of this method.    */
specifier|public
name|LocalVariableTable
name|getLocalVariableTable
parameter_list|(
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
name|LocalVariableGen
index|[]
name|lg
init|=
name|getLocalVariables
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|lg
operator|.
name|length
decl_stmt|;
name|LocalVariable
index|[]
name|lv
init|=
operator|new
name|LocalVariable
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|lv
index|[
name|i
index|]
operator|=
name|lg
index|[
name|i
index|]
operator|.
name|getLocalVariable
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|new
name|LocalVariableTable
argument_list|(
name|cp
operator|.
name|addUtf8
argument_list|(
literal|"LocalVariableTable"
argument_list|)
argument_list|,
literal|2
operator|+
name|lv
operator|.
name|length
operator|*
literal|10
argument_list|,
name|lv
argument_list|,
name|cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Give an instruction a line number corresponding to the source code line.    *    * @param ih instruction to tag    * @return new line number object    * @see LineNumber    */
specifier|public
name|LineNumberGen
name|addLineNumber
parameter_list|(
name|InstructionHandle
name|ih
parameter_list|,
name|int
name|src_line
parameter_list|)
block|{
name|LineNumberGen
name|l
init|=
operator|new
name|LineNumberGen
argument_list|(
name|ih
argument_list|,
name|src_line
argument_list|)
decl_stmt|;
name|line_number_vec
operator|.
name|add
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
comment|/**    * Remove a line number.    */
specifier|public
name|void
name|removeLineNumber
parameter_list|(
name|LineNumberGen
name|l
parameter_list|)
block|{
name|line_number_vec
operator|.
name|remove
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove all line numbers.    */
specifier|public
name|void
name|removeLineNumbers
parameter_list|()
block|{
name|line_number_vec
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/*    * @return array of line numbers    */
specifier|public
name|LineNumberGen
index|[]
name|getLineNumbers
parameter_list|()
block|{
name|LineNumberGen
index|[]
name|lg
init|=
operator|new
name|LineNumberGen
index|[
name|line_number_vec
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|line_number_vec
operator|.
name|toArray
argument_list|(
name|lg
argument_list|)
expr_stmt|;
return|return
name|lg
return|;
block|}
comment|/**    * @return `LineNumberTable' attribute of all the local variables of this method.    */
specifier|public
name|LineNumberTable
name|getLineNumberTable
parameter_list|(
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
name|int
name|size
init|=
name|line_number_vec
operator|.
name|size
argument_list|()
decl_stmt|;
name|LineNumber
index|[]
name|ln
init|=
operator|new
name|LineNumber
index|[
name|size
index|]
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|ln
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|LineNumberGen
operator|)
name|line_number_vec
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getLineNumber
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
block|}
comment|// Never occurs
return|return
operator|new
name|LineNumberTable
argument_list|(
name|cp
operator|.
name|addUtf8
argument_list|(
literal|"LineNumberTable"
argument_list|)
argument_list|,
literal|2
operator|+
name|ln
operator|.
name|length
operator|*
literal|4
argument_list|,
name|ln
argument_list|,
name|cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Add an exception handler, i.e., specify region where a handler is active and an    * instruction where the actual handling is done.    *    * @param start_pc Start of region (inclusive)    * @param end_pc End of region (inclusive)    * @param handler_pc Where handling is done    * @param catch_type class type of handled exception or null if any    * exception is handled    * @return new exception handler object    */
specifier|public
name|CodeExceptionGen
name|addExceptionHandler
parameter_list|(
name|InstructionHandle
name|start_pc
parameter_list|,
name|InstructionHandle
name|end_pc
parameter_list|,
name|InstructionHandle
name|handler_pc
parameter_list|,
name|ObjectType
name|catch_type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|start_pc
operator|==
literal|null
operator|)
operator|||
operator|(
name|end_pc
operator|==
literal|null
operator|)
operator|||
operator|(
name|handler_pc
operator|==
literal|null
operator|)
condition|)
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Exception handler target is null instruction"
argument_list|)
throw|;
name|CodeExceptionGen
name|c
init|=
operator|new
name|CodeExceptionGen
argument_list|(
name|start_pc
argument_list|,
name|end_pc
argument_list|,
name|handler_pc
argument_list|,
name|catch_type
argument_list|)
decl_stmt|;
name|exception_vec
operator|.
name|add
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/**    * Remove an exception handler.    */
specifier|public
name|void
name|removeExceptionHandler
parameter_list|(
name|CodeExceptionGen
name|c
parameter_list|)
block|{
name|exception_vec
operator|.
name|remove
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove all line numbers.    */
specifier|public
name|void
name|removeExceptionHandlers
parameter_list|()
block|{
name|exception_vec
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/*    * @return array of declared exception handlers    */
specifier|public
name|CodeExceptionGen
index|[]
name|getExceptionHandlers
parameter_list|()
block|{
name|CodeExceptionGen
index|[]
name|cg
init|=
operator|new
name|CodeExceptionGen
index|[
name|exception_vec
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|exception_vec
operator|.
name|toArray
argument_list|(
name|cg
argument_list|)
expr_stmt|;
return|return
name|cg
return|;
block|}
comment|/**    * @return code exceptions for `Code' attribute    */
specifier|private
name|CodeException
index|[]
name|getCodeExceptions
parameter_list|()
block|{
name|int
name|size
init|=
name|exception_vec
operator|.
name|size
argument_list|()
decl_stmt|;
name|CodeException
index|[]
name|c_exc
init|=
operator|new
name|CodeException
index|[
name|size
index|]
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|CodeExceptionGen
name|c
init|=
operator|(
name|CodeExceptionGen
operator|)
name|exception_vec
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|c_exc
index|[
name|i
index|]
operator|=
name|c
operator|.
name|getCodeException
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
block|}
return|return
name|c_exc
return|;
block|}
comment|/**    * Add an exception possibly thrown by this method.    *    * @param class_name (fully qualified) name of exception    */
specifier|public
name|void
name|addException
parameter_list|(
name|String
name|class_name
parameter_list|)
block|{
name|throws_vec
operator|.
name|add
argument_list|(
name|class_name
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove an exception.    */
specifier|public
name|void
name|removeException
parameter_list|(
name|String
name|c
parameter_list|)
block|{
name|throws_vec
operator|.
name|remove
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove all exceptions.    */
specifier|public
name|void
name|removeExceptions
parameter_list|()
block|{
name|throws_vec
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/*    * @return array of thrown exceptions    */
specifier|public
name|String
index|[]
name|getExceptions
parameter_list|()
block|{
name|String
index|[]
name|e
init|=
operator|new
name|String
index|[
name|throws_vec
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|throws_vec
operator|.
name|toArray
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
comment|/**    * @return `Exceptions' attribute of all the exceptions thrown by this method.    */
specifier|private
name|ExceptionTable
name|getExceptionTable
parameter_list|(
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
name|int
name|size
init|=
name|throws_vec
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
index|[]
name|ex
init|=
operator|new
name|int
index|[
name|size
index|]
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|ex
index|[
name|i
index|]
operator|=
name|cp
operator|.
name|addClass
argument_list|(
operator|(
name|String
operator|)
name|throws_vec
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArrayIndexOutOfBoundsException
name|e
parameter_list|)
block|{
block|}
return|return
operator|new
name|ExceptionTable
argument_list|(
name|cp
operator|.
name|addUtf8
argument_list|(
literal|"Exceptions"
argument_list|)
argument_list|,
literal|2
operator|+
literal|2
operator|*
name|size
argument_list|,
name|ex
argument_list|,
name|cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Add an attribute to the code. Currently, the JVM knows about the    * LineNumberTable, LocalVariableTable and StackMap attributes,    * where the former two will be generated automatically and the    * latter is used for the MIDP only. Other attributes will be    * ignored by the JVM but do no harm.    *    * @param a attribute to be added    */
specifier|public
name|void
name|addCodeAttribute
parameter_list|(
name|Attribute
name|a
parameter_list|)
block|{
name|code_attrs_vec
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove a code attribute.    */
specifier|public
name|void
name|removeCodeAttribute
parameter_list|(
name|Attribute
name|a
parameter_list|)
block|{
name|code_attrs_vec
operator|.
name|remove
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove all code attributes.    */
specifier|public
name|void
name|removeCodeAttributes
parameter_list|()
block|{
name|code_attrs_vec
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * @return all attributes of this method.    */
specifier|public
name|Attribute
index|[]
name|getCodeAttributes
parameter_list|()
block|{
name|Attribute
index|[]
name|attributes
init|=
operator|new
name|Attribute
index|[
name|code_attrs_vec
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|code_attrs_vec
operator|.
name|toArray
argument_list|(
name|attributes
argument_list|)
expr_stmt|;
return|return
name|attributes
return|;
block|}
comment|/**    * Get method object. Never forget to call setMaxStack() or setMaxStack(max), respectively,    * before calling this method (the same applies for max locals).    *    * @return method object    */
specifier|public
name|Method
name|getMethod
parameter_list|()
block|{
name|String
name|signature
init|=
name|getSignature
argument_list|()
decl_stmt|;
name|int
name|name_index
init|=
name|cp
operator|.
name|addUtf8
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|signature_index
init|=
name|cp
operator|.
name|addUtf8
argument_list|(
name|signature
argument_list|)
decl_stmt|;
comment|/* Also updates positions of instructions, i.e., their indices      */
name|byte
index|[]
name|byte_code
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|il
operator|!=
literal|null
condition|)
name|byte_code
operator|=
name|il
operator|.
name|getByteCode
argument_list|()
expr_stmt|;
name|LineNumberTable
name|lnt
init|=
literal|null
decl_stmt|;
name|LocalVariableTable
name|lvt
init|=
literal|null
decl_stmt|;
comment|/* Create LocalVariableTable and LineNumberTable attributes (for debuggers, e.g.)      */
if|if
condition|(
operator|(
name|variable_vec
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|!
name|strip_attributes
condition|)
name|addCodeAttribute
argument_list|(
name|lvt
operator|=
name|getLocalVariableTable
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|line_number_vec
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|!
name|strip_attributes
condition|)
name|addCodeAttribute
argument_list|(
name|lnt
operator|=
name|getLineNumberTable
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|Attribute
index|[]
name|code_attrs
init|=
name|getCodeAttributes
argument_list|()
decl_stmt|;
comment|/* Each attribute causes 6 additional header bytes      */
name|int
name|attrs_len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|code_attrs
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|attrs_len
operator|+=
operator|(
name|code_attrs
index|[
name|i
index|]
operator|.
name|getLength
argument_list|()
operator|+
literal|6
operator|)
expr_stmt|;
name|CodeException
index|[]
name|c_exc
init|=
name|getCodeExceptions
argument_list|()
decl_stmt|;
name|int
name|exc_len
init|=
name|c_exc
operator|.
name|length
operator|*
literal|8
decl_stmt|;
comment|// Every entry takes 8 bytes
name|Code
name|code
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|il
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|isAbstract
argument_list|()
operator|&&
operator|!
name|isNative
argument_list|()
condition|)
block|{
comment|// Remove any stale code attribute
name|Attribute
index|[]
name|attributes
init|=
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|attributes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Attribute
name|a
init|=
name|attributes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|a
operator|instanceof
name|Code
condition|)
name|removeAttribute
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
operator|new
name|Code
argument_list|(
name|cp
operator|.
name|addUtf8
argument_list|(
literal|"Code"
argument_list|)
argument_list|,
literal|8
operator|+
name|byte_code
operator|.
name|length
operator|+
comment|// prologue byte code
literal|2
operator|+
name|exc_len
operator|+
comment|// exceptions
literal|2
operator|+
name|attrs_len
argument_list|,
comment|// attributes
name|max_stack
argument_list|,
name|max_locals
argument_list|,
name|byte_code
argument_list|,
name|c_exc
argument_list|,
name|code_attrs
argument_list|,
name|cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
expr_stmt|;
name|addAttribute
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
name|ExceptionTable
name|et
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|throws_vec
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
name|addAttribute
argument_list|(
name|et
operator|=
name|getExceptionTable
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add `Exceptions' if there are "throws" clauses
name|Method
name|m
init|=
operator|new
name|Method
argument_list|(
name|access_flags
argument_list|,
name|name_index
argument_list|,
name|signature_index
argument_list|,
name|getAttributes
argument_list|()
argument_list|,
name|cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
decl_stmt|;
comment|// Undo effects of adding attributes
if|if
condition|(
name|lvt
operator|!=
literal|null
condition|)
name|removeCodeAttribute
argument_list|(
name|lvt
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnt
operator|!=
literal|null
condition|)
name|removeCodeAttribute
argument_list|(
name|lnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|null
condition|)
name|removeAttribute
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|et
operator|!=
literal|null
condition|)
name|removeAttribute
argument_list|(
name|et
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
comment|/**    * Remove all NOPs from the instruction list (if possible) and update every    * object refering to them, i.e., branch instructions, local variables and    * exception handlers.    */
specifier|public
name|void
name|removeNOPs
parameter_list|()
block|{
if|if
condition|(
name|il
operator|!=
literal|null
condition|)
block|{
name|InstructionHandle
name|next
decl_stmt|;
comment|/* Check branch instructions.        */
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|il
operator|.
name|getStart
argument_list|()
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ih
operator|.
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|next
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|ih
operator|.
name|getInstruction
argument_list|()
operator|instanceof
name|NOP
operator|)
condition|)
block|{
try|try
block|{
name|il
operator|.
name|delete
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TargetLostException
name|e
parameter_list|)
block|{
name|InstructionHandle
index|[]
name|targets
init|=
name|e
operator|.
name|getTargets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|InstructionTargeter
index|[]
name|targeters
init|=
name|targets
index|[
name|i
index|]
operator|.
name|getTargeters
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|targeters
operator|.
name|length
condition|;
name|j
operator|++
control|)
name|targeters
index|[
name|j
index|]
operator|.
name|updateTarget
argument_list|(
name|targets
index|[
name|i
index|]
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**    * Set maximum number of local variables.    */
specifier|public
name|void
name|setMaxLocals
parameter_list|(
name|int
name|m
parameter_list|)
block|{
name|max_locals
operator|=
name|m
expr_stmt|;
block|}
specifier|public
name|int
name|getMaxLocals
parameter_list|()
block|{
return|return
name|max_locals
return|;
block|}
comment|/**    * Set maximum stack size for this method.    */
specifier|public
name|void
name|setMaxStack
parameter_list|(
name|int
name|m
parameter_list|)
block|{
name|max_stack
operator|=
name|m
expr_stmt|;
block|}
specifier|public
name|int
name|getMaxStack
parameter_list|()
block|{
return|return
name|max_stack
return|;
block|}
comment|/** @return class that contains this method    */
specifier|public
name|String
name|getClassName
parameter_list|()
block|{
return|return
name|class_name
return|;
block|}
specifier|public
name|void
name|setClassName
parameter_list|(
name|String
name|class_name
parameter_list|)
block|{
name|this
operator|.
name|class_name
operator|=
name|class_name
expr_stmt|;
block|}
specifier|public
name|void
name|setReturnType
parameter_list|(
name|Type
name|return_type
parameter_list|)
block|{
name|setType
argument_list|(
name|return_type
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Type
name|getReturnType
parameter_list|()
block|{
return|return
name|getType
argument_list|()
return|;
block|}
specifier|public
name|void
name|setArgumentTypes
parameter_list|(
name|Type
index|[]
name|arg_types
parameter_list|)
block|{
name|this
operator|.
name|arg_types
operator|=
name|arg_types
expr_stmt|;
block|}
specifier|public
name|Type
index|[]
name|getArgumentTypes
parameter_list|()
block|{
return|return
operator|(
name|Type
index|[]
operator|)
name|arg_types
operator|.
name|clone
argument_list|()
return|;
block|}
specifier|public
name|void
name|setArgumentType
parameter_list|(
name|int
name|i
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
name|arg_types
index|[
name|i
index|]
operator|=
name|type
expr_stmt|;
block|}
specifier|public
name|Type
name|getArgumentType
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|arg_types
index|[
name|i
index|]
return|;
block|}
specifier|public
name|void
name|setArgumentNames
parameter_list|(
name|String
index|[]
name|arg_names
parameter_list|)
block|{
name|this
operator|.
name|arg_names
operator|=
name|arg_names
expr_stmt|;
block|}
specifier|public
name|String
index|[]
name|getArgumentNames
parameter_list|()
block|{
return|return
operator|(
name|String
index|[]
operator|)
name|arg_names
operator|.
name|clone
argument_list|()
return|;
block|}
specifier|public
name|void
name|setArgumentName
parameter_list|(
name|int
name|i
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|arg_names
index|[
name|i
index|]
operator|=
name|name
expr_stmt|;
block|}
specifier|public
name|String
name|getArgumentName
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|arg_names
index|[
name|i
index|]
return|;
block|}
specifier|public
name|InstructionList
name|getInstructionList
parameter_list|()
block|{
return|return
name|il
return|;
block|}
specifier|public
name|void
name|setInstructionList
parameter_list|(
name|InstructionList
name|il
parameter_list|)
block|{
name|this
operator|.
name|il
operator|=
name|il
expr_stmt|;
block|}
specifier|public
name|String
name|getSignature
parameter_list|()
block|{
return|return
name|Type
operator|.
name|getMethodSignature
argument_list|(
name|type
argument_list|,
name|arg_types
argument_list|)
return|;
block|}
comment|/**    * Computes max. stack size by performing control flow analysis.    */
specifier|public
name|void
name|setMaxStack
parameter_list|()
block|{
if|if
condition|(
name|il
operator|!=
literal|null
condition|)
name|max_stack
operator|=
name|getMaxStack
argument_list|(
name|cp
argument_list|,
name|il
argument_list|,
name|getExceptionHandlers
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|max_stack
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * Compute maximum number of local variables.    */
specifier|public
name|void
name|setMaxLocals
parameter_list|()
block|{
if|if
condition|(
name|il
operator|!=
literal|null
condition|)
block|{
name|int
name|max
init|=
name|isStatic
argument_list|()
condition|?
literal|0
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|arg_types
operator|!=
literal|null
condition|)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arg_types
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|max
operator|+=
name|arg_types
index|[
name|i
index|]
operator|.
name|getSize
argument_list|()
expr_stmt|;
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|il
operator|.
name|getStart
argument_list|()
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|getNext
argument_list|()
control|)
block|{
name|Instruction
name|ins
init|=
name|ih
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|ins
operator|instanceof
name|LocalVariableInstruction
operator|)
operator|||
operator|(
name|ins
operator|instanceof
name|RET
operator|)
operator|||
operator|(
name|ins
operator|instanceof
name|IINC
operator|)
condition|)
block|{
name|int
name|index
init|=
operator|(
operator|(
name|IndexedInstruction
operator|)
name|ins
operator|)
operator|.
name|getIndex
argument_list|()
operator|+
operator|(
operator|(
name|TypedInstruction
operator|)
name|ins
operator|)
operator|.
name|getType
argument_list|(
name|cp
argument_list|)
operator|.
name|getSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|>
name|max
condition|)
name|max
operator|=
name|index
expr_stmt|;
block|}
block|}
name|max_locals
operator|=
name|max
expr_stmt|;
block|}
else|else
name|max_locals
operator|=
literal|0
expr_stmt|;
block|}
comment|/** Do not/Do produce attributes code attributesLineNumberTable and    * LocalVariableTable, like javac -O    */
specifier|public
name|void
name|stripAttributes
parameter_list|(
name|boolean
name|flag
parameter_list|)
block|{
name|strip_attributes
operator|=
name|flag
expr_stmt|;
block|}
specifier|static
specifier|final
class|class
name|BranchTarget
block|{
name|InstructionHandle
name|target
decl_stmt|;
name|int
name|stackDepth
decl_stmt|;
name|BranchTarget
parameter_list|(
name|InstructionHandle
name|target
parameter_list|,
name|int
name|stackDepth
parameter_list|)
block|{
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|this
operator|.
name|stackDepth
operator|=
name|stackDepth
expr_stmt|;
block|}
block|}
specifier|static
specifier|final
class|class
name|BranchStack
block|{
name|Stack
name|branchTargets
init|=
operator|new
name|Stack
argument_list|()
decl_stmt|;
name|Hashtable
name|visitedTargets
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
specifier|public
name|void
name|push
parameter_list|(
name|InstructionHandle
name|target
parameter_list|,
name|int
name|stackDepth
parameter_list|)
block|{
if|if
condition|(
name|visited
argument_list|(
name|target
argument_list|)
condition|)
return|return;
name|branchTargets
operator|.
name|push
argument_list|(
name|visit
argument_list|(
name|target
argument_list|,
name|stackDepth
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BranchTarget
name|pop
parameter_list|()
block|{
if|if
condition|(
operator|!
name|branchTargets
operator|.
name|empty
argument_list|()
condition|)
block|{
name|BranchTarget
name|bt
init|=
operator|(
name|BranchTarget
operator|)
name|branchTargets
operator|.
name|pop
argument_list|()
decl_stmt|;
return|return
name|bt
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
specifier|final
name|BranchTarget
name|visit
parameter_list|(
name|InstructionHandle
name|target
parameter_list|,
name|int
name|stackDepth
parameter_list|)
block|{
name|BranchTarget
name|bt
init|=
operator|new
name|BranchTarget
argument_list|(
name|target
argument_list|,
name|stackDepth
argument_list|)
decl_stmt|;
name|visitedTargets
operator|.
name|put
argument_list|(
name|target
argument_list|,
name|bt
argument_list|)
expr_stmt|;
return|return
name|bt
return|;
block|}
specifier|private
specifier|final
name|boolean
name|visited
parameter_list|(
name|InstructionHandle
name|target
parameter_list|)
block|{
return|return
operator|(
name|visitedTargets
operator|.
name|get
argument_list|(
name|target
argument_list|)
operator|!=
literal|null
operator|)
return|;
block|}
block|}
comment|/**    * Computes stack usage of an instruction list by performing control flow analysis.    *    * @return maximum stack depth used by method    */
specifier|public
specifier|static
name|int
name|getMaxStack
parameter_list|(
name|ConstantPoolGen
name|cp
parameter_list|,
name|InstructionList
name|il
parameter_list|,
name|CodeExceptionGen
index|[]
name|et
parameter_list|)
block|{
name|BranchStack
name|branchTargets
init|=
operator|new
name|BranchStack
argument_list|()
decl_stmt|;
comment|/* Initially, populate the branch stack with the exception      * handlers, because these aren't (necessarily) branched to      * explicitly. in each case, the stack will have depth 1,      * containing the exception object.      */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|et
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|InstructionHandle
name|handler_pc
init|=
name|et
index|[
name|i
index|]
operator|.
name|getHandlerPC
argument_list|()
decl_stmt|;
if|if
condition|(
name|handler_pc
operator|!=
literal|null
condition|)
name|branchTargets
operator|.
name|push
argument_list|(
name|handler_pc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|stackDepth
init|=
literal|0
decl_stmt|,
name|maxStackDepth
init|=
literal|0
decl_stmt|;
name|InstructionHandle
name|ih
init|=
name|il
operator|.
name|getStart
argument_list|()
decl_stmt|;
while|while
condition|(
name|ih
operator|!=
literal|null
condition|)
block|{
name|Instruction
name|instruction
init|=
name|ih
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
name|short
name|opcode
init|=
name|instruction
operator|.
name|getOpcode
argument_list|()
decl_stmt|;
name|int
name|delta
init|=
name|instruction
operator|.
name|produceStack
argument_list|(
name|cp
argument_list|)
operator|-
name|instruction
operator|.
name|consumeStack
argument_list|(
name|cp
argument_list|)
decl_stmt|;
name|stackDepth
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|stackDepth
operator|>
name|maxStackDepth
condition|)
name|maxStackDepth
operator|=
name|stackDepth
expr_stmt|;
comment|// choose the next instruction based on whether current is a branch.
if|if
condition|(
name|instruction
operator|instanceof
name|BranchInstruction
condition|)
block|{
name|BranchInstruction
name|branch
init|=
operator|(
name|BranchInstruction
operator|)
name|instruction
decl_stmt|;
if|if
condition|(
name|instruction
operator|instanceof
name|Select
condition|)
block|{
comment|// explore all of the select's targets. the default target is handled below.
name|Select
name|select
init|=
operator|(
name|Select
operator|)
name|branch
decl_stmt|;
name|InstructionHandle
index|[]
name|targets
init|=
name|select
operator|.
name|getTargets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targets
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|branchTargets
operator|.
name|push
argument_list|(
name|targets
index|[
name|i
index|]
argument_list|,
name|stackDepth
argument_list|)
expr_stmt|;
comment|// nothing to fall through to.
name|ih
operator|=
literal|null
expr_stmt|;
block|}
if|else if
condition|(
operator|!
operator|(
name|branch
operator|instanceof
name|IfInstruction
operator|)
condition|)
block|{
comment|// if an instruction that comes back to following PC,
comment|// push next instruction, with stack depth reduced by 1.
if|if
condition|(
name|opcode
operator|==
name|Constants
operator|.
name|JSR
operator|||
name|opcode
operator|==
name|Constants
operator|.
name|JSR_W
condition|)
name|branchTargets
operator|.
name|push
argument_list|(
name|ih
operator|.
name|getNext
argument_list|()
argument_list|,
name|stackDepth
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ih
operator|=
literal|null
expr_stmt|;
block|}
comment|// for all branches, the target of the branch is pushed on the branch stack.
comment|// conditional branches have a fall through case, selects don't, and
comment|// jsr/jsr_w return to the next instruction.
name|branchTargets
operator|.
name|push
argument_list|(
name|branch
operator|.
name|getTarget
argument_list|()
argument_list|,
name|stackDepth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// check for instructions that terminate the method.
if|if
condition|(
name|opcode
operator|==
name|Constants
operator|.
name|ATHROW
operator|||
name|opcode
operator|==
name|Constants
operator|.
name|RET
operator|||
operator|(
name|opcode
operator|>=
name|Constants
operator|.
name|IRETURN
operator|&&
name|opcode
operator|<=
name|Constants
operator|.
name|RETURN
operator|)
condition|)
name|ih
operator|=
literal|null
expr_stmt|;
block|}
comment|// normal case, go to the next instruction.
if|if
condition|(
name|ih
operator|!=
literal|null
condition|)
name|ih
operator|=
name|ih
operator|.
name|getNext
argument_list|()
expr_stmt|;
comment|// if we have no more instructions, see if there are any deferred branches to explore.
if|if
condition|(
name|ih
operator|==
literal|null
condition|)
block|{
name|BranchTarget
name|bt
init|=
name|branchTargets
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|bt
operator|!=
literal|null
condition|)
block|{
name|ih
operator|=
name|bt
operator|.
name|target
expr_stmt|;
name|stackDepth
operator|=
name|bt
operator|.
name|stackDepth
expr_stmt|;
block|}
block|}
block|}
return|return
name|maxStackDepth
return|;
block|}
specifier|private
name|ArrayList
name|observers
decl_stmt|;
comment|/** Add observer for this object.    */
specifier|public
name|void
name|addObserver
parameter_list|(
name|MethodObserver
name|o
parameter_list|)
block|{
if|if
condition|(
name|observers
operator|==
literal|null
condition|)
name|observers
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
name|observers
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
comment|/** Remove observer for this object.    */
specifier|public
name|void
name|removeObserver
parameter_list|(
name|MethodObserver
name|o
parameter_list|)
block|{
if|if
condition|(
name|observers
operator|!=
literal|null
condition|)
name|observers
operator|.
name|remove
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
comment|/** Call notify() method on all observers. This method is not called    * automatically whenever the state has changed, but has to be    * called by the user after he has finished editing the object.    */
specifier|public
name|void
name|update
parameter_list|()
block|{
if|if
condition|(
name|observers
operator|!=
literal|null
condition|)
for|for
control|(
name|Iterator
name|e
init|=
name|observers
operator|.
name|iterator
argument_list|()
init|;
name|e
operator|.
name|hasNext
argument_list|()
condition|;
control|)
operator|(
operator|(
name|MethodObserver
operator|)
name|e
operator|.
name|next
argument_list|()
operator|)
operator|.
name|notify
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return string representation close to declaration format,    * `public static void main(String[]) throws IOException', e.g.    *    * @return String representation of the method.    */
specifier|public
specifier|final
name|String
name|toString
parameter_list|()
block|{
name|String
name|access
init|=
name|Utility
operator|.
name|accessToString
argument_list|(
name|access_flags
argument_list|)
decl_stmt|;
name|String
name|signature
init|=
name|Type
operator|.
name|getMethodSignature
argument_list|(
name|type
argument_list|,
name|arg_types
argument_list|)
decl_stmt|;
name|signature
operator|=
name|Utility
operator|.
name|methodSignatureToString
argument_list|(
name|signature
argument_list|,
name|name
argument_list|,
name|access
argument_list|,
literal|true
argument_list|,
name|getLocalVariableTable
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|(
name|signature
argument_list|)
decl_stmt|;
if|if
condition|(
name|throws_vec
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Iterator
name|e
init|=
name|throws_vec
operator|.
name|iterator
argument_list|()
init|;
name|e
operator|.
name|hasNext
argument_list|()
condition|;
control|)
name|buf
operator|.
name|append
argument_list|(
literal|"\n\t\tthrows "
operator|+
name|e
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** @return deep copy of this method    */
specifier|public
name|MethodGen
name|copy
parameter_list|(
name|String
name|class_name
parameter_list|,
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
name|Method
name|m
init|=
operator|(
operator|(
name|MethodGen
operator|)
name|clone
argument_list|()
operator|)
operator|.
name|getMethod
argument_list|()
decl_stmt|;
name|MethodGen
name|mg
init|=
operator|new
name|MethodGen
argument_list|(
name|m
argument_list|,
name|class_name
argument_list|,
name|this
operator|.
name|cp
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|cp
operator|!=
name|cp
condition|)
block|{
name|mg
operator|.
name|setConstantPool
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|mg
operator|.
name|getInstructionList
argument_list|()
operator|.
name|replaceConstantPool
argument_list|(
name|this
operator|.
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
name|mg
return|;
block|}
comment|/**    * @return Comparison strategy object    */
specifier|public
specifier|static
name|BCELComparator
name|getComparator
parameter_list|()
block|{
return|return
name|_cmp
return|;
block|}
comment|/**    * @param comparator Comparison strategy object    */
specifier|public
specifier|static
name|void
name|setComparator
parameter_list|(
name|BCELComparator
name|comparator
parameter_list|)
block|{
name|_cmp
operator|=
name|comparator
expr_stmt|;
block|}
comment|/**    * Return value as defined by given BCELComparator strategy.    * By default two MethodGen objects are said to be equal when    * their names and signatures are equal.    *     * @see java.lang.Object#equals(java.lang.Object)    */
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|_cmp
operator|.
name|equals
argument_list|(
name|this
argument_list|,
name|obj
argument_list|)
return|;
block|}
comment|/**    * Return value as defined by given BCELComparator strategy.    * By default return the hashcode of the method's name XOR signature.    *     * @see java.lang.Object#hashCode()    */
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|_cmp
operator|.
name|hashCode
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
end_class

end_unit

