begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|bcel
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|AnnotationEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ElementValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ElementValuePair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|JavaClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ALOAD
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ASTORE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|AnnotationElementValueGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|AnnotationEntryGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ArrayElementValueGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ArrayType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ClassGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ConstantPoolGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ElementValueGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ElementValuePairGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|GOTO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|InstructionConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|InstructionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|InstructionHandle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|InstructionList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|LocalVariableGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|MethodGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ObjectType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|PUSH
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|SimpleElementValueGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|util
operator|.
name|SyntheticRepository
import|;
end_import

begin_comment
comment|/**  * The program that some of the tests generate looks like this:  *   *<pre>  * public class HelloWorld  * {  * 	public static void main(String[] argv)  * 	{  * 		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));  * 		String name = null;  *   * 		try  * 		{  * 			name =&quot;Andy&quot;;  * 		}  * 		catch (IOException e)  * 		{  * 			return;  * 		}  * 		System.out.println(&quot;Hello,&quot; + name);  * 	}  * }  *</pre>  */
end_comment

begin_class
specifier|public
class|class
name|GeneratingAnnotatedClassesTestCase
extends|extends
name|AbstractTestCase
block|{
comment|/** 	 * Steps in the test: 	 *<ol> 	 *<li>Programmatically construct the HelloWorld program</li> 	 *<li>Add two simple annotations at the class level</li> 	 *<li>Save the class to disk</li> 	 *<li>Reload the class using the 'static' variant of the BCEL classes</li> 	 *<li>Check the attributes are OK</li> 	 *</ol> 	 */
specifier|public
name|void
name|testGenerateClassLevelAnnotations
parameter_list|()
throws|throws
name|ClassNotFoundException
block|{
comment|// Create HelloWorld
name|ClassGen
name|cg
init|=
name|createClassGen
argument_list|(
literal|"HelloWorld"
argument_list|)
decl_stmt|;
name|cg
operator|.
name|setMajor
argument_list|(
literal|49
argument_list|)
expr_stmt|;
name|cg
operator|.
name|setMinor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ConstantPoolGen
name|cp
init|=
name|cg
operator|.
name|getConstantPool
argument_list|()
decl_stmt|;
name|InstructionList
name|il
init|=
operator|new
name|InstructionList
argument_list|()
decl_stmt|;
name|cg
operator|.
name|addAnnotationEntry
argument_list|(
name|createSimpleVisibleAnnotation
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cg
operator|.
name|addAnnotationEntry
argument_list|(
name|createSimpleInvisibleAnnotation
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|buildClassContents
argument_list|(
name|cg
argument_list|,
name|cp
argument_list|,
name|il
argument_list|)
expr_stmt|;
comment|//System.out.println(cg.getJavaClass().toString());
name|dumpClass
argument_list|(
name|cg
argument_list|,
literal|"HelloWorld.class"
argument_list|)
expr_stmt|;
name|JavaClass
name|jc
init|=
name|getClassFrom
argument_list|(
literal|"."
argument_list|,
literal|"HelloWorld"
argument_list|)
decl_stmt|;
name|AnnotationEntry
index|[]
name|as
init|=
name|jc
operator|.
name|getAnnotationEntries
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Should be two AnnotationEntries but found "
operator|+
name|as
operator|.
name|length
argument_list|,
name|as
operator|.
name|length
operator|==
literal|2
argument_list|)
expr_stmt|;
name|AnnotationEntry
name|one
init|=
name|as
index|[
literal|0
index|]
decl_stmt|;
name|AnnotationEntry
name|two
init|=
name|as
index|[
literal|1
index|]
decl_stmt|;
comment|// TODO L??;
name|assertTrue
argument_list|(
literal|"Name of annotation 1 should be LSimpleAnnotation; but it is "
operator|+
name|as
index|[
literal|0
index|]
operator|.
name|getAnnotationType
argument_list|()
argument_list|,
name|as
index|[
literal|0
index|]
operator|.
name|getAnnotationType
argument_list|()
operator|.
name|equals
argument_list|(
literal|"LSimpleAnnotation;"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Name of annotation 2 should be LSimpleAnnotation; but it is "
operator|+
name|as
index|[
literal|1
index|]
operator|.
name|getAnnotationType
argument_list|()
argument_list|,
name|as
index|[
literal|1
index|]
operator|.
name|getAnnotationType
argument_list|()
operator|.
name|equals
argument_list|(
literal|"LSimpleAnnotation;"
argument_list|)
argument_list|)
expr_stmt|;
name|ElementValuePair
index|[]
name|vals
init|=
name|as
index|[
literal|0
index|]
operator|.
name|getElementValuePairs
argument_list|()
decl_stmt|;
name|ElementValuePair
name|nvp
init|=
name|vals
index|[
literal|0
index|]
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Name of element in SimpleAnnotation should be 'id' but it is "
operator|+
name|nvp
operator|.
name|getNameString
argument_list|()
argument_list|,
name|nvp
operator|.
name|getNameString
argument_list|()
operator|.
name|equals
argument_list|(
literal|"id"
argument_list|)
argument_list|)
expr_stmt|;
name|ElementValue
name|ev
init|=
name|nvp
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Type of element value should be int but it is "
operator|+
name|ev
operator|.
name|getElementValueType
argument_list|()
argument_list|,
name|ev
operator|.
name|getElementValueType
argument_list|()
operator|==
name|ElementValue
operator|.
name|PRIMITIVE_INT
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Value of element should be 4 but it is "
operator|+
name|ev
operator|.
name|stringifyValue
argument_list|()
argument_list|,
name|ev
operator|.
name|stringifyValue
argument_list|()
operator|.
name|equals
argument_list|(
literal|"4"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|createTestdataFile
argument_list|(
literal|"HelloWorld.class"
argument_list|)
operator|.
name|delete
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Just check that we can dump a class that has a method annotation on it 	 * and it is still there when we read it back in 	 */
specifier|public
name|void
name|testGenerateMethodLevelAnnotations1
parameter_list|()
throws|throws
name|ClassNotFoundException
block|{
comment|// Create HelloWorld
name|ClassGen
name|cg
init|=
name|createClassGen
argument_list|(
literal|"HelloWorld"
argument_list|)
decl_stmt|;
name|ConstantPoolGen
name|cp
init|=
name|cg
operator|.
name|getConstantPool
argument_list|()
decl_stmt|;
name|InstructionList
name|il
init|=
operator|new
name|InstructionList
argument_list|()
decl_stmt|;
name|buildClassContentsWithAnnotatedMethods
argument_list|(
name|cg
argument_list|,
name|cp
argument_list|,
name|il
argument_list|)
expr_stmt|;
comment|// Check annotation is OK
name|int
name|i
init|=
name|cg
operator|.
name|getMethods
argument_list|()
index|[
literal|0
index|]
operator|.
name|getAnnotationEntries
argument_list|()
operator|.
name|length
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Prior to dumping, main method should have 1 annotation but has "
operator|+
name|i
argument_list|,
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
name|dumpClass
argument_list|(
name|cg
argument_list|,
literal|"temp1"
operator|+
name|File
operator|.
name|separator
operator|+
literal|"HelloWorld.class"
argument_list|)
expr_stmt|;
name|JavaClass
name|jc2
init|=
name|getClassFrom
argument_list|(
literal|"temp1"
argument_list|,
literal|"HelloWorld"
argument_list|)
decl_stmt|;
comment|// Check annotation is OK
name|i
operator|=
name|jc2
operator|.
name|getMethods
argument_list|()
index|[
literal|0
index|]
operator|.
name|getAnnotationEntries
argument_list|()
operator|.
name|length
expr_stmt|;
name|assertTrue
argument_list|(
literal|"JavaClass should say 1 annotation on main method but says "
operator|+
name|i
argument_list|,
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ClassGen
name|cg2
init|=
operator|new
name|ClassGen
argument_list|(
name|jc2
argument_list|)
decl_stmt|;
comment|// Check it now it is a ClassGen
name|Method
index|[]
name|m
init|=
name|cg2
operator|.
name|getMethods
argument_list|()
decl_stmt|;
name|i
operator|=
name|m
index|[
literal|0
index|]
operator|.
name|getAnnotationEntries
argument_list|()
operator|.
name|length
expr_stmt|;
name|assertTrue
argument_list|(
literal|"The main 'Method' should have one annotation but has "
operator|+
name|i
argument_list|,
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
name|MethodGen
name|mg
init|=
operator|new
name|MethodGen
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|,
name|cg2
operator|.
name|getClassName
argument_list|()
argument_list|,
name|cg2
operator|.
name|getConstantPool
argument_list|()
argument_list|)
decl_stmt|;
comment|// Check it finally when the Method is changed to a MethodGen
name|i
operator|=
name|mg
operator|.
name|getAnnotationEntries
argument_list|()
operator|.
name|length
expr_stmt|;
name|assertTrue
argument_list|(
literal|"The main 'MethodGen' should have one annotation but has "
operator|+
name|i
argument_list|,
name|i
operator|==
literal|1
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|wipe
argument_list|(
literal|"temp1"
operator|+
name|File
operator|.
name|separator
operator|+
literal|"HelloWorld.class"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Going further than the last test - when we reload the method back in, 	 * let's change it (adding a new annotation) and then store that, read it 	 * back in and verify both annotations are there ! 	 */
specifier|public
name|void
name|testGenerateMethodLevelAnnotations2
parameter_list|()
throws|throws
name|ClassNotFoundException
block|{
comment|// Create HelloWorld
name|ClassGen
name|cg
init|=
name|createClassGen
argument_list|(
literal|"HelloWorld"
argument_list|)
decl_stmt|;
name|ConstantPoolGen
name|cp
init|=
name|cg
operator|.
name|getConstantPool
argument_list|()
decl_stmt|;
name|InstructionList
name|il
init|=
operator|new
name|InstructionList
argument_list|()
decl_stmt|;
name|buildClassContentsWithAnnotatedMethods
argument_list|(
name|cg
argument_list|,
name|cp
argument_list|,
name|il
argument_list|)
expr_stmt|;
name|dumpClass
argument_list|(
name|cg
argument_list|,
literal|"temp2"
argument_list|,
literal|"HelloWorld.class"
argument_list|)
expr_stmt|;
name|JavaClass
name|jc2
init|=
name|getClassFrom
argument_list|(
literal|"temp2"
argument_list|,
literal|"HelloWorld"
argument_list|)
decl_stmt|;
name|ClassGen
name|cg2
init|=
operator|new
name|ClassGen
argument_list|(
name|jc2
argument_list|)
decl_stmt|;
comment|// Main method after reading the class back in
name|Method
name|mainMethod1
init|=
name|jc2
operator|.
name|getMethods
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|assertTrue
argument_list|(
literal|"The 'Method' should have one annotations but has "
operator|+
name|mainMethod1
operator|.
name|getAnnotationEntries
argument_list|()
operator|.
name|length
argument_list|,
name|mainMethod1
operator|.
name|getAnnotationEntries
argument_list|()
operator|.
name|length
operator|==
literal|1
argument_list|)
expr_stmt|;
name|MethodGen
name|mainMethod2
init|=
operator|new
name|MethodGen
argument_list|(
name|mainMethod1
argument_list|,
name|cg2
operator|.
name|getClassName
argument_list|()
argument_list|,
name|cg2
operator|.
name|getConstantPool
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"The 'MethodGen' should have one annotations but has "
operator|+
name|mainMethod2
operator|.
name|getAnnotationEntries
argument_list|()
operator|.
name|length
argument_list|,
name|mainMethod2
operator|.
name|getAnnotationEntries
argument_list|()
operator|.
name|length
operator|==
literal|1
argument_list|)
expr_stmt|;
name|mainMethod2
operator|.
name|addAnnotationEntry
argument_list|(
name|createFruitAnnotation
argument_list|(
name|cg2
operator|.
name|getConstantPool
argument_list|()
argument_list|,
literal|"Pear"
argument_list|)
argument_list|)
expr_stmt|;
name|cg2
operator|.
name|removeMethod
argument_list|(
name|mainMethod1
argument_list|)
expr_stmt|;
name|cg2
operator|.
name|addMethod
argument_list|(
name|mainMethod2
operator|.
name|getMethod
argument_list|()
argument_list|)
expr_stmt|;
name|dumpClass
argument_list|(
name|cg2
argument_list|,
literal|"temp3"
argument_list|,
literal|"HelloWorld.class"
argument_list|)
expr_stmt|;
name|JavaClass
name|jc3
init|=
name|getClassFrom
argument_list|(
literal|"temp3"
argument_list|,
literal|"HelloWorld"
argument_list|)
decl_stmt|;
name|ClassGen
name|cg3
init|=
operator|new
name|ClassGen
argument_list|(
name|jc3
argument_list|)
decl_stmt|;
name|Method
name|mainMethod3
init|=
name|cg3
operator|.
name|getMethods
argument_list|()
index|[
literal|1
index|]
decl_stmt|;
name|int
name|i
init|=
name|mainMethod3
operator|.
name|getAnnotationEntries
argument_list|()
operator|.
name|length
decl_stmt|;
name|assertTrue
argument_list|(
literal|"The 'Method' should now have two annotations but has "
operator|+
name|i
argument_list|,
name|i
operator|==
literal|2
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|wipe
argument_list|(
literal|"temp2"
argument_list|,
literal|"HelloWorld.class"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|wipe
argument_list|(
literal|"temp3"
argument_list|,
literal|"HelloWorld.class"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// J5TODO: Need to add deleteFile calls to many of these tests
comment|/** 	 * Transform simple class from an immutable to a mutable object. 	 */
specifier|public
name|void
name|testTransformClassToClassGen_SimpleTypes
parameter_list|()
throws|throws
name|ClassNotFoundException
block|{
name|JavaClass
name|jc
init|=
name|getTestClass
argument_list|(
literal|"org.apache.bcel.data.SimpleAnnotatedClass"
argument_list|)
decl_stmt|;
name|ClassGen
name|cgen
init|=
operator|new
name|ClassGen
argument_list|(
name|jc
argument_list|)
decl_stmt|;
comment|// Check annotations are correctly preserved
name|AnnotationEntryGen
index|[]
name|annotations
init|=
name|cgen
operator|.
name|getAnnotationEntries
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Expected one annotation but found "
operator|+
name|annotations
operator|.
name|length
argument_list|,
name|annotations
operator|.
name|length
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Transform simple class from an immutable to a mutable object. The class 	 * is annotated with an annotation that uses an enum. 	 */
specifier|public
name|void
name|testTransformClassToClassGen_EnumType
parameter_list|()
throws|throws
name|ClassNotFoundException
block|{
name|JavaClass
name|jc
init|=
name|getTestClass
argument_list|(
literal|"org.apache.bcel.data.AnnotatedWithEnumClass"
argument_list|)
decl_stmt|;
name|ClassGen
name|cgen
init|=
operator|new
name|ClassGen
argument_list|(
name|jc
argument_list|)
decl_stmt|;
comment|// Check annotations are correctly preserved
name|AnnotationEntryGen
index|[]
name|annotations
init|=
name|cgen
operator|.
name|getAnnotationEntries
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Expected one annotation but found "
operator|+
name|annotations
operator|.
name|length
argument_list|,
name|annotations
operator|.
name|length
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Transform simple class from an immutable to a mutable object. The class 	 * is annotated with an annotation that uses an array of SimpleAnnotations. 	 */
specifier|public
name|void
name|testTransformClassToClassGen_ArrayAndAnnotationTypes
parameter_list|()
throws|throws
name|ClassNotFoundException
block|{
name|JavaClass
name|jc
init|=
name|getTestClass
argument_list|(
literal|"org.apache.bcel.data.AnnotatedWithCombinedAnnotation"
argument_list|)
decl_stmt|;
name|ClassGen
name|cgen
init|=
operator|new
name|ClassGen
argument_list|(
name|jc
argument_list|)
decl_stmt|;
comment|// Check annotations are correctly preserved
name|AnnotationEntryGen
index|[]
name|annotations
init|=
name|cgen
operator|.
name|getAnnotationEntries
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Expected one annotation but found "
operator|+
name|annotations
operator|.
name|length
argument_list|,
name|annotations
operator|.
name|length
operator|==
literal|1
argument_list|)
expr_stmt|;
name|AnnotationEntryGen
name|a
init|=
name|annotations
index|[
literal|0
index|]
decl_stmt|;
name|assertTrue
argument_list|(
literal|"That annotation should only have one value but has "
operator|+
name|a
operator|.
name|getValues
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|a
operator|.
name|getValues
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ElementValuePairGen
name|nvp
init|=
operator|(
name|ElementValuePairGen
operator|)
name|a
operator|.
name|getValues
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ElementValueGen
name|value
init|=
name|nvp
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Value should be ArrayElementValueGen but is "
operator|+
name|value
argument_list|,
name|value
operator|instanceof
name|ArrayElementValueGen
argument_list|)
expr_stmt|;
name|ArrayElementValueGen
name|arrayValue
init|=
operator|(
name|ArrayElementValueGen
operator|)
name|value
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Array value should be size one but is "
operator|+
name|arrayValue
operator|.
name|getElementValuesSize
argument_list|()
argument_list|,
name|arrayValue
operator|.
name|getElementValuesSize
argument_list|()
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ElementValueGen
name|innerValue
init|=
operator|(
name|ElementValueGen
operator|)
name|arrayValue
operator|.
name|getElementValues
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Value in the array should be AnnotationElementValueGen but is "
operator|+
name|innerValue
argument_list|,
name|innerValue
operator|instanceof
name|AnnotationElementValueGen
argument_list|)
expr_stmt|;
name|AnnotationElementValueGen
name|innerAnnotationValue
init|=
operator|(
name|AnnotationElementValueGen
operator|)
name|innerValue
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Should be called Lorg/apache/bcel/data/SimpleAnnotation; but is called: "
operator|+
name|innerAnnotationValue
operator|.
name|getAnnotation
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|,
name|innerAnnotationValue
operator|.
name|getAnnotation
argument_list|()
operator|.
name|getTypeSignature
argument_list|()
operator|.
name|equals
argument_list|(
literal|"Lorg/apache/bcel/data/SimpleAnnotation;"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Transform complex class from an immutable to a mutable object. 	 */
specifier|public
name|void
name|testTransformComplexClassToClassGen
parameter_list|()
throws|throws
name|ClassNotFoundException
block|{
name|JavaClass
name|jc
init|=
name|getTestClass
argument_list|(
literal|"org.apache.bcel.data.ComplexAnnotatedClass"
argument_list|)
decl_stmt|;
name|ClassGen
name|cgen
init|=
operator|new
name|ClassGen
argument_list|(
name|jc
argument_list|)
decl_stmt|;
comment|// Check annotations are correctly preserved
name|AnnotationEntryGen
index|[]
name|annotations
init|=
name|cgen
operator|.
name|getAnnotationEntries
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Expected one annotation but found "
operator|+
name|annotations
operator|.
name|length
argument_list|,
name|annotations
operator|.
name|length
operator|==
literal|1
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|?
argument_list|>
name|l
init|=
name|annotations
index|[
literal|0
index|]
operator|.
name|getValues
argument_list|()
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
init|=
name|l
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ElementValuePairGen
name|element
init|=
operator|(
name|ElementValuePairGen
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|element
operator|.
name|getNameString
argument_list|()
operator|.
name|equals
argument_list|(
literal|"dval"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|SimpleElementValueGen
operator|)
name|element
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|stringifyValue
argument_list|()
operator|.
name|equals
argument_list|(
literal|"33.4"
argument_list|)
condition|)
name|found
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
literal|"Did not find double annotation value with value 33.4"
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Load a class in and modify it with a new attribute - A SimpleAnnotation 	 * annotation 	 */
specifier|public
name|void
name|testModifyingClasses1
parameter_list|()
throws|throws
name|ClassNotFoundException
block|{
name|JavaClass
name|jc
init|=
name|getTestClass
argument_list|(
literal|"org.apache.bcel.data.SimpleAnnotatedClass"
argument_list|)
decl_stmt|;
name|ClassGen
name|cgen
init|=
operator|new
name|ClassGen
argument_list|(
name|jc
argument_list|)
decl_stmt|;
name|ConstantPoolGen
name|cp
init|=
name|cgen
operator|.
name|getConstantPool
argument_list|()
decl_stmt|;
name|cgen
operator|.
name|addAnnotationEntry
argument_list|(
name|createFruitAnnotation
argument_list|(
name|cp
argument_list|,
literal|"Pineapple"
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Should now have two annotations but has "
operator|+
name|cgen
operator|.
name|getAnnotationEntries
argument_list|()
operator|.
name|length
argument_list|,
name|cgen
operator|.
name|getAnnotationEntries
argument_list|()
operator|.
name|length
operator|==
literal|2
argument_list|)
expr_stmt|;
name|dumpClass
argument_list|(
name|cgen
argument_list|,
literal|"SimpleAnnotatedClass.class"
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|wipe
argument_list|(
literal|"SimpleAnnotatedClass.class"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Load a class in and modify it with a new attribute - A ComplexAnnotation 	 * annotation 	 */
specifier|public
name|void
name|testModifyingClasses2
parameter_list|()
throws|throws
name|ClassNotFoundException
block|{
name|JavaClass
name|jc
init|=
name|getTestClass
argument_list|(
literal|"org.apache.bcel.data.SimpleAnnotatedClass"
argument_list|)
decl_stmt|;
name|ClassGen
name|cgen
init|=
operator|new
name|ClassGen
argument_list|(
name|jc
argument_list|)
decl_stmt|;
name|ConstantPoolGen
name|cp
init|=
name|cgen
operator|.
name|getConstantPool
argument_list|()
decl_stmt|;
name|cgen
operator|.
name|addAnnotationEntry
argument_list|(
name|createCombinedAnnotation
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Should now have two annotations but has "
operator|+
name|cgen
operator|.
name|getAnnotationEntries
argument_list|()
operator|.
name|length
argument_list|,
name|cgen
operator|.
name|getAnnotationEntries
argument_list|()
operator|.
name|length
operator|==
literal|2
argument_list|)
expr_stmt|;
name|dumpClass
argument_list|(
name|cgen
argument_list|,
literal|"SimpleAnnotatedClass.class"
argument_list|)
expr_stmt|;
name|JavaClass
name|jc2
init|=
name|getClassFrom
argument_list|(
literal|"."
argument_list|,
literal|"SimpleAnnotatedClass"
argument_list|)
decl_stmt|;
name|jc2
operator|.
name|getAnnotationEntries
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|wipe
argument_list|(
literal|"SimpleAnnotatedClass.class"
argument_list|)
argument_list|)
expr_stmt|;
comment|// System.err.println(jc2.toString());
block|}
specifier|private
name|void
name|dumpClass
parameter_list|(
name|ClassGen
name|cg
parameter_list|,
name|String
name|fname
parameter_list|)
block|{
try|try
block|{
name|File
name|f
init|=
name|createTestdataFile
argument_list|(
name|fname
argument_list|)
decl_stmt|;
name|cg
operator|.
name|getJavaClass
argument_list|()
operator|.
name|dump
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|dumpClass
parameter_list|(
name|ClassGen
name|cg
parameter_list|,
name|String
name|dir
parameter_list|,
name|String
name|fname
parameter_list|)
block|{
name|dumpClass
argument_list|(
name|cg
argument_list|,
name|dir
operator|+
name|File
operator|.
name|separator
operator|+
name|fname
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|buildClassContentsWithAnnotatedMethods
parameter_list|(
name|ClassGen
name|cg
parameter_list|,
name|ConstantPoolGen
name|cp
parameter_list|,
name|InstructionList
name|il
parameter_list|)
block|{
comment|// Create method 'public static void main(String[]argv)'
name|MethodGen
name|mg
init|=
name|createMethodGen
argument_list|(
literal|"main"
argument_list|,
name|il
argument_list|,
name|cp
argument_list|)
decl_stmt|;
name|InstructionFactory
name|factory
init|=
operator|new
name|InstructionFactory
argument_list|(
name|cg
argument_list|)
decl_stmt|;
name|mg
operator|.
name|addAnnotationEntry
argument_list|(
name|createSimpleVisibleAnnotation
argument_list|(
name|mg
operator|.
name|getConstantPool
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// We now define some often used types:
name|ObjectType
name|i_stream
init|=
operator|new
name|ObjectType
argument_list|(
literal|"java.io.InputStream"
argument_list|)
decl_stmt|;
name|ObjectType
name|p_stream
init|=
operator|new
name|ObjectType
argument_list|(
literal|"java.io.PrintStream"
argument_list|)
decl_stmt|;
comment|// Create variables in and name : We call the constructors, i.e.,
comment|// execute BufferedReader(InputStreamReader(System.in)) . The reference
comment|// to the BufferedReader object stays on top of the stack and is stored
comment|// in the newly allocated in variable.
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createNew
argument_list|(
literal|"java.io.BufferedReader"
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|InstructionConstants
operator|.
name|DUP
argument_list|)
expr_stmt|;
comment|// Use predefined constant
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createNew
argument_list|(
literal|"java.io.InputStreamReader"
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|InstructionConstants
operator|.
name|DUP
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createFieldAccess
argument_list|(
literal|"java.lang.System"
argument_list|,
literal|"in"
argument_list|,
name|i_stream
argument_list|,
name|Constants
operator|.
name|GETSTATIC
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createInvoke
argument_list|(
literal|"java.io.InputStreamReader"
argument_list|,
literal|"<init>"
argument_list|,
name|Type
operator|.
name|VOID
argument_list|,
operator|new
name|Type
index|[]
block|{
name|i_stream
block|}
argument_list|,
name|Constants
operator|.
name|INVOKESPECIAL
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createInvoke
argument_list|(
literal|"java.io.BufferedReader"
argument_list|,
literal|"<init>"
argument_list|,
name|Type
operator|.
name|VOID
argument_list|,
operator|new
name|Type
index|[]
block|{
operator|new
name|ObjectType
argument_list|(
literal|"java.io.Reader"
argument_list|)
block|}
argument_list|,
name|Constants
operator|.
name|INVOKESPECIAL
argument_list|)
argument_list|)
expr_stmt|;
name|LocalVariableGen
name|lg
init|=
name|mg
operator|.
name|addLocalVariable
argument_list|(
literal|"in"
argument_list|,
operator|new
name|ObjectType
argument_list|(
literal|"java.io.BufferedReader"
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|int
name|in
init|=
name|lg
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|lg
operator|.
name|setStart
argument_list|(
name|il
operator|.
name|append
argument_list|(
operator|new
name|ASTORE
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// "in" valid from here
comment|// Create local variable name and initialize it to null
name|lg
operator|=
name|mg
operator|.
name|addLocalVariable
argument_list|(
literal|"name"
argument_list|,
name|Type
operator|.
name|STRING
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|int
name|name
init|=
name|lg
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|il
operator|.
name|append
argument_list|(
name|InstructionConstants
operator|.
name|ACONST_NULL
argument_list|)
expr_stmt|;
name|lg
operator|.
name|setStart
argument_list|(
name|il
operator|.
name|append
argument_list|(
operator|new
name|ASTORE
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// "name" valid from here
comment|// Create try-catch block: We remember the start of the block, read a
comment|// line from the standard input and store it into the variable name .
comment|// InstructionHandle try_start = il.append(factory.createFieldAccess(
comment|// "java.lang.System", "out", p_stream, Constants.GETSTATIC));
comment|// il.append(new PUSH(cp, "Please enter your name> "));
comment|// il.append(factory.createInvoke("java.io.PrintStream", "print",
comment|// Type.VOID, new Type[] { Type.STRING },
comment|// Constants.INVOKEVIRTUAL));
comment|// il.append(new ALOAD(in));
comment|// il.append(factory.createInvoke("java.io.BufferedReader", "readLine",
comment|// Type.STRING, Type.NO_ARGS, Constants.INVOKEVIRTUAL));
name|InstructionHandle
name|try_start
init|=
name|il
operator|.
name|append
argument_list|(
operator|new
name|PUSH
argument_list|(
name|cp
argument_list|,
literal|"Andy"
argument_list|)
argument_list|)
decl_stmt|;
name|il
operator|.
name|append
argument_list|(
operator|new
name|ASTORE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|// Upon normal execution we jump behind exception handler, the target
comment|// address is not known yet.
name|GOTO
name|g
init|=
operator|new
name|GOTO
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|InstructionHandle
name|try_end
init|=
name|il
operator|.
name|append
argument_list|(
name|g
argument_list|)
decl_stmt|;
comment|// We add the exception handler which simply returns from the method.
name|LocalVariableGen
name|var_ex
init|=
name|mg
operator|.
name|addLocalVariable
argument_list|(
literal|"ex"
argument_list|,
name|Type
operator|.
name|getType
argument_list|(
literal|"Ljava.io.IOException;"
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|int
name|var_ex_slot
init|=
name|var_ex
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|InstructionHandle
name|handler
init|=
name|il
operator|.
name|append
argument_list|(
operator|new
name|ASTORE
argument_list|(
name|var_ex_slot
argument_list|)
argument_list|)
decl_stmt|;
name|var_ex
operator|.
name|setStart
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|var_ex
operator|.
name|setEnd
argument_list|(
name|il
operator|.
name|append
argument_list|(
name|InstructionConstants
operator|.
name|RETURN
argument_list|)
argument_list|)
expr_stmt|;
name|mg
operator|.
name|addExceptionHandler
argument_list|(
name|try_start
argument_list|,
name|try_end
argument_list|,
name|handler
argument_list|,
operator|new
name|ObjectType
argument_list|(
literal|"java.io.IOException"
argument_list|)
argument_list|)
expr_stmt|;
comment|// "Normal" code continues, now we can set the branch target of the GOTO
comment|// .
name|InstructionHandle
name|ih
init|=
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createFieldAccess
argument_list|(
literal|"java.lang.System"
argument_list|,
literal|"out"
argument_list|,
name|p_stream
argument_list|,
name|Constants
operator|.
name|GETSTATIC
argument_list|)
argument_list|)
decl_stmt|;
name|g
operator|.
name|setTarget
argument_list|(
name|ih
argument_list|)
expr_stmt|;
comment|// Printing "Hello": String concatenation compiles to StringBuffer
comment|// operations.
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createNew
argument_list|(
name|Type
operator|.
name|STRINGBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|InstructionConstants
operator|.
name|DUP
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
operator|new
name|PUSH
argument_list|(
name|cp
argument_list|,
literal|"Hello, "
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createInvoke
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"<init>"
argument_list|,
name|Type
operator|.
name|VOID
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|STRING
block|}
argument_list|,
name|Constants
operator|.
name|INVOKESPECIAL
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
operator|new
name|ALOAD
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createInvoke
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"append"
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|STRING
block|}
argument_list|,
name|Constants
operator|.
name|INVOKEVIRTUAL
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createInvoke
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"toString"
argument_list|,
name|Type
operator|.
name|STRING
argument_list|,
name|Type
operator|.
name|NO_ARGS
argument_list|,
name|Constants
operator|.
name|INVOKEVIRTUAL
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createInvoke
argument_list|(
literal|"java.io.PrintStream"
argument_list|,
literal|"println"
argument_list|,
name|Type
operator|.
name|VOID
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|STRING
block|}
argument_list|,
name|Constants
operator|.
name|INVOKEVIRTUAL
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|InstructionConstants
operator|.
name|RETURN
argument_list|)
expr_stmt|;
comment|// Finalization: Finally, we have to set the stack size, which normally
comment|// would have to be computed on the fly and add a default constructor
comment|// method to the class, which is empty in this case.
name|mg
operator|.
name|setMaxStack
argument_list|()
expr_stmt|;
name|mg
operator|.
name|setMaxLocals
argument_list|()
expr_stmt|;
name|cg
operator|.
name|addMethod
argument_list|(
name|mg
operator|.
name|getMethod
argument_list|()
argument_list|)
expr_stmt|;
name|il
operator|.
name|dispose
argument_list|()
expr_stmt|;
comment|// Allow instruction handles to be reused
name|cg
operator|.
name|addEmptyConstructor
argument_list|(
name|Constants
operator|.
name|ACC_PUBLIC
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|buildClassContents
parameter_list|(
name|ClassGen
name|cg
parameter_list|,
name|ConstantPoolGen
name|cp
parameter_list|,
name|InstructionList
name|il
parameter_list|)
block|{
comment|// Create method 'public static void main(String[]argv)'
name|MethodGen
name|mg
init|=
name|createMethodGen
argument_list|(
literal|"main"
argument_list|,
name|il
argument_list|,
name|cp
argument_list|)
decl_stmt|;
name|InstructionFactory
name|factory
init|=
operator|new
name|InstructionFactory
argument_list|(
name|cg
argument_list|)
decl_stmt|;
comment|// We now define some often used types:
name|ObjectType
name|i_stream
init|=
operator|new
name|ObjectType
argument_list|(
literal|"java.io.InputStream"
argument_list|)
decl_stmt|;
name|ObjectType
name|p_stream
init|=
operator|new
name|ObjectType
argument_list|(
literal|"java.io.PrintStream"
argument_list|)
decl_stmt|;
comment|// Create variables in and name : We call the constructors, i.e.,
comment|// execute BufferedReader(InputStreamReader(System.in)) . The reference
comment|// to the BufferedReader object stays on top of the stack and is stored
comment|// in the newly allocated in variable.
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createNew
argument_list|(
literal|"java.io.BufferedReader"
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|InstructionConstants
operator|.
name|DUP
argument_list|)
expr_stmt|;
comment|// Use predefined constant
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createNew
argument_list|(
literal|"java.io.InputStreamReader"
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|InstructionConstants
operator|.
name|DUP
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createFieldAccess
argument_list|(
literal|"java.lang.System"
argument_list|,
literal|"in"
argument_list|,
name|i_stream
argument_list|,
name|Constants
operator|.
name|GETSTATIC
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createInvoke
argument_list|(
literal|"java.io.InputStreamReader"
argument_list|,
literal|"<init>"
argument_list|,
name|Type
operator|.
name|VOID
argument_list|,
operator|new
name|Type
index|[]
block|{
name|i_stream
block|}
argument_list|,
name|Constants
operator|.
name|INVOKESPECIAL
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createInvoke
argument_list|(
literal|"java.io.BufferedReader"
argument_list|,
literal|"<init>"
argument_list|,
name|Type
operator|.
name|VOID
argument_list|,
operator|new
name|Type
index|[]
block|{
operator|new
name|ObjectType
argument_list|(
literal|"java.io.Reader"
argument_list|)
block|}
argument_list|,
name|Constants
operator|.
name|INVOKESPECIAL
argument_list|)
argument_list|)
expr_stmt|;
name|LocalVariableGen
name|lg
init|=
name|mg
operator|.
name|addLocalVariable
argument_list|(
literal|"in"
argument_list|,
operator|new
name|ObjectType
argument_list|(
literal|"java.io.BufferedReader"
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|int
name|in
init|=
name|lg
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|lg
operator|.
name|setStart
argument_list|(
name|il
operator|.
name|append
argument_list|(
operator|new
name|ASTORE
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// "in" valid from here
comment|// Create local variable name and initialize it to null
name|lg
operator|=
name|mg
operator|.
name|addLocalVariable
argument_list|(
literal|"name"
argument_list|,
name|Type
operator|.
name|STRING
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|int
name|name
init|=
name|lg
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|il
operator|.
name|append
argument_list|(
name|InstructionConstants
operator|.
name|ACONST_NULL
argument_list|)
expr_stmt|;
name|lg
operator|.
name|setStart
argument_list|(
name|il
operator|.
name|append
argument_list|(
operator|new
name|ASTORE
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// "name" valid from here
comment|// Create try-catch block: We remember the start of the block, read a
comment|// line from the standard input and store it into the variable name .
comment|// InstructionHandle try_start = il.append(factory.createFieldAccess(
comment|// "java.lang.System", "out", p_stream, Constants.GETSTATIC));
comment|// il.append(new PUSH(cp, "Please enter your name> "));
comment|// il.append(factory.createInvoke("java.io.PrintStream", "print",
comment|// Type.VOID, new Type[] { Type.STRING },
comment|// Constants.INVOKEVIRTUAL));
comment|// il.append(new ALOAD(in));
comment|// il.append(factory.createInvoke("java.io.BufferedReader", "readLine",
comment|// Type.STRING, Type.NO_ARGS, Constants.INVOKEVIRTUAL));
name|InstructionHandle
name|try_start
init|=
name|il
operator|.
name|append
argument_list|(
operator|new
name|PUSH
argument_list|(
name|cp
argument_list|,
literal|"Andy"
argument_list|)
argument_list|)
decl_stmt|;
name|il
operator|.
name|append
argument_list|(
operator|new
name|ASTORE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|// Upon normal execution we jump behind exception handler, the target
comment|// address is not known yet.
name|GOTO
name|g
init|=
operator|new
name|GOTO
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|InstructionHandle
name|try_end
init|=
name|il
operator|.
name|append
argument_list|(
name|g
argument_list|)
decl_stmt|;
comment|// We add the exception handler which simply returns from the method.
name|LocalVariableGen
name|var_ex
init|=
name|mg
operator|.
name|addLocalVariable
argument_list|(
literal|"ex"
argument_list|,
name|Type
operator|.
name|getType
argument_list|(
literal|"Ljava.io.IOException;"
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|int
name|var_ex_slot
init|=
name|var_ex
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|InstructionHandle
name|handler
init|=
name|il
operator|.
name|append
argument_list|(
operator|new
name|ASTORE
argument_list|(
name|var_ex_slot
argument_list|)
argument_list|)
decl_stmt|;
name|var_ex
operator|.
name|setStart
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|var_ex
operator|.
name|setEnd
argument_list|(
name|il
operator|.
name|append
argument_list|(
name|InstructionConstants
operator|.
name|RETURN
argument_list|)
argument_list|)
expr_stmt|;
name|mg
operator|.
name|addExceptionHandler
argument_list|(
name|try_start
argument_list|,
name|try_end
argument_list|,
name|handler
argument_list|,
operator|new
name|ObjectType
argument_list|(
literal|"java.io.IOException"
argument_list|)
argument_list|)
expr_stmt|;
comment|// "Normal" code continues, now we can set the branch target of the GOTO
comment|// .
name|InstructionHandle
name|ih
init|=
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createFieldAccess
argument_list|(
literal|"java.lang.System"
argument_list|,
literal|"out"
argument_list|,
name|p_stream
argument_list|,
name|Constants
operator|.
name|GETSTATIC
argument_list|)
argument_list|)
decl_stmt|;
name|g
operator|.
name|setTarget
argument_list|(
name|ih
argument_list|)
expr_stmt|;
comment|// Printing "Hello": String concatenation compiles to StringBuffer
comment|// operations.
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createNew
argument_list|(
name|Type
operator|.
name|STRINGBUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|InstructionConstants
operator|.
name|DUP
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
operator|new
name|PUSH
argument_list|(
name|cp
argument_list|,
literal|"Hello, "
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createInvoke
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"<init>"
argument_list|,
name|Type
operator|.
name|VOID
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|STRING
block|}
argument_list|,
name|Constants
operator|.
name|INVOKESPECIAL
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
operator|new
name|ALOAD
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createInvoke
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"append"
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|STRING
block|}
argument_list|,
name|Constants
operator|.
name|INVOKEVIRTUAL
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createInvoke
argument_list|(
literal|"java.lang.StringBuffer"
argument_list|,
literal|"toString"
argument_list|,
name|Type
operator|.
name|STRING
argument_list|,
name|Type
operator|.
name|NO_ARGS
argument_list|,
name|Constants
operator|.
name|INVOKEVIRTUAL
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|factory
operator|.
name|createInvoke
argument_list|(
literal|"java.io.PrintStream"
argument_list|,
literal|"println"
argument_list|,
name|Type
operator|.
name|VOID
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|STRING
block|}
argument_list|,
name|Constants
operator|.
name|INVOKEVIRTUAL
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
name|InstructionConstants
operator|.
name|RETURN
argument_list|)
expr_stmt|;
comment|// Finalization: Finally, we have to set the stack size, which normally
comment|// would have to be computed on the fly and add a default constructor
comment|// method to the class, which is empty in this case.
name|mg
operator|.
name|setMaxStack
argument_list|()
expr_stmt|;
name|mg
operator|.
name|setMaxLocals
argument_list|()
expr_stmt|;
name|cg
operator|.
name|addMethod
argument_list|(
name|mg
operator|.
name|getMethod
argument_list|()
argument_list|)
expr_stmt|;
name|il
operator|.
name|dispose
argument_list|()
expr_stmt|;
comment|// Allow instruction handles to be reused
name|cg
operator|.
name|addEmptyConstructor
argument_list|(
name|Constants
operator|.
name|ACC_PUBLIC
argument_list|)
expr_stmt|;
block|}
specifier|private
name|JavaClass
name|getClassFrom
parameter_list|(
name|String
name|where
parameter_list|,
name|String
name|clazzname
parameter_list|)
throws|throws
name|ClassNotFoundException
block|{
comment|// System.out.println(where);
name|SyntheticRepository
name|repos
init|=
name|createRepos
argument_list|(
name|where
argument_list|)
decl_stmt|;
return|return
name|repos
operator|.
name|loadClass
argument_list|(
name|clazzname
argument_list|)
return|;
block|}
comment|// helper methods
specifier|private
name|ClassGen
name|createClassGen
parameter_list|(
name|String
name|classname
parameter_list|)
block|{
return|return
operator|new
name|ClassGen
argument_list|(
name|classname
argument_list|,
literal|"java.lang.Object"
argument_list|,
literal|"<generated>"
argument_list|,
name|Constants
operator|.
name|ACC_PUBLIC
operator||
name|Constants
operator|.
name|ACC_SUPER
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
name|MethodGen
name|createMethodGen
parameter_list|(
name|String
name|methodname
parameter_list|,
name|InstructionList
name|il
parameter_list|,
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
return|return
operator|new
name|MethodGen
argument_list|(
name|Constants
operator|.
name|ACC_STATIC
operator||
name|Constants
operator|.
name|ACC_PUBLIC
argument_list|,
comment|// access
comment|// flags
name|Type
operator|.
name|VOID
argument_list|,
comment|// return type
operator|new
name|Type
index|[]
block|{
operator|new
name|ArrayType
argument_list|(
name|Type
operator|.
name|STRING
argument_list|,
literal|1
argument_list|)
block|}
argument_list|,
comment|// argument
comment|// types
operator|new
name|String
index|[]
block|{
literal|"argv"
block|}
argument_list|,
comment|// arg names
name|methodname
argument_list|,
literal|"HelloWorld"
argument_list|,
comment|// method, class
name|il
argument_list|,
name|cp
argument_list|)
return|;
block|}
specifier|public
name|AnnotationEntryGen
name|createSimpleVisibleAnnotation
parameter_list|(
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
name|SimpleElementValueGen
name|evg
init|=
operator|new
name|SimpleElementValueGen
argument_list|(
name|ElementValueGen
operator|.
name|PRIMITIVE_INT
argument_list|,
name|cp
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|ElementValuePairGen
name|nvGen
init|=
operator|new
name|ElementValuePairGen
argument_list|(
literal|"id"
argument_list|,
name|evg
argument_list|,
name|cp
argument_list|)
decl_stmt|;
name|ObjectType
name|t
init|=
operator|new
name|ObjectType
argument_list|(
literal|"SimpleAnnotation"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ElementValuePairGen
argument_list|>
name|elements
init|=
operator|new
name|ArrayList
argument_list|<
name|ElementValuePairGen
argument_list|>
argument_list|()
decl_stmt|;
name|elements
operator|.
name|add
argument_list|(
name|nvGen
argument_list|)
expr_stmt|;
name|AnnotationEntryGen
name|a
init|=
operator|new
name|AnnotationEntryGen
argument_list|(
name|t
argument_list|,
name|elements
argument_list|,
literal|true
argument_list|,
name|cp
argument_list|)
decl_stmt|;
return|return
name|a
return|;
block|}
specifier|public
name|AnnotationEntryGen
name|createFruitAnnotation
parameter_list|(
name|ConstantPoolGen
name|cp
parameter_list|,
name|String
name|aFruit
parameter_list|)
block|{
name|SimpleElementValueGen
name|evg
init|=
operator|new
name|SimpleElementValueGen
argument_list|(
name|ElementValueGen
operator|.
name|STRING
argument_list|,
name|cp
argument_list|,
name|aFruit
argument_list|)
decl_stmt|;
name|ElementValuePairGen
name|nvGen
init|=
operator|new
name|ElementValuePairGen
argument_list|(
literal|"fruit"
argument_list|,
name|evg
argument_list|,
name|cp
argument_list|)
decl_stmt|;
name|ObjectType
name|t
init|=
operator|new
name|ObjectType
argument_list|(
literal|"SimpleStringAnnotation"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ElementValuePairGen
argument_list|>
name|elements
init|=
operator|new
name|ArrayList
argument_list|<
name|ElementValuePairGen
argument_list|>
argument_list|()
decl_stmt|;
name|elements
operator|.
name|add
argument_list|(
name|nvGen
argument_list|)
expr_stmt|;
return|return
operator|new
name|AnnotationEntryGen
argument_list|(
name|t
argument_list|,
name|elements
argument_list|,
literal|true
argument_list|,
name|cp
argument_list|)
return|;
block|}
specifier|public
name|AnnotationEntryGen
name|createCombinedAnnotation
parameter_list|(
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
comment|// Create an annotation instance
name|AnnotationEntryGen
name|a
init|=
name|createSimpleVisibleAnnotation
argument_list|(
name|cp
argument_list|)
decl_stmt|;
name|ArrayElementValueGen
name|array
init|=
operator|new
name|ArrayElementValueGen
argument_list|(
name|cp
argument_list|)
decl_stmt|;
name|array
operator|.
name|addElement
argument_list|(
operator|new
name|AnnotationElementValueGen
argument_list|(
name|a
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|ElementValuePairGen
name|nvp
init|=
operator|new
name|ElementValuePairGen
argument_list|(
literal|"value"
argument_list|,
name|array
argument_list|,
name|cp
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ElementValuePairGen
argument_list|>
name|elements
init|=
operator|new
name|ArrayList
argument_list|<
name|ElementValuePairGen
argument_list|>
argument_list|()
decl_stmt|;
name|elements
operator|.
name|add
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|new
name|AnnotationEntryGen
argument_list|(
operator|new
name|ObjectType
argument_list|(
literal|"CombinedAnnotation"
argument_list|)
argument_list|,
name|elements
argument_list|,
literal|true
argument_list|,
name|cp
argument_list|)
return|;
block|}
specifier|public
name|AnnotationEntryGen
name|createSimpleInvisibleAnnotation
parameter_list|(
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
name|SimpleElementValueGen
name|evg
init|=
operator|new
name|SimpleElementValueGen
argument_list|(
name|ElementValueGen
operator|.
name|PRIMITIVE_INT
argument_list|,
name|cp
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|ElementValuePairGen
name|nvGen
init|=
operator|new
name|ElementValuePairGen
argument_list|(
literal|"id"
argument_list|,
name|evg
argument_list|,
name|cp
argument_list|)
decl_stmt|;
name|ObjectType
name|t
init|=
operator|new
name|ObjectType
argument_list|(
literal|"SimpleAnnotation"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ElementValuePairGen
argument_list|>
name|elements
init|=
operator|new
name|ArrayList
argument_list|<
name|ElementValuePairGen
argument_list|>
argument_list|()
decl_stmt|;
name|elements
operator|.
name|add
argument_list|(
name|nvGen
argument_list|)
expr_stmt|;
name|AnnotationEntryGen
name|a
init|=
operator|new
name|AnnotationEntryGen
argument_list|(
name|t
argument_list|,
name|elements
argument_list|,
literal|false
argument_list|,
name|cp
argument_list|)
decl_stmt|;
return|return
name|a
return|;
block|}
block|}
end_class

end_unit

