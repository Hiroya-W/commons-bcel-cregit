begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|statics
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|Const
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|Repository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Attribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Code
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|CodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Constant
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantFieldref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantInterfaceMethodref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantMethodref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantNameAndType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ConstantUtf8
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|JavaClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|LineNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|LineNumberTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|LocalVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|LocalVariableTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ALOAD
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ANEWARRAY
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ASTORE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ATHROW
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ArrayType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|BREAKPOINT
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|CHECKCAST
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ConstantPoolGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|DLOAD
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|DSTORE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|FLOAD
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|FSTORE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|FieldInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|GETSTATIC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|GotoInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|IINC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ILOAD
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|IMPDEP1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|IMPDEP2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|INSTANCEOF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|INVOKEDYNAMIC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|INVOKEINTERFACE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|INVOKESPECIAL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|INVOKESTATIC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|INVOKEVIRTUAL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ISTORE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|Instruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|InstructionHandle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|InstructionList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|InvokeInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|JsrInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|LDC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|LDC2_W
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|LLOAD
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|LOOKUPSWITCH
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|LSTORE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|LoadClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|MULTIANEWARRAY
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|NEW
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|NEWARRAY
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ObjectType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|PUTSTATIC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|RET
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ReferenceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ReturnInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|TABLESWITCH
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|PassVerifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|VerificationResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|Verifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|VerifierFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|exc
operator|.
name|AssertionViolatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|exc
operator|.
name|ClassConstraintException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|exc
operator|.
name|InvalidMethodException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|exc
operator|.
name|StaticCodeConstraintException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|exc
operator|.
name|StaticCodeInstructionConstraintException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|exc
operator|.
name|StaticCodeInstructionOperandConstraintException
import|;
end_import

begin_comment
comment|/**  * This PassVerifier verifies a class file according to  * pass 3, static part as described in The Java Virtual  * Machine Specification, 2nd edition.  * More detailed information is to be found at the do_verify()  * method's documentation.   *  * @version $Id$  * @see #do_verify()  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|Pass3aVerifier
extends|extends
name|PassVerifier
block|{
comment|/** The Verifier that created this. */
specifier|private
specifier|final
name|Verifier
name|myOwner
decl_stmt|;
comment|/**       * The method number to verify.      * This is the index in the array returned      * by JavaClass.getMethods().      */
specifier|private
specifier|final
name|int
name|method_no
decl_stmt|;
comment|/**      * The one and only InstructionList object used by an instance of this class.      * It's here for performance reasons by do_verify() and its callees.      */
specifier|private
name|InstructionList
name|instructionList
decl_stmt|;
comment|/**      * The one and only Code object used by an instance of this class.      *  It's here for performance reasons by do_verify() and its callees.      */
specifier|private
name|Code
name|code
decl_stmt|;
comment|/** Should only be instantiated by a Verifier. */
specifier|public
name|Pass3aVerifier
parameter_list|(
specifier|final
name|Verifier
name|owner
parameter_list|,
specifier|final
name|int
name|method_no
parameter_list|)
block|{
name|myOwner
operator|=
name|owner
expr_stmt|;
name|this
operator|.
name|method_no
operator|=
name|method_no
expr_stmt|;
block|}
comment|/**      * Pass 3a is the verification of static constraints of      * JVM code (such as legal targets of branch instructions).      * This is the part of pass 3 where you do not need data      * flow analysis.      * JustIce also delays the checks for a correct exception      * table of a Code attribute and correct line number entries      * in a LineNumberTable attribute of a Code attribute (which      * conceptually belong to pass 2) to this pass. Also, most      * of the check for valid local variable entries in a      * LocalVariableTable attribute of a Code attribute is      * delayed until this pass.      * All these checks need access to the code array of the      * Code attribute.      *      * @throws InvalidMethodException if the method to verify does not exist.      */
annotation|@
name|Override
specifier|public
name|VerificationResult
name|do_verify
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|myOwner
operator|.
name|doPass2
argument_list|()
operator|.
name|equals
argument_list|(
name|VerificationResult
operator|.
name|VR_OK
argument_list|)
condition|)
block|{
comment|// Okay, class file was loaded correctly by Pass 1
comment|// and satisfies static constraints of Pass 2.
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|Method
index|[]
name|methods
init|=
name|jc
operator|.
name|getMethods
argument_list|()
decl_stmt|;
if|if
condition|(
name|method_no
operator|>=
name|methods
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|InvalidMethodException
argument_list|(
literal|"METHOD DOES NOT EXIST!"
argument_list|)
throw|;
block|}
name|Method
name|method
init|=
name|methods
index|[
name|method_no
index|]
decl_stmt|;
name|code
operator|=
name|method
operator|.
name|getCode
argument_list|()
expr_stmt|;
comment|// No Code? Nothing to verify!
if|if
condition|(
name|method
operator|.
name|isAbstract
argument_list|()
operator|||
name|method
operator|.
name|isNative
argument_list|()
condition|)
block|{
comment|// IF mg HAS NO CODE (static constraint of Pass 2)
return|return
name|VerificationResult
operator|.
name|VR_OK
return|;
block|}
comment|// TODO:
comment|// We want a very sophisticated code examination here with good explanations
comment|// on where to look for an illegal instruction or such.
comment|// Only after that we should try to build an InstructionList and throw an
comment|// AssertionViolatedException if after our examination InstructionList building
comment|// still fails.
comment|// That examination should be implemented in a byte-oriented way, i.e. look for
comment|// an instruction, make sure its validity, count its length, find the next
comment|// instruction and so on.
try|try
block|{
name|instructionList
operator|=
operator|new
name|InstructionList
argument_list|(
name|method
operator|.
name|getCode
argument_list|()
operator|.
name|getCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|re
parameter_list|)
block|{
return|return
operator|new
name|VerificationResult
argument_list|(
name|VerificationResult
operator|.
name|VERIFIED_REJECTED
argument_list|,
literal|"Bad bytecode in the code array of the Code attribute of method '"
operator|+
name|method
operator|+
literal|"'."
argument_list|)
return|;
block|}
name|instructionList
operator|.
name|setPositions
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Start verification.
name|VerificationResult
name|vr
init|=
name|VerificationResult
operator|.
name|VR_OK
decl_stmt|;
comment|//default
try|try
block|{
name|delayedPass2Checks
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassConstraintException
name|cce
parameter_list|)
block|{
name|vr
operator|=
operator|new
name|VerificationResult
argument_list|(
name|VerificationResult
operator|.
name|VERIFIED_REJECTED
argument_list|,
name|cce
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vr
return|;
block|}
try|try
block|{
name|pass3StaticInstructionChecks
argument_list|()
expr_stmt|;
name|pass3StaticInstructionOperandsChecks
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StaticCodeConstraintException
name|scce
parameter_list|)
block|{
name|vr
operator|=
operator|new
name|VerificationResult
argument_list|(
name|VerificationResult
operator|.
name|VERIFIED_REJECTED
argument_list|,
name|scce
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|cce
parameter_list|)
block|{
name|vr
operator|=
operator|new
name|VerificationResult
argument_list|(
name|VerificationResult
operator|.
name|VERIFIED_REJECTED
argument_list|,
literal|"Class Cast Exception: "
operator|+
name|cce
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|vr
return|;
block|}
comment|//did not pass Pass 2.
return|return
name|VerificationResult
operator|.
name|VR_NOTYET
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: maybe not the best way to handle this
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * These are the checks that could be done in pass 2 but are delayed to pass 3      * for performance reasons. Also, these checks need access to the code array      * of the Code attribute of a Method so it's okay to perform them here.      * Also see the description of the do_verify() method.      *      * @throws ClassConstraintException if the verification fails.      * @see #do_verify()      */
specifier|private
name|void
name|delayedPass2Checks
parameter_list|()
block|{
name|int
index|[]
name|instructionPositions
init|=
name|instructionList
operator|.
name|getInstructionPositions
argument_list|()
decl_stmt|;
name|int
name|codeLength
init|=
name|code
operator|.
name|getCode
argument_list|()
operator|.
name|length
decl_stmt|;
comment|/////////////////////
comment|// LineNumberTable //
comment|/////////////////////
name|LineNumberTable
name|lnt
init|=
name|code
operator|.
name|getLineNumberTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|lnt
operator|!=
literal|null
condition|)
block|{
name|LineNumber
index|[]
name|lineNumbers
init|=
name|lnt
operator|.
name|getLineNumberTable
argument_list|()
decl_stmt|;
name|IntList
name|offsets
init|=
operator|new
name|IntList
argument_list|()
decl_stmt|;
name|lineNumber_loop
label|:
for|for
control|(
name|LineNumber
name|lineNumber
range|:
name|lineNumbers
control|)
block|{
comment|// may appear in any order.
for|for
control|(
name|int
name|instructionPosition
range|:
name|instructionPositions
control|)
block|{
comment|// TODO: Make this a binary search! The instructionPositions array is naturally ordered!
name|int
name|offset
init|=
name|lineNumber
operator|.
name|getStartPC
argument_list|()
decl_stmt|;
if|if
condition|(
name|instructionPosition
operator|==
name|offset
condition|)
block|{
if|if
condition|(
name|offsets
operator|.
name|contains
argument_list|(
name|offset
argument_list|)
condition|)
block|{
name|addMessage
argument_list|(
literal|"LineNumberTable attribute '"
operator|+
name|code
operator|.
name|getLineNumberTable
argument_list|()
operator|+
literal|"' refers to the same code offset ('"
operator|+
name|offset
operator|+
literal|"') more than once"
operator|+
literal|" which is violating the semantics [but is sometimes produced by IBM's 'jikes' compiler]."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offsets
operator|.
name|add
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
continue|continue
name|lineNumber_loop
continue|;
block|}
block|}
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|code
operator|+
literal|"' has a LineNumberTable attribute '"
operator|+
name|code
operator|.
name|getLineNumberTable
argument_list|()
operator|+
literal|"' referring to a code offset ('"
operator|+
name|lineNumber
operator|.
name|getStartPC
argument_list|()
operator|+
literal|"') that does not exist."
argument_list|)
throw|;
block|}
block|}
comment|///////////////////////////
comment|// LocalVariableTable(s) //
comment|///////////////////////////
comment|/* We cannot use code.getLocalVariableTable() because there could be more            than only one. This is a bug in BCEL. */
name|Attribute
index|[]
name|atts
init|=
name|code
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
name|Attribute
name|att
range|:
name|atts
control|)
block|{
if|if
condition|(
name|att
operator|instanceof
name|LocalVariableTable
condition|)
block|{
name|LocalVariableTable
name|lvt
init|=
operator|(
name|LocalVariableTable
operator|)
name|att
decl_stmt|;
name|LocalVariable
index|[]
name|localVariables
init|=
name|lvt
operator|.
name|getLocalVariableTable
argument_list|()
decl_stmt|;
for|for
control|(
name|LocalVariable
name|localVariable
range|:
name|localVariables
control|)
block|{
name|int
name|startpc
init|=
name|localVariable
operator|.
name|getStartPC
argument_list|()
decl_stmt|;
name|int
name|length
init|=
name|localVariable
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|contains
argument_list|(
name|instructionPositions
argument_list|,
name|startpc
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|code
operator|+
literal|"' has a LocalVariableTable attribute '"
operator|+
name|code
operator|.
name|getLocalVariableTable
argument_list|()
operator|+
literal|"' referring to a code offset ('"
operator|+
name|startpc
operator|+
literal|"') that does not exist."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
operator|!
name|contains
argument_list|(
name|instructionPositions
argument_list|,
name|startpc
operator|+
name|length
argument_list|)
operator|)
operator|&&
operator|(
name|startpc
operator|+
name|length
operator|!=
name|codeLength
operator|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|code
operator|+
literal|"' has a LocalVariableTable attribute '"
operator|+
name|code
operator|.
name|getLocalVariableTable
argument_list|()
operator|+
literal|"' referring to a code offset start_pc+length ('"
operator|+
operator|(
name|startpc
operator|+
name|length
operator|)
operator|+
literal|"') that does not exist."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|////////////////////
comment|// ExceptionTable //
comment|////////////////////
comment|// In BCEL's "classfile" API, the startPC/endPC-notation is
comment|// inclusive/exclusive as in the Java Virtual Machine Specification.
comment|// WARNING: This is not true for BCEL's "generic" API.
name|CodeException
index|[]
name|exceptionTable
init|=
name|code
operator|.
name|getExceptionTable
argument_list|()
decl_stmt|;
for|for
control|(
name|CodeException
name|element
range|:
name|exceptionTable
control|)
block|{
name|int
name|startpc
init|=
name|element
operator|.
name|getStartPC
argument_list|()
decl_stmt|;
name|int
name|endpc
init|=
name|element
operator|.
name|getEndPC
argument_list|()
decl_stmt|;
name|int
name|handlerpc
init|=
name|element
operator|.
name|getHandlerPC
argument_list|()
decl_stmt|;
if|if
condition|(
name|startpc
operator|>=
name|endpc
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|code
operator|+
literal|"' has an exception_table entry '"
operator|+
name|element
operator|+
literal|"' that has its start_pc ('"
operator|+
name|startpc
operator|+
literal|"') not smaller than its end_pc ('"
operator|+
name|endpc
operator|+
literal|"')."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|contains
argument_list|(
name|instructionPositions
argument_list|,
name|startpc
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|code
operator|+
literal|"' has an exception_table entry '"
operator|+
name|element
operator|+
literal|"' that has a non-existant bytecode offset as its start_pc ('"
operator|+
name|startpc
operator|+
literal|"')."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
operator|!
name|contains
argument_list|(
name|instructionPositions
argument_list|,
name|endpc
argument_list|)
operator|)
operator|&&
operator|(
name|endpc
operator|!=
name|codeLength
operator|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|code
operator|+
literal|"' has an exception_table entry '"
operator|+
name|element
operator|+
literal|"' that has a non-existant bytecode offset as its end_pc ('"
operator|+
name|startpc
operator|+
literal|"') [that is also not equal to code_length ('"
operator|+
name|codeLength
operator|+
literal|"')]."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|contains
argument_list|(
name|instructionPositions
argument_list|,
name|handlerpc
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassConstraintException
argument_list|(
literal|"Code attribute '"
operator|+
name|code
operator|+
literal|"' has an exception_table entry '"
operator|+
name|element
operator|+
literal|"' that has a non-existant bytecode offset as its handler_pc ('"
operator|+
name|handlerpc
operator|+
literal|"')."
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * These are the checks if constraints are satisfied which are described in the      * Java Virtual Machine Specification, Second Edition as Static Constraints on      * the instructions of Java Virtual Machine Code (chapter 4.8.1).      *      * @throws StaticCodeConstraintException if the verification fails.      */
specifier|private
name|void
name|pass3StaticInstructionChecks
parameter_list|()
block|{
comment|// Code array must not be empty:
comment|// Enforced in pass 2 (also stated in the static constraints of the Code
comment|// array in vmspec2), together with pass 1 (reading code_length bytes and
comment|// interpreting them as code[]). So this must not be checked again here.
if|if
condition|(
name|code
operator|.
name|getCode
argument_list|()
operator|.
name|length
operator|>=
name|Const
operator|.
name|MAX_CODE_SIZE
condition|)
block|{
comment|// length must be LESS than the max
throw|throw
operator|new
name|StaticCodeInstructionConstraintException
argument_list|(
literal|"Code array in code attribute '"
operator|+
name|code
operator|+
literal|"' too big: must be smaller than "
operator|+
name|Const
operator|.
name|MAX_CODE_SIZE
operator|+
literal|"65536 bytes."
argument_list|)
throw|;
block|}
comment|// First opcode at offset 0: okay, that's clear. Nothing to do.
comment|// Only instances of the instructions documented in Section 6.4 may appear in
comment|// the code array.
comment|// For BCEL's sake, we cannot handle WIDE stuff, but hopefully BCEL does its job right :)
comment|// The last byte of the last instruction in the code array must be the byte at index
comment|// code_length-1 : See the do_verify() comments. We actually don't iterate through the
comment|// byte array, but use an InstructionList so we cannot check for this. But BCEL does
comment|// things right, so it's implicitly okay.
comment|// TODO: Check how BCEL handles (and will handle) instructions like IMPDEP1, IMPDEP2,
comment|//       BREAKPOINT... that BCEL knows about but which are illegal anyway.
comment|//       We currently go the safe way here.
name|InstructionHandle
name|ih
init|=
name|instructionList
operator|.
name|getStart
argument_list|()
decl_stmt|;
while|while
condition|(
name|ih
operator|!=
literal|null
condition|)
block|{
name|Instruction
name|i
init|=
name|ih
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|instanceof
name|IMPDEP1
condition|)
block|{
throw|throw
operator|new
name|StaticCodeInstructionConstraintException
argument_list|(
literal|"IMPDEP1 must not be in the code, it is an illegal instruction for _internal_ JVM use!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|i
operator|instanceof
name|IMPDEP2
condition|)
block|{
throw|throw
operator|new
name|StaticCodeInstructionConstraintException
argument_list|(
literal|"IMPDEP2 must not be in the code, it is an illegal instruction for _internal_ JVM use!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|i
operator|instanceof
name|BREAKPOINT
condition|)
block|{
throw|throw
operator|new
name|StaticCodeInstructionConstraintException
argument_list|(
literal|"BREAKPOINT must not be in the code, it is an illegal instruction for _internal_ JVM use!"
argument_list|)
throw|;
block|}
name|ih
operator|=
name|ih
operator|.
name|getNext
argument_list|()
expr_stmt|;
block|}
comment|// The original verifier seems to do this check here, too.
comment|// An unreachable last instruction may also not fall through the
comment|// end of the code, which is stupid -- but with the original
comment|// verifier's subroutine semantics one cannot predict reachability.
name|Instruction
name|last
init|=
name|instructionList
operator|.
name|getEnd
argument_list|()
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|last
operator|instanceof
name|ReturnInstruction
operator|)
operator|||
operator|(
name|last
operator|instanceof
name|RET
operator|)
operator|||
operator|(
name|last
operator|instanceof
name|GotoInstruction
operator|)
operator|||
operator|(
name|last
operator|instanceof
name|ATHROW
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|StaticCodeInstructionConstraintException
argument_list|(
literal|"Execution must not fall off the bottom of the code array."
operator|+
literal|" This constraint is enforced statically as some existing verifiers do"
operator|+
literal|" - so it may be a false alarm if the last instruction is not reachable."
argument_list|)
throw|;
block|}
block|}
comment|/**      * These are the checks for the satisfaction of constraints which are described in the      * Java Virtual Machine Specification, Second Edition as Static Constraints on      * the operands of instructions of Java Virtual Machine Code (chapter 4.8.1).      * BCEL parses the code array to create an InstructionList and therefore has to check      * some of these constraints. Additional checks are also implemented here.      *      * @throws StaticCodeConstraintException if the verification fails.      */
specifier|private
name|void
name|pass3StaticInstructionOperandsChecks
parameter_list|()
block|{
try|try
block|{
comment|// When building up the InstructionList, BCEL has already done all those checks
comment|// mentioned in The Java Virtual Machine Specification, Second Edition, as
comment|// "static constraints on the operands of instructions in the code array".
comment|// TODO: see the do_verify() comments. Maybe we should really work on the
comment|//       byte array first to give more comprehensive messages.
comment|// TODO: Review Exception API, possibly build in some "offending instruction" thing
comment|//       when we're ready to insulate the offending instruction by doing the
comment|//       above thing.
comment|// TODO: Implement as much as possible here. BCEL does _not_ check everything.
name|ConstantPoolGen
name|cpg
init|=
operator|new
name|ConstantPoolGen
argument_list|(
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|getConstantPool
argument_list|()
argument_list|)
decl_stmt|;
name|InstOperandConstraintVisitor
name|v
init|=
operator|new
name|InstOperandConstraintVisitor
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
comment|// Checks for the things BCEL does _not_ handle itself.
name|InstructionHandle
name|ih
init|=
name|instructionList
operator|.
name|getStart
argument_list|()
decl_stmt|;
while|while
condition|(
name|ih
operator|!=
literal|null
condition|)
block|{
name|Instruction
name|i
init|=
name|ih
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
comment|// An "own" constraint, due to JustIce's new definition of what "subroutine" means.
if|if
condition|(
name|i
operator|instanceof
name|JsrInstruction
condition|)
block|{
name|InstructionHandle
name|target
init|=
operator|(
operator|(
name|JsrInstruction
operator|)
name|i
operator|)
operator|.
name|getTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|instructionList
operator|.
name|getStart
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|StaticCodeInstructionOperandConstraintException
argument_list|(
literal|"Due to JustIce's clear definition of subroutines, no JSR or JSR_W may have a top-level instruction"
operator|+
literal|" (such as the very first instruction, which is targeted by instruction '"
operator|+
name|ih
operator|+
literal|"' as its target."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|target
operator|.
name|getInstruction
argument_list|()
operator|instanceof
name|ASTORE
operator|)
condition|)
block|{
throw|throw
operator|new
name|StaticCodeInstructionOperandConstraintException
argument_list|(
literal|"Due to JustIce's clear definition of subroutines, no JSR or JSR_W may target anything else"
operator|+
literal|" than an ASTORE instruction. Instruction '"
operator|+
name|ih
operator|+
literal|"' targets '"
operator|+
name|target
operator|+
literal|"'."
argument_list|)
throw|;
block|}
block|}
comment|// vmspec2, page 134-137
name|ih
operator|.
name|accept
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|ih
operator|=
name|ih
operator|.
name|getNext
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: maybe not the best way to handle this
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** A small utility method returning if a given int i is in the given int[] ints. */
specifier|private
specifier|static
name|boolean
name|contains
parameter_list|(
specifier|final
name|int
index|[]
name|ints
parameter_list|,
specifier|final
name|int
name|i
parameter_list|)
block|{
for|for
control|(
name|int
name|k
range|:
name|ints
control|)
block|{
if|if
condition|(
name|k
operator|==
name|i
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Returns the method number as supplied when instantiating. */
specifier|public
name|int
name|getMethodNo
parameter_list|()
block|{
return|return
name|method_no
return|;
block|}
comment|/**      * This visitor class does the actual checking for the instruction      * operand's constraints.      */
specifier|private
class|class
name|InstOperandConstraintVisitor
extends|extends
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|EmptyVisitor
block|{
comment|/** The ConstantPoolGen instance this Visitor operates on. */
specifier|private
specifier|final
name|ConstantPoolGen
name|cpg
decl_stmt|;
comment|/** The only Constructor. */
name|InstOperandConstraintVisitor
parameter_list|(
specifier|final
name|ConstantPoolGen
name|cpg
parameter_list|)
block|{
name|this
operator|.
name|cpg
operator|=
name|cpg
expr_stmt|;
block|}
comment|/**          * Utility method to return the max_locals value of the method verified          * by the surrounding Pass3aVerifier instance.          */
specifier|private
name|int
name|max_locals
parameter_list|()
block|{
try|try
block|{
return|return
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|getMethods
argument_list|()
index|[
name|method_no
index|]
operator|.
name|getCode
argument_list|()
operator|.
name|getMaxLocals
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: maybe not the best way to handle this
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**          * A utility method to always raise an exeption.          */
specifier|private
name|void
name|constraintViolated
parameter_list|(
specifier|final
name|Instruction
name|i
parameter_list|,
specifier|final
name|String
name|message
parameter_list|)
block|{
throw|throw
operator|new
name|StaticCodeInstructionOperandConstraintException
argument_list|(
literal|"Instruction "
operator|+
name|i
operator|+
literal|" constraint violated: "
operator|+
name|message
argument_list|)
throw|;
block|}
comment|/**          * A utility method to raise an exception if the index is not          * a valid constant pool index.          */
specifier|private
name|void
name|indexValid
parameter_list|(
specifier|final
name|Instruction
name|i
parameter_list|,
specifier|final
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|cpg
operator|.
name|getSize
argument_list|()
condition|)
block|{
name|constraintViolated
argument_list|(
name|i
argument_list|,
literal|"Illegal constant pool index '"
operator|+
name|idx
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
comment|///////////////////////////////////////////////////////////
comment|// The Java Virtual Machine Specification, pages 134-137 //
comment|///////////////////////////////////////////////////////////
comment|/**          * Assures the generic preconditions of a LoadClass instance.          * The referenced class is loaded and pass2-verified.          */
annotation|@
name|Override
specifier|public
name|void
name|visitLoadClass
parameter_list|(
specifier|final
name|LoadClass
name|o
parameter_list|)
block|{
name|ObjectType
name|t
init|=
name|o
operator|.
name|getLoadClassType
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
comment|// null means "no class is loaded"
name|Verifier
name|v
init|=
name|VerifierFactory
operator|.
name|getVerifier
argument_list|(
name|t
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|VerificationResult
name|vr
init|=
name|v
operator|.
name|doPass1
argument_list|()
decl_stmt|;
if|if
condition|(
name|vr
operator|.
name|getStatus
argument_list|()
operator|!=
name|VerificationResult
operator|.
name|VERIFIED_OK
condition|)
block|{
name|constraintViolated
argument_list|(
operator|(
name|Instruction
operator|)
name|o
argument_list|,
literal|"Class '"
operator|+
name|o
operator|.
name|getLoadClassType
argument_list|(
name|cpg
argument_list|)
operator|.
name|getClassName
argument_list|()
operator|+
literal|"' is referenced, but cannot be loaded: '"
operator|+
name|vr
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// The target of each jump and branch instruction [...] must be the opcode [...]
comment|// BCEL _DOES_ handle this.
comment|// tableswitch: BCEL will do it, supposedly.
comment|// lookupswitch: BCEL will do it, supposedly.
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
comment|// LDC and LDC_W (LDC_W is a subclass of LDC in BCEL's model)
annotation|@
name|Override
specifier|public
name|void
name|visitLDC
parameter_list|(
specifier|final
name|LDC
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|instanceof
name|ConstantClass
condition|)
block|{
name|addMessage
argument_list|(
literal|"Operand of LDC or LDC_W is CONSTANT_Class '"
operator|+
name|c
operator|+
literal|"' - this is only supported in JDK 1.5 and higher."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|c
operator|instanceof
name|ConstantInteger
operator|)
operator|||
operator|(
name|c
operator|instanceof
name|ConstantFloat
operator|)
operator|||
operator|(
name|c
operator|instanceof
name|ConstantString
operator|)
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Operand of LDC or LDC_W must be one of CONSTANT_Integer, CONSTANT_Float or CONSTANT_String, but is '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
comment|// LDC2_W
annotation|@
name|Override
specifier|public
name|void
name|visitLDC2_W
parameter_list|(
specifier|final
name|LDC2_W
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|c
operator|instanceof
name|ConstantLong
operator|)
operator|||
operator|(
name|c
operator|instanceof
name|ConstantDouble
operator|)
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Operand of LDC2_W must be CONSTANT_Long or CONSTANT_Double, but is '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StaticCodeInstructionOperandConstraintException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"OOPS: Does not BCEL handle that? LDC2_W operand has a problem."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|ObjectType
name|getObjectType
parameter_list|(
specifier|final
name|FieldInstruction
name|o
parameter_list|)
block|{
name|ReferenceType
name|rt
init|=
name|o
operator|.
name|getReferenceType
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
if|if
condition|(
name|rt
operator|instanceof
name|ObjectType
condition|)
block|{
return|return
operator|(
name|ObjectType
operator|)
name|rt
return|;
block|}
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"expecting ObjectType but got "
operator|+
name|rt
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
comment|//getfield, putfield, getstatic, putstatic
annotation|@
name|Override
specifier|public
name|void
name|visitFieldInstruction
parameter_list|(
specifier|final
name|FieldInstruction
name|o
parameter_list|)
block|{
try|try
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantFieldref
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Indexing a constant that's not a CONSTANT_Fieldref but a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
name|String
name|field_name
init|=
name|o
operator|.
name|getFieldName
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|getObjectType
argument_list|(
name|o
argument_list|)
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|Field
index|[]
name|fields
init|=
name|jc
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|Field
name|f
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Field
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|field
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|field_name
argument_list|)
condition|)
block|{
name|Type
name|f_type
init|=
name|Type
operator|.
name|getType
argument_list|(
name|field
operator|.
name|getSignature
argument_list|()
argument_list|)
decl_stmt|;
name|Type
name|o_type
init|=
name|o
operator|.
name|getType
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
comment|/* TODO: Check if assignment compatibility is sufficient.                    * What does Sun do?                    */
if|if
condition|(
name|f_type
operator|.
name|equals
argument_list|(
name|o_type
argument_list|)
condition|)
block|{
name|f
operator|=
name|field
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
name|JavaClass
index|[]
name|superclasses
init|=
name|jc
operator|.
name|getSuperClasses
argument_list|()
decl_stmt|;
name|outer
label|:
for|for
control|(
name|JavaClass
name|superclass
range|:
name|superclasses
control|)
block|{
name|fields
operator|=
name|superclass
operator|.
name|getFields
argument_list|()
expr_stmt|;
for|for
control|(
name|Field
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|field
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|field_name
argument_list|)
condition|)
block|{
name|Type
name|f_type
init|=
name|Type
operator|.
name|getType
argument_list|(
name|field
operator|.
name|getSignature
argument_list|()
argument_list|)
decl_stmt|;
name|Type
name|o_type
init|=
name|o
operator|.
name|getType
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
if|if
condition|(
name|f_type
operator|.
name|equals
argument_list|(
name|o_type
argument_list|)
condition|)
block|{
name|f
operator|=
name|field
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|.
name|getAccessFlags
argument_list|()
operator|&
operator|(
name|Const
operator|.
name|ACC_PUBLIC
operator||
name|Const
operator|.
name|ACC_PROTECTED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|f
operator|=
literal|null
expr_stmt|;
block|}
break|break
name|outer
break|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced field '"
operator|+
name|field_name
operator|+
literal|"' does not exist in class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* TODO: Check if assignment compatibility is sufficient.                    What does Sun do? */
name|Type
operator|.
name|getType
argument_list|(
name|f
operator|.
name|getSignature
argument_list|()
argument_list|)
expr_stmt|;
name|o
operator|.
name|getType
argument_list|(
name|cpg
argument_list|)
expr_stmt|;
comment|//                Type f_type = Type.getType(f.getSignature());
comment|//                Type o_type = o.getType(cpg);
comment|// Argh. Sun's implementation allows us to have multiple fields of
comment|// the same name but with a different signature.
comment|//if (! f_type.equals(o_type)) {
comment|//    constraintViolated(o,
comment|//        "Referenced field '"+field_name+"' has type '"+f_type+"' instead of '"+o_type+"' as expected.");
comment|//}
comment|/* TODO: Check for access modifiers here. */
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: maybe not the best way to handle this
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitInvokeInstruction
parameter_list|(
specifier|final
name|InvokeInstruction
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|instanceof
name|INVOKEVIRTUAL
operator|)
operator|||
operator|(
name|o
operator|instanceof
name|INVOKESPECIAL
operator|)
operator|||
operator|(
name|o
operator|instanceof
name|INVOKESTATIC
operator|)
condition|)
block|{
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantMethodref
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Indexing a constant that's not a CONSTANT_Methodref but a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Constants are okay due to pass2.
name|ConstantNameAndType
name|cnat
init|=
operator|(
name|ConstantNameAndType
operator|)
operator|(
name|cpg
operator|.
name|getConstant
argument_list|(
operator|(
operator|(
name|ConstantMethodref
operator|)
name|c
operator|)
operator|.
name|getNameAndTypeIndex
argument_list|()
argument_list|)
operator|)
decl_stmt|;
name|ConstantUtf8
name|cutf8
init|=
operator|(
name|ConstantUtf8
operator|)
operator|(
name|cpg
operator|.
name|getConstant
argument_list|(
name|cnat
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|cutf8
operator|.
name|getBytes
argument_list|()
operator|.
name|equals
argument_list|(
name|Const
operator|.
name|CONSTRUCTOR_NAME
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|o
operator|instanceof
name|INVOKESPECIAL
operator|)
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Only INVOKESPECIAL is allowed to invoke instance initialization methods."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
operator|(
name|cutf8
operator|.
name|getBytes
argument_list|()
operator|.
name|equals
argument_list|(
name|Const
operator|.
name|CONSTRUCTOR_NAME
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|cutf8
operator|.
name|getBytes
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"<"
argument_list|)
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"No method with a name beginning with '<' other than the instance initialization methods"
operator|+
literal|" may be called by the method invocation instructions."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|//if (o instanceof INVOKEINTERFACE) {
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantInterfaceMethodref
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Indexing a constant that's not a CONSTANT_InterfaceMethodref but a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
comment|// TODO: From time to time check if BCEL allows to detect if the
comment|// 'count' operand is consistent with the information in the
comment|// CONSTANT_InterfaceMethodref and if the last operand is zero.
comment|// By now, BCEL hides those two operands because they're superfluous.
comment|// Invoked method must not be<init> or<clinit>
name|ConstantNameAndType
name|cnat
init|=
operator|(
name|ConstantNameAndType
operator|)
operator|(
name|cpg
operator|.
name|getConstant
argument_list|(
operator|(
operator|(
name|ConstantInterfaceMethodref
operator|)
name|c
operator|)
operator|.
name|getNameAndTypeIndex
argument_list|()
argument_list|)
operator|)
decl_stmt|;
name|String
name|name
init|=
operator|(
operator|(
name|ConstantUtf8
operator|)
operator|(
name|cpg
operator|.
name|getConstant
argument_list|(
name|cnat
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
operator|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|Const
operator|.
name|CONSTRUCTOR_NAME
argument_list|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Method to invoke must not be '"
operator|+
name|Const
operator|.
name|CONSTRUCTOR_NAME
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|Const
operator|.
name|STATIC_INITIALIZER_NAME
argument_list|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Method to invoke must not be '"
operator|+
name|Const
operator|.
name|STATIC_INITIALIZER_NAME
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// The LoadClassType is the method-declaring class, so we have to check the other types.
name|Type
name|t
init|=
name|o
operator|.
name|getReturnType
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
block|{
name|t
operator|=
operator|(
operator|(
name|ArrayType
operator|)
name|t
operator|)
operator|.
name|getBasicType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|instanceof
name|ObjectType
condition|)
block|{
name|Verifier
name|v
init|=
name|VerifierFactory
operator|.
name|getVerifier
argument_list|(
operator|(
operator|(
name|ObjectType
operator|)
name|t
operator|)
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|VerificationResult
name|vr
init|=
name|v
operator|.
name|doPass2
argument_list|()
decl_stmt|;
if|if
condition|(
name|vr
operator|.
name|getStatus
argument_list|()
operator|!=
name|VerificationResult
operator|.
name|VERIFIED_OK
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Return type class/interface could not be verified successfully: '"
operator|+
name|vr
operator|.
name|getMessage
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
name|Type
index|[]
name|ts
init|=
name|o
operator|.
name|getArgumentTypes
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
for|for
control|(
name|Type
name|element
range|:
name|ts
control|)
block|{
name|t
operator|=
name|element
expr_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
block|{
name|t
operator|=
operator|(
operator|(
name|ArrayType
operator|)
name|t
operator|)
operator|.
name|getBasicType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|instanceof
name|ObjectType
condition|)
block|{
name|Verifier
name|v
init|=
name|VerifierFactory
operator|.
name|getVerifier
argument_list|(
operator|(
operator|(
name|ObjectType
operator|)
name|t
operator|)
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|VerificationResult
name|vr
init|=
name|v
operator|.
name|doPass2
argument_list|()
decl_stmt|;
if|if
condition|(
name|vr
operator|.
name|getStatus
argument_list|()
operator|!=
name|VerificationResult
operator|.
name|VERIFIED_OK
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Argument type class/interface could not be verified successfully: '"
operator|+
name|vr
operator|.
name|getMessage
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitINSTANCEOF
parameter_list|(
specifier|final
name|INSTANCEOF
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantClass
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Expecting a CONSTANT_Class operand, but found a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitCHECKCAST
parameter_list|(
specifier|final
name|CHECKCAST
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantClass
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Expecting a CONSTANT_Class operand, but found a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitNEW
parameter_list|(
specifier|final
name|NEW
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantClass
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Expecting a CONSTANT_Class operand, but found a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ConstantUtf8
name|cutf8
init|=
operator|(
name|ConstantUtf8
operator|)
operator|(
name|cpg
operator|.
name|getConstant
argument_list|(
operator|(
operator|(
name|ConstantClass
operator|)
name|c
operator|)
operator|.
name|getNameIndex
argument_list|()
argument_list|)
operator|)
decl_stmt|;
name|Type
name|t
init|=
name|Type
operator|.
name|getType
argument_list|(
literal|"L"
operator|+
name|cutf8
operator|.
name|getBytes
argument_list|()
operator|+
literal|";"
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"NEW must not be used to create an array."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitMULTIANEWARRAY
parameter_list|(
specifier|final
name|MULTIANEWARRAY
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantClass
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Expecting a CONSTANT_Class operand, but found a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
name|int
name|dimensions2create
init|=
name|o
operator|.
name|getDimensions
argument_list|()
decl_stmt|;
if|if
condition|(
name|dimensions2create
operator|<
literal|1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Number of dimensions to create must be greater than zero."
argument_list|)
expr_stmt|;
block|}
name|Type
name|t
init|=
name|o
operator|.
name|getType
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
block|{
name|int
name|dimensions
init|=
operator|(
operator|(
name|ArrayType
operator|)
name|t
operator|)
operator|.
name|getDimensions
argument_list|()
decl_stmt|;
if|if
condition|(
name|dimensions
operator|<
name|dimensions2create
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Not allowed to create array with more dimensions ('"
operator|+
name|dimensions2create
operator|+
literal|"') than the one referenced by the CONSTANT_Class '"
operator|+
name|t
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Expecting a CONSTANT_Class referencing an array type."
operator|+
literal|" [Constraint not found in The Java Virtual Machine Specification, Second Edition, 4.8.1]"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitANEWARRAY
parameter_list|(
specifier|final
name|ANEWARRAY
name|o
parameter_list|)
block|{
name|indexValid
argument_list|(
name|o
argument_list|,
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Constant
name|c
init|=
name|cpg
operator|.
name|getConstant
argument_list|(
name|o
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|instanceof
name|ConstantClass
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Expecting a CONSTANT_Class operand, but found a '"
operator|+
name|c
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
name|Type
name|t
init|=
name|o
operator|.
name|getType
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
block|{
name|int
name|dimensions
init|=
operator|(
operator|(
name|ArrayType
operator|)
name|t
operator|)
operator|.
name|getDimensions
argument_list|()
decl_stmt|;
if|if
condition|(
name|dimensions
operator|>
name|Const
operator|.
name|MAX_ARRAY_DIMENSIONS
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Not allowed to create an array with more than "
operator|+
name|Const
operator|.
name|MAX_ARRAY_DIMENSIONS
operator|+
literal|" dimensions;"
operator|+
literal|" actual: "
operator|+
name|dimensions
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitNEWARRAY
parameter_list|(
specifier|final
name|NEWARRAY
name|o
parameter_list|)
block|{
name|byte
name|t
init|=
name|o
operator|.
name|getTypecode
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|t
operator|==
name|Const
operator|.
name|T_BOOLEAN
operator|)
operator|||
operator|(
name|t
operator|==
name|Const
operator|.
name|T_CHAR
operator|)
operator|||
operator|(
name|t
operator|==
name|Const
operator|.
name|T_FLOAT
operator|)
operator|||
operator|(
name|t
operator|==
name|Const
operator|.
name|T_DOUBLE
operator|)
operator|||
operator|(
name|t
operator|==
name|Const
operator|.
name|T_BYTE
operator|)
operator|||
operator|(
name|t
operator|==
name|Const
operator|.
name|T_SHORT
operator|)
operator|||
operator|(
name|t
operator|==
name|Const
operator|.
name|T_INT
operator|)
operator|||
operator|(
name|t
operator|==
name|Const
operator|.
name|T_LONG
operator|)
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Illegal type code '+t+' for 'atype' operand."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitILOAD
parameter_list|(
specifier|final
name|ILOAD
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitFLOAD
parameter_list|(
specifier|final
name|FLOAD
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitALOAD
parameter_list|(
specifier|final
name|ALOAD
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitISTORE
parameter_list|(
specifier|final
name|ISTORE
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitFSTORE
parameter_list|(
specifier|final
name|FSTORE
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitASTORE
parameter_list|(
specifier|final
name|ASTORE
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitIINC
parameter_list|(
specifier|final
name|IINC
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitRET
parameter_list|(
specifier|final
name|RET
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus1
init|=
name|max_locals
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus1
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-1 '"
operator|+
name|maxminus1
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitLLOAD
parameter_list|(
specifier|final
name|LLOAD
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
operator|+
literal|" [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus2
init|=
name|max_locals
argument_list|()
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus2
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-2 '"
operator|+
name|maxminus2
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitDLOAD
parameter_list|(
specifier|final
name|DLOAD
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
operator|+
literal|" [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus2
init|=
name|max_locals
argument_list|()
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus2
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-2 '"
operator|+
name|maxminus2
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitLSTORE
parameter_list|(
specifier|final
name|LSTORE
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
operator|+
literal|" [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus2
init|=
name|max_locals
argument_list|()
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus2
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-2 '"
operator|+
name|maxminus2
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitDSTORE
parameter_list|(
specifier|final
name|DSTORE
name|o
parameter_list|)
block|{
name|int
name|idx
init|=
name|o
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must be non-negative."
operator|+
literal|" [Constraint by JustIce as an analogon to the single-slot xLOAD/xSTORE instructions; may not happen anyway.]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|maxminus2
init|=
name|max_locals
argument_list|()
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|idx
operator|>
name|maxminus2
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Index '"
operator|+
name|idx
operator|+
literal|"' must not be greater than max_locals-2 '"
operator|+
name|maxminus2
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitLOOKUPSWITCH
parameter_list|(
specifier|final
name|LOOKUPSWITCH
name|o
parameter_list|)
block|{
name|int
index|[]
name|matchs
init|=
name|o
operator|.
name|getMatchs
argument_list|()
decl_stmt|;
name|int
name|max
init|=
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|matchs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|matchs
index|[
name|i
index|]
operator|==
name|max
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Match '"
operator|+
name|matchs
index|[
name|i
index|]
operator|+
literal|"' occurs more than once."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|matchs
index|[
name|i
index|]
operator|<
name|max
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Lookup table must be sorted but isn't."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
name|matchs
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitTABLESWITCH
parameter_list|(
specifier|final
name|TABLESWITCH
name|o
parameter_list|)
block|{
comment|// "high" must be>= "low". We cannot check this, as BCEL hides
comment|// it from us.
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitPUTSTATIC
parameter_list|(
specifier|final
name|PUTSTATIC
name|o
parameter_list|)
block|{
try|try
block|{
name|String
name|field_name
init|=
name|o
operator|.
name|getFieldName
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|getObjectType
argument_list|(
name|o
argument_list|)
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|Field
index|[]
name|fields
init|=
name|jc
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|Field
name|f
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Field
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|field
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|field_name
argument_list|)
condition|)
block|{
name|f
operator|=
name|field
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Field '"
operator|+
name|field_name
operator|+
literal|"' not found in "
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|f
operator|.
name|isFinal
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|myOwner
operator|.
name|getClassName
argument_list|()
operator|.
name|equals
argument_list|(
name|getObjectType
argument_list|(
name|o
argument_list|)
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced field '"
operator|+
name|f
operator|+
literal|"' is final and must therefore be declared in the current class '"
operator|+
name|myOwner
operator|.
name|getClassName
argument_list|()
operator|+
literal|"' which is not the case: it is declared in '"
operator|+
name|o
operator|.
name|getReferenceType
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|f
operator|.
name|isStatic
argument_list|()
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced field '"
operator|+
name|f
operator|+
literal|"' is not static which it should be."
argument_list|)
expr_stmt|;
block|}
name|String
name|meth_name
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|getMethods
argument_list|()
index|[
name|method_no
index|]
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// If it's an interface, it can be set only in<clinit>.
if|if
condition|(
operator|(
operator|!
operator|(
name|jc
operator|.
name|isClass
argument_list|()
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|meth_name
operator|.
name|equals
argument_list|(
name|Const
operator|.
name|STATIC_INITIALIZER_NAME
argument_list|)
operator|)
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Interface field '"
operator|+
name|f
operator|+
literal|"' must be set in a '"
operator|+
name|Const
operator|.
name|STATIC_INITIALIZER_NAME
operator|+
literal|"' method."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: maybe not the best way to handle this
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitGETSTATIC
parameter_list|(
specifier|final
name|GETSTATIC
name|o
parameter_list|)
block|{
try|try
block|{
name|String
name|field_name
init|=
name|o
operator|.
name|getFieldName
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|getObjectType
argument_list|(
name|o
argument_list|)
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
name|Field
index|[]
name|fields
init|=
name|jc
operator|.
name|getFields
argument_list|()
decl_stmt|;
name|Field
name|f
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Field
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|field
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|field_name
argument_list|)
condition|)
block|{
name|f
operator|=
name|field
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Field '"
operator|+
name|field_name
operator|+
literal|"' not found in "
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|f
operator|.
name|isStatic
argument_list|()
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced field '"
operator|+
name|f
operator|+
literal|"' is not static which it should be."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: maybe not the best way to handle this
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/* Checks if the constraints of operands of the said instruction(s) are satisfied. */
comment|//public void visitPUTFIELD(PUTFIELD o) {
comment|// for performance reasons done in Pass 3b
comment|//}
comment|/* Checks if the constraints of operands of the said instruction(s) are satisfied. */
comment|//public void visitGETFIELD(GETFIELD o) {
comment|// for performance reasons done in Pass 3b
comment|//}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitINVOKEDYNAMIC
parameter_list|(
specifier|final
name|INVOKEDYNAMIC
name|o
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"INVOKEDYNAMIC instruction is not supported at this time"
argument_list|)
throw|;
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitINVOKEINTERFACE
parameter_list|(
specifier|final
name|INVOKEINTERFACE
name|o
parameter_list|)
block|{
try|try
block|{
comment|// INVOKEINTERFACE is a LoadClass; the Class where the referenced method is declared in,
comment|// is therefore resolved/verified.
comment|// INVOKEINTERFACE is an InvokeInstruction, the argument and return types are resolved/verified,
comment|// too. So are the allowed method names.
name|String
name|classname
init|=
name|o
operator|.
name|getClassName
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|classname
argument_list|)
decl_stmt|;
name|Method
name|m
init|=
name|getMethodRecursive
argument_list|(
name|jc
argument_list|,
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced method '"
operator|+
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' with expected signature '"
operator|+
name|o
operator|.
name|getSignature
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' not found in class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|jc
operator|.
name|isClass
argument_list|()
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"' is a class, but not an interface as expected."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: maybe not the best way to handle this
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**          * Looks for the method referenced by the given invoke instruction in the given class          * or its super classes and super interfaces.          * @param jc the class that defines the referenced method          * @param invoke the instruction that references the method          * @return the referenced method or null if not found.          */
specifier|private
name|Method
name|getMethodRecursive
parameter_list|(
specifier|final
name|JavaClass
name|jc
parameter_list|,
specifier|final
name|InvokeInstruction
name|invoke
parameter_list|)
throws|throws
name|ClassNotFoundException
block|{
name|Method
name|m
decl_stmt|;
comment|//look in the given class
name|m
operator|=
name|getMethod
argument_list|(
name|jc
argument_list|,
name|invoke
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
literal|null
condition|)
block|{
comment|//method found in given class
return|return
name|m
return|;
block|}
comment|//method not found, look in super classes
for|for
control|(
name|JavaClass
name|superclass
range|:
name|jc
operator|.
name|getSuperClasses
argument_list|()
control|)
block|{
name|m
operator|=
name|getMethod
argument_list|(
name|superclass
argument_list|,
name|invoke
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
literal|null
condition|)
block|{
comment|//method found in super class
return|return
name|m
return|;
block|}
block|}
comment|//method not found, look in super interfaces
for|for
control|(
name|JavaClass
name|superclass
range|:
name|jc
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
name|m
operator|=
name|getMethod
argument_list|(
name|superclass
argument_list|,
name|invoke
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
literal|null
condition|)
block|{
comment|//method found in super interface
return|return
name|m
return|;
block|}
block|}
comment|//method not found in the hierarchy
return|return
literal|null
return|;
block|}
comment|/**          * Looks for the method referenced by the given invoke instruction in the given class.          * @param jc the class that defines the referenced method          * @param invoke the instruction that references the method          * @return the referenced method or null if not found.          */
specifier|private
name|Method
name|getMethod
parameter_list|(
specifier|final
name|JavaClass
name|jc
parameter_list|,
specifier|final
name|InvokeInstruction
name|invoke
parameter_list|)
block|{
name|Method
index|[]
name|ms
init|=
name|jc
operator|.
name|getMethods
argument_list|()
decl_stmt|;
for|for
control|(
name|Method
name|element
range|:
name|ms
control|)
block|{
if|if
condition|(
operator|(
name|element
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|invoke
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|Type
operator|.
name|getReturnType
argument_list|(
name|element
operator|.
name|getSignature
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|invoke
operator|.
name|getReturnType
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|objarrayequals
argument_list|(
name|Type
operator|.
name|getArgumentTypes
argument_list|(
name|element
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|invoke
operator|.
name|getArgumentTypes
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
name|element
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitINVOKESPECIAL
parameter_list|(
specifier|final
name|INVOKESPECIAL
name|o
parameter_list|)
block|{
try|try
block|{
comment|// INVOKESPECIAL is a LoadClass; the Class where the referenced method is declared in,
comment|// is therefore resolved/verified.
comment|// INVOKESPECIAL is an InvokeInstruction, the argument and return types are resolved/verified,
comment|// too. So are the allowed method names.
name|String
name|classname
init|=
name|o
operator|.
name|getClassName
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|classname
argument_list|)
decl_stmt|;
name|Method
name|m
init|=
name|getMethodRecursive
argument_list|(
name|jc
argument_list|,
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced method '"
operator|+
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' with expected signature '"
operator|+
name|o
operator|.
name|getSignature
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' not found in class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
name|JavaClass
name|current
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|myOwner
operator|.
name|getClassName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|.
name|isSuper
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|Repository
operator|.
name|instanceOf
argument_list|(
name|current
argument_list|,
name|jc
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|current
operator|.
name|equals
argument_list|(
name|jc
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
operator|.
name|equals
argument_list|(
name|Const
operator|.
name|CONSTRUCTOR_NAME
argument_list|)
operator|)
condition|)
block|{
comment|// Special lookup procedure for ACC_SUPER classes.
name|int
name|supidx
init|=
operator|-
literal|1
decl_stmt|;
name|Method
name|meth
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|supidx
operator|!=
literal|0
condition|)
block|{
name|supidx
operator|=
name|current
operator|.
name|getSuperclassNameIndex
argument_list|()
expr_stmt|;
name|current
operator|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|current
operator|.
name|getSuperclassName
argument_list|()
argument_list|)
expr_stmt|;
name|Method
index|[]
name|meths
init|=
name|current
operator|.
name|getMethods
argument_list|()
decl_stmt|;
for|for
control|(
name|Method
name|meth2
range|:
name|meths
control|)
block|{
if|if
condition|(
operator|(
name|meth2
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|Type
operator|.
name|getReturnType
argument_list|(
name|meth2
operator|.
name|getSignature
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|o
operator|.
name|getReturnType
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|objarrayequals
argument_list|(
name|Type
operator|.
name|getArgumentTypes
argument_list|(
name|meth2
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|o
operator|.
name|getArgumentTypes
argument_list|(
name|cpg
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|meth
operator|=
name|meth2
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|meth
operator|!=
literal|null
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|meth
operator|==
literal|null
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"ACC_SUPER special lookup procedure not successful: method '"
operator|+
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' with proper signature not declared in superclass hierarchy."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: maybe not the best way to handle this
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitINVOKESTATIC
parameter_list|(
specifier|final
name|INVOKESTATIC
name|o
parameter_list|)
block|{
try|try
block|{
comment|// INVOKESTATIC is a LoadClass; the Class where the referenced method is declared in,
comment|// is therefore resolved/verified.
comment|// INVOKESTATIC is an InvokeInstruction, the argument and return types are resolved/verified,
comment|// too. So are the allowed method names.
name|String
name|classname
init|=
name|o
operator|.
name|getClassName
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|classname
argument_list|)
decl_stmt|;
name|Method
name|m
init|=
name|getMethodRecursive
argument_list|(
name|jc
argument_list|,
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced method '"
operator|+
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' with expected signature '"
operator|+
name|o
operator|.
name|getSignature
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' not found in class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|!
operator|(
name|m
operator|.
name|isStatic
argument_list|()
operator|)
condition|)
block|{
comment|// implies it's not abstract, verified in pass 2.
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced method '"
operator|+
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' has ACC_STATIC unset."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: maybe not the best way to handle this
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Checks if the constraints of operands of the said instruction(s) are satisfied. */
annotation|@
name|Override
specifier|public
name|void
name|visitINVOKEVIRTUAL
parameter_list|(
specifier|final
name|INVOKEVIRTUAL
name|o
parameter_list|)
block|{
try|try
block|{
comment|// INVOKEVIRTUAL is a LoadClass; the Class where the referenced method is declared in,
comment|// is therefore resolved/verified.
comment|// INVOKEVIRTUAL is an InvokeInstruction, the argument and return types are resolved/verified,
comment|// too. So are the allowed method names.
name|String
name|classname
init|=
name|o
operator|.
name|getClassName
argument_list|(
name|cpg
argument_list|)
decl_stmt|;
name|JavaClass
name|jc
init|=
name|Repository
operator|.
name|lookupClass
argument_list|(
name|classname
argument_list|)
decl_stmt|;
name|Method
name|m
init|=
name|getMethodRecursive
argument_list|(
name|jc
argument_list|,
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced method '"
operator|+
name|o
operator|.
name|getMethodName
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' with expected signature '"
operator|+
name|o
operator|.
name|getSignature
argument_list|(
name|cpg
argument_list|)
operator|+
literal|"' not found in class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"'."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|jc
operator|.
name|isClass
argument_list|()
operator|)
condition|)
block|{
name|constraintViolated
argument_list|(
name|o
argument_list|,
literal|"Referenced class '"
operator|+
name|jc
operator|.
name|getClassName
argument_list|()
operator|+
literal|"' is an interface, but not a class as expected."
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// FIXME: maybe not the best way to handle this
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Missing class: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|// WIDE stuff is BCEL-internal and cannot be checked here.
comment|/**          * A utility method like equals(Object) for arrays.          * The equality of the elements is based on their equals(Object)          * method instead of their object identity.          */
specifier|private
name|boolean
name|objarrayequals
parameter_list|(
specifier|final
name|Object
index|[]
name|o
parameter_list|,
specifier|final
name|Object
index|[]
name|p
parameter_list|)
block|{
if|if
condition|(
name|o
operator|.
name|length
operator|!=
name|p
operator|.
name|length
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|o
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
end_class

end_unit

