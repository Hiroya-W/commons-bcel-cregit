begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright  2000-2004 The Apache Software Foundation  *  *  Licensed under the Apache License, Version 2.0 (the "License");   *  you may not use this file except in compliance with the License.  *  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.   *  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|structurals
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ASTORE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ATHROW
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|BranchInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|CodeExceptionGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|GotoInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|IndexedInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|Instruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|InstructionHandle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|JsrInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|LocalVariableInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|MethodGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|RET
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ReturnInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|Select
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|exc
operator|.
name|AssertionViolatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|exc
operator|.
name|StructuralCodeConstraintException
import|;
end_import

begin_comment
comment|/** 	 * Instances of this class contain information about the subroutines 	 * found in a code array of a method. 	 * This implementation considers the top-level (the instructions 	 * reachable without a JSR or JSR_W starting off from the first 	 * instruction in a code array of a method) being a special subroutine; 	 * see getTopLevel() for that. 	 * Please note that the definition of subroutines in the Java Virtual 	 * Machine Specification, Second Edition is somewhat incomplete. 	 * Therefore, JustIce uses an own, more rigid notion. 	 * Basically, a subroutine is a piece of code that starts at the target 	 * of a JSR of JSR_W instruction and ends at a corresponding RET 	 * instruction. Note also that the control flow of a subroutine 	 * may be complex and non-linear; and that subroutines may be nested. 	 * JustIce also mandates subroutines not to be protected by exception 	 * handling code (for the sake of control flow predictability). 	 * To understand JustIce's notion of subroutines, please read    * 	 * TODO: refer to the paper. 	 * 	 * @version $Id$ 	 * @author Enver Haase 	 * @see #getTopLevel() 	 */
end_comment

begin_class
specifier|public
class|class
name|Subroutines
block|{
comment|/** 	 * This inner class implements the Subroutine interface. 	 */
specifier|private
class|class
name|SubroutineImpl
implements|implements
name|Subroutine
block|{
comment|/** 		 * UNSET, a symbol for an uninitialized localVariable 		 * field. This is used for the "top-level" Subroutine; 		 * i.e. no subroutine. 		 */
specifier|private
specifier|static
specifier|final
name|int
name|UNSET
init|=
operator|-
literal|1
decl_stmt|;
comment|/** 		 * The Local Variable slot where the first 		 * instruction of this subroutine (an ASTORE) stores 		 * the JsrInstruction's ReturnAddress in and 		 * the RET of this subroutine operates on. 		 */
specifier|private
name|int
name|localVariable
init|=
name|UNSET
decl_stmt|;
comment|/** The instructions that belong to this subroutine. */
specifier|private
name|Set
name|instructions
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
comment|// Elements: InstructionHandle
comment|/* 		 * Refer to the Subroutine interface for documentation. 		 */
specifier|public
name|boolean
name|contains
parameter_list|(
name|InstructionHandle
name|inst
parameter_list|)
block|{
return|return
name|instructions
operator|.
name|contains
argument_list|(
name|inst
argument_list|)
return|;
block|}
comment|/** 		 * The JSR or JSR_W instructions that define this 		 * subroutine by targeting it. 		 */
specifier|private
name|Set
name|theJSRs
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
comment|/** 		 * The RET instruction that leaves this subroutine. 		 */
specifier|private
name|InstructionHandle
name|theRET
decl_stmt|;
comment|/** 		 * Returns a String representation of this object, merely 		 * for debugging purposes. 		 * (Internal) Warning: Verbosity on a problematic subroutine may cause 		 * stack overflow errors due to recursive subSubs() calls. 		 * Don't use this, then. 		 */
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|String
name|ret
init|=
literal|"Subroutine: Local variable is '"
operator|+
name|localVariable
operator|+
literal|"', JSRs are '"
operator|+
name|theJSRs
operator|+
literal|"', RET is '"
operator|+
name|theRET
operator|+
literal|"', Instructions: '"
operator|+
name|instructions
operator|.
name|toString
argument_list|()
operator|+
literal|"'."
decl_stmt|;
name|ret
operator|+=
literal|" Accessed local variable slots: '"
expr_stmt|;
name|int
index|[]
name|alv
init|=
name|getAccessedLocalsIndices
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alv
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|+=
name|alv
index|[
name|i
index|]
operator|+
literal|" "
expr_stmt|;
block|}
name|ret
operator|+=
literal|"'."
expr_stmt|;
name|ret
operator|+=
literal|" Recursively (via subsub...routines) accessed local variable slots: '"
expr_stmt|;
name|alv
operator|=
name|getRecursivelyAccessedLocalsIndices
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alv
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|+=
name|alv
index|[
name|i
index|]
operator|+
literal|" "
expr_stmt|;
block|}
name|ret
operator|+=
literal|"'."
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/** 		 * Sets the leaving RET instruction. Must be invoked after all instructions are added. 		 * Must not be invoked for top-level 'subroutine'. 		 */
name|void
name|setLeavingRET
parameter_list|()
block|{
if|if
condition|(
name|localVariable
operator|==
name|UNSET
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"setLeavingRET() called for top-level 'subroutine' or forgot to set local variable first."
argument_list|)
throw|;
block|}
name|Iterator
name|iter
init|=
name|instructions
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|InstructionHandle
name|ret
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|InstructionHandle
name|actual
init|=
operator|(
name|InstructionHandle
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|actual
operator|.
name|getInstruction
argument_list|()
operator|instanceof
name|RET
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|StructuralCodeConstraintException
argument_list|(
literal|"Subroutine with more then one RET detected: '"
operator|+
name|ret
operator|+
literal|"' and '"
operator|+
name|actual
operator|+
literal|"'."
argument_list|)
throw|;
block|}
else|else
block|{
name|ret
operator|=
name|actual
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|StructuralCodeConstraintException
argument_list|(
literal|"Subroutine without a RET detected."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
operator|(
name|RET
operator|)
name|ret
operator|.
name|getInstruction
argument_list|()
operator|)
operator|.
name|getIndex
argument_list|()
operator|!=
name|localVariable
condition|)
block|{
throw|throw
operator|new
name|StructuralCodeConstraintException
argument_list|(
literal|"Subroutine uses '"
operator|+
name|ret
operator|+
literal|"' which does not match the correct local variable '"
operator|+
name|localVariable
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|theRET
operator|=
name|ret
expr_stmt|;
block|}
comment|/* 		 * Refer to the Subroutine interface for documentation. 		 */
specifier|public
name|InstructionHandle
index|[]
name|getEnteringJsrInstructions
parameter_list|()
block|{
if|if
condition|(
name|this
operator|==
name|TOPLEVEL
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"getLeavingRET() called on top level pseudo-subroutine."
argument_list|)
throw|;
block|}
name|InstructionHandle
index|[]
name|jsrs
init|=
operator|new
name|InstructionHandle
index|[
name|theJSRs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
return|return
operator|(
name|InstructionHandle
index|[]
operator|)
operator|(
name|theJSRs
operator|.
name|toArray
argument_list|(
name|jsrs
argument_list|)
operator|)
return|;
block|}
comment|/** 		 * Adds a new JSR or JSR_W that has this subroutine as its target. 		 */
specifier|public
name|void
name|addEnteringJsrInstruction
parameter_list|(
name|InstructionHandle
name|jsrInst
parameter_list|)
block|{
if|if
condition|(
operator|(
name|jsrInst
operator|==
literal|null
operator|)
operator|||
operator|(
operator|!
operator|(
name|jsrInst
operator|.
name|getInstruction
argument_list|()
operator|instanceof
name|JsrInstruction
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Expecting JsrInstruction InstructionHandle."
argument_list|)
throw|;
block|}
if|if
condition|(
name|localVariable
operator|==
name|UNSET
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Set the localVariable first!"
argument_list|)
throw|;
block|}
else|else
block|{
comment|// Something is wrong when an ASTORE is targeted that does not operate on the same local variable than the rest of the
comment|// JsrInstruction-targets and the RET.
comment|// (We don't know out leader here so we cannot check if we're really targeted!)
if|if
condition|(
name|localVariable
operator|!=
operator|(
operator|(
name|ASTORE
operator|)
operator|(
operator|(
operator|(
name|JsrInstruction
operator|)
name|jsrInst
operator|.
name|getInstruction
argument_list|()
operator|)
operator|.
name|getTarget
argument_list|()
operator|.
name|getInstruction
argument_list|()
operator|)
operator|)
operator|.
name|getIndex
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Setting a wrong JsrInstruction."
argument_list|)
throw|;
block|}
block|}
name|theJSRs
operator|.
name|add
argument_list|(
name|jsrInst
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Refer to the Subroutine interface for documentation. 		 */
specifier|public
name|InstructionHandle
name|getLeavingRET
parameter_list|()
block|{
if|if
condition|(
name|this
operator|==
name|TOPLEVEL
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"getLeavingRET() called on top level pseudo-subroutine."
argument_list|)
throw|;
block|}
return|return
name|theRET
return|;
block|}
comment|/* 		 * Refer to the Subroutine interface for documentation. 		 */
specifier|public
name|InstructionHandle
index|[]
name|getInstructions
parameter_list|()
block|{
name|InstructionHandle
index|[]
name|ret
init|=
operator|new
name|InstructionHandle
index|[
name|instructions
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
return|return
operator|(
name|InstructionHandle
index|[]
operator|)
name|instructions
operator|.
name|toArray
argument_list|(
name|ret
argument_list|)
return|;
block|}
comment|/* 		 * Adds an instruction to this subroutine. 		 * All instructions must have been added before invoking setLeavingRET(). 		 * @see #setLeavingRET 		 */
name|void
name|addInstruction
parameter_list|(
name|InstructionHandle
name|ih
parameter_list|)
block|{
if|if
condition|(
name|theRET
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"All instructions must have been added before invoking setLeavingRET()."
argument_list|)
throw|;
block|}
name|instructions
operator|.
name|add
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
comment|/* Satisfies Subroutine.getRecursivelyAccessedLocalsIndices(). */
specifier|public
name|int
index|[]
name|getRecursivelyAccessedLocalsIndices
parameter_list|()
block|{
name|Set
name|s
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
name|int
index|[]
name|lvs
init|=
name|getAccessedLocalsIndices
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|lvs
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|s
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
name|lvs
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|_getRecursivelyAccessedLocalsIndicesHelper
argument_list|(
name|s
argument_list|,
name|this
operator|.
name|subSubs
argument_list|()
argument_list|)
expr_stmt|;
name|int
index|[]
name|ret
init|=
operator|new
name|int
index|[
name|s
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|Iterator
name|i
init|=
name|s
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|j
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|ret
index|[
name|j
index|]
operator|=
operator|(
operator|(
name|Integer
operator|)
name|i
operator|.
name|next
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/** 		 * A recursive helper method for getRecursivelyAccessedLocalsIndices(). 		 * @see #getRecursivelyAccessedLocalsIndices() 		 */
specifier|private
name|void
name|_getRecursivelyAccessedLocalsIndicesHelper
parameter_list|(
name|Set
name|s
parameter_list|,
name|Subroutine
index|[]
name|subs
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
index|[]
name|lvs
init|=
name|subs
index|[
name|i
index|]
operator|.
name|getAccessedLocalsIndices
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|lvs
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|s
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
name|lvs
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subs
index|[
name|i
index|]
operator|.
name|subSubs
argument_list|()
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|_getRecursivelyAccessedLocalsIndicesHelper
argument_list|(
name|s
argument_list|,
name|subs
index|[
name|i
index|]
operator|.
name|subSubs
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * Satisfies Subroutine.getAccessedLocalIndices(). 		 */
specifier|public
name|int
index|[]
name|getAccessedLocalsIndices
parameter_list|()
block|{
comment|//TODO: Implement caching.
name|Set
name|acc
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
if|if
condition|(
name|theRET
operator|==
literal|null
operator|&&
name|this
operator|!=
name|TOPLEVEL
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"This subroutine object must be built up completely before calculating accessed locals."
argument_list|)
throw|;
block|}
name|Iterator
name|i
init|=
name|instructions
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|InstructionHandle
name|ih
init|=
operator|(
name|InstructionHandle
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// RET is not a LocalVariableInstruction in the current version of BCEL.
if|if
condition|(
name|ih
operator|.
name|getInstruction
argument_list|()
operator|instanceof
name|LocalVariableInstruction
operator|||
name|ih
operator|.
name|getInstruction
argument_list|()
operator|instanceof
name|RET
condition|)
block|{
name|int
name|idx
init|=
operator|(
operator|(
name|IndexedInstruction
operator|)
operator|(
name|ih
operator|.
name|getInstruction
argument_list|()
operator|)
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|acc
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
comment|// LONG? DOUBLE?.
try|try
block|{
comment|// LocalVariableInstruction instances are typed without the need to look into
comment|// the constant pool.
if|if
condition|(
name|ih
operator|.
name|getInstruction
argument_list|()
operator|instanceof
name|LocalVariableInstruction
condition|)
block|{
name|int
name|s
init|=
operator|(
operator|(
name|LocalVariableInstruction
operator|)
name|ih
operator|.
name|getInstruction
argument_list|()
operator|)
operator|.
name|getType
argument_list|(
literal|null
argument_list|)
operator|.
name|getSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|2
condition|)
block|{
name|acc
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|re
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Oops. BCEL did not like NULL as a ConstantPoolGen object."
argument_list|)
throw|;
block|}
block|}
block|}
name|int
index|[]
name|ret
init|=
operator|new
name|int
index|[
name|acc
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|i
operator|=
name|acc
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|int
name|j
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|ret
index|[
name|j
index|]
operator|=
operator|(
operator|(
name|Integer
operator|)
name|i
operator|.
name|next
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/* 		 * Satisfies Subroutine.subSubs(). 		 */
specifier|public
name|Subroutine
index|[]
name|subSubs
parameter_list|()
block|{
name|Set
name|h
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
name|Iterator
name|i
init|=
name|instructions
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Instruction
name|inst
init|=
operator|(
operator|(
name|InstructionHandle
operator|)
name|i
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
if|if
condition|(
name|inst
operator|instanceof
name|JsrInstruction
condition|)
block|{
name|InstructionHandle
name|targ
init|=
operator|(
operator|(
name|JsrInstruction
operator|)
name|inst
operator|)
operator|.
name|getTarget
argument_list|()
decl_stmt|;
name|h
operator|.
name|add
argument_list|(
name|getSubroutine
argument_list|(
name|targ
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Subroutine
index|[]
name|ret
init|=
operator|new
name|Subroutine
index|[
name|h
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
return|return
operator|(
name|Subroutine
index|[]
operator|)
name|h
operator|.
name|toArray
argument_list|(
name|ret
argument_list|)
return|;
block|}
comment|/* 		 * Sets the local variable slot the ASTORE that is targeted 		 * by the JsrInstructions of this subroutine operates on. 		 * This subroutine's RET operates on that same local variable 		 * slot, of course. 		 */
name|void
name|setLocalVariable
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|localVariable
operator|!=
name|UNSET
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"localVariable set twice."
argument_list|)
throw|;
block|}
else|else
block|{
name|localVariable
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/** 		 * The default constructor. 		 */
specifier|public
name|SubroutineImpl
parameter_list|()
block|{
block|}
block|}
comment|// end Inner Class SubrouteImpl
comment|//Node coloring constants
specifier|private
specifier|static
specifier|final
name|Integer
name|WHITE
init|=
operator|new
name|Integer
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Integer
name|GRAY
init|=
operator|new
name|Integer
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Integer
name|BLACK
init|=
operator|new
name|Integer
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|/** 	 * The map containing the subroutines found. 	 * Key: InstructionHandle of the leader of the subroutine. 	 * Elements: SubroutineImpl objects. 	 */
specifier|private
name|Map
name|subroutines
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|/** 	 * This is referring to a special subroutine, namely the 	 * top level. This is not really a subroutine but we use 	 * it to distinguish between top level instructions and 	 * unreachable instructions. 	 */
specifier|public
specifier|final
name|Subroutine
name|TOPLEVEL
decl_stmt|;
comment|/** 	 * Constructor. 	 * @param mg A MethodGen object representing method to 	 * create the Subroutine objects of. 	 */
specifier|public
name|Subroutines
parameter_list|(
name|MethodGen
name|mg
parameter_list|)
block|{
name|InstructionHandle
index|[]
name|all
init|=
name|mg
operator|.
name|getInstructionList
argument_list|()
operator|.
name|getInstructionHandles
argument_list|()
decl_stmt|;
name|CodeExceptionGen
index|[]
name|handlers
init|=
name|mg
operator|.
name|getExceptionHandlers
argument_list|()
decl_stmt|;
comment|// Define our "Toplevel" fake subroutine.
name|TOPLEVEL
operator|=
operator|new
name|SubroutineImpl
argument_list|()
expr_stmt|;
comment|// Calculate "real" subroutines.
name|Set
name|sub_leaders
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
comment|// Elements: InstructionHandle
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|all
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Instruction
name|inst
init|=
name|all
index|[
name|i
index|]
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
if|if
condition|(
name|inst
operator|instanceof
name|JsrInstruction
condition|)
block|{
name|sub_leaders
operator|.
name|add
argument_list|(
operator|(
operator|(
name|JsrInstruction
operator|)
name|inst
operator|)
operator|.
name|getTarget
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Build up the database.
name|Iterator
name|iter
init|=
name|sub_leaders
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SubroutineImpl
name|sr
init|=
operator|new
name|SubroutineImpl
argument_list|()
decl_stmt|;
name|InstructionHandle
name|astore
init|=
operator|(
name|InstructionHandle
operator|)
operator|(
name|iter
operator|.
name|next
argument_list|()
operator|)
decl_stmt|;
name|sr
operator|.
name|setLocalVariable
argument_list|(
operator|(
operator|(
name|ASTORE
operator|)
operator|(
name|astore
operator|.
name|getInstruction
argument_list|()
operator|)
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|subroutines
operator|.
name|put
argument_list|(
name|astore
argument_list|,
name|sr
argument_list|)
expr_stmt|;
block|}
comment|// Fake it a bit. We want a virtual "TopLevel" subroutine.
name|subroutines
operator|.
name|put
argument_list|(
name|all
index|[
literal|0
index|]
argument_list|,
name|TOPLEVEL
argument_list|)
expr_stmt|;
name|sub_leaders
operator|.
name|add
argument_list|(
name|all
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Tell the subroutines about their JsrInstructions.
comment|// Note that there cannot be a JSR targeting the top-level
comment|// since "Jsr 0" is disallowed in Pass 3a.
comment|// Instructions shared by a subroutine and the toplevel are
comment|// disallowed and checked below, after the BFS.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|all
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Instruction
name|inst
init|=
name|all
index|[
name|i
index|]
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
if|if
condition|(
name|inst
operator|instanceof
name|JsrInstruction
condition|)
block|{
name|InstructionHandle
name|leader
init|=
operator|(
operator|(
name|JsrInstruction
operator|)
name|inst
operator|)
operator|.
name|getTarget
argument_list|()
decl_stmt|;
operator|(
operator|(
name|SubroutineImpl
operator|)
name|getSubroutine
argument_list|(
name|leader
argument_list|)
operator|)
operator|.
name|addEnteringJsrInstruction
argument_list|(
name|all
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Now do a BFS from every subroutine leader to find all the
comment|// instructions that belong to a subroutine.
name|Set
name|instructions_assigned
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
comment|// we don't want to assign an instruction to two or more Subroutine objects.
name|Map
name|colors
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|//Graph colouring. Key: InstructionHandle, Value: Integer .
name|iter
operator|=
name|sub_leaders
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// Do some BFS with "actual" as the root of the graph.
name|InstructionHandle
name|actual
init|=
operator|(
name|InstructionHandle
operator|)
operator|(
name|iter
operator|.
name|next
argument_list|()
operator|)
decl_stmt|;
comment|// Init colors
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|all
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|colors
operator|.
name|put
argument_list|(
name|all
index|[
name|i
index|]
argument_list|,
name|WHITE
argument_list|)
expr_stmt|;
block|}
name|colors
operator|.
name|put
argument_list|(
name|actual
argument_list|,
name|GRAY
argument_list|)
expr_stmt|;
comment|// Init Queue
name|ArrayList
name|Q
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|Q
operator|.
name|add
argument_list|(
name|actual
argument_list|)
expr_stmt|;
comment|// add(Obj) adds to the end, remove(0) removes from the start.
comment|/* BFS ALGORITHM MODIFICATION: Start out with multiple "root" nodes, as exception handlers are starting points of top-level code, too. [why top-level? TODO: Refer to the special JustIce notion of subroutines.]*/
if|if
condition|(
name|actual
operator|==
name|all
index|[
literal|0
index|]
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|handlers
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|colors
operator|.
name|put
argument_list|(
name|handlers
index|[
name|j
index|]
operator|.
name|getHandlerPC
argument_list|()
argument_list|,
name|GRAY
argument_list|)
expr_stmt|;
name|Q
operator|.
name|add
argument_list|(
name|handlers
index|[
name|j
index|]
operator|.
name|getHandlerPC
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* CONTINUE NORMAL BFS ALGORITHM */
comment|// Loop until Queue is empty
while|while
condition|(
name|Q
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|InstructionHandle
name|u
init|=
operator|(
name|InstructionHandle
operator|)
name|Q
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|InstructionHandle
index|[]
name|successors
init|=
name|getSuccessors
argument_list|(
name|u
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|successors
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|Integer
operator|)
name|colors
operator|.
name|get
argument_list|(
name|successors
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
name|WHITE
condition|)
block|{
name|colors
operator|.
name|put
argument_list|(
name|successors
index|[
name|i
index|]
argument_list|,
name|GRAY
argument_list|)
expr_stmt|;
name|Q
operator|.
name|add
argument_list|(
name|successors
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|colors
operator|.
name|put
argument_list|(
name|u
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
block|}
comment|// BFS ended above.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|all
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|colors
operator|.
name|get
argument_list|(
name|all
index|[
name|i
index|]
argument_list|)
operator|==
name|BLACK
condition|)
block|{
operator|(
operator|(
name|SubroutineImpl
operator|)
operator|(
name|actual
operator|==
name|all
index|[
literal|0
index|]
condition|?
name|getTopLevel
argument_list|()
else|:
name|getSubroutine
argument_list|(
name|actual
argument_list|)
operator|)
operator|)
operator|.
name|addInstruction
argument_list|(
name|all
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|instructions_assigned
operator|.
name|contains
argument_list|(
name|all
index|[
name|i
index|]
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|StructuralCodeConstraintException
argument_list|(
literal|"Instruction '"
operator|+
name|all
index|[
name|i
index|]
operator|+
literal|"' is part of more than one subroutine (or of the top level and a subroutine)."
argument_list|)
throw|;
block|}
else|else
block|{
name|instructions_assigned
operator|.
name|add
argument_list|(
name|all
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|actual
operator|!=
name|all
index|[
literal|0
index|]
condition|)
block|{
comment|// If we don't deal with the top-level 'subroutine'
operator|(
operator|(
name|SubroutineImpl
operator|)
name|getSubroutine
argument_list|(
name|actual
argument_list|)
operator|)
operator|.
name|setLeavingRET
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Now make sure no instruction of a Subroutine is protected by exception handling code
comment|// as is mandated by JustIces notion of subroutines.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|handlers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|InstructionHandle
name|_protected
init|=
name|handlers
index|[
name|i
index|]
operator|.
name|getStartPC
argument_list|()
decl_stmt|;
while|while
condition|(
name|_protected
operator|!=
name|handlers
index|[
name|i
index|]
operator|.
name|getEndPC
argument_list|()
operator|.
name|getNext
argument_list|()
condition|)
block|{
comment|// Note the inclusive/inclusive notation of "generic API" exception handlers!
name|Iterator
name|subs
init|=
name|subroutines
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|subs
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Subroutine
name|sub
init|=
operator|(
name|Subroutine
operator|)
name|subs
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|sub
operator|!=
name|subroutines
operator|.
name|get
argument_list|(
name|all
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|// We don't want to forbid top-level exception handlers.
if|if
condition|(
name|sub
operator|.
name|contains
argument_list|(
name|_protected
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|StructuralCodeConstraintException
argument_list|(
literal|"Subroutine instruction '"
operator|+
name|_protected
operator|+
literal|"' is protected by an exception handler, '"
operator|+
name|handlers
index|[
name|i
index|]
operator|+
literal|"'. This is forbidden by the JustIce verifier due to its clear definition of subroutines."
argument_list|)
throw|;
block|}
block|}
block|}
name|_protected
operator|=
name|_protected
operator|.
name|getNext
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Now make sure no subroutine is calling a subroutine
comment|// that uses the same local variable for the RET as themselves
comment|// (recursively).
comment|// This includes that subroutines may not call themselves
comment|// recursively, even not through intermediate calls to other
comment|// subroutines.
name|noRecursiveCalls
argument_list|(
name|getTopLevel
argument_list|()
argument_list|,
operator|new
name|HashSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * This (recursive) utility method makes sure that 	 * no subroutine is calling a subroutine 	 * that uses the same local variable for the RET as themselves 	 * (recursively). 	 * This includes that subroutines may not call themselves 	 * recursively, even not through intermediate calls to other 	 * subroutines. 	 * 	 * @throws StructuralCodeConstraintException if the above constraint is not satisfied. 	 */
specifier|private
name|void
name|noRecursiveCalls
parameter_list|(
name|Subroutine
name|sub
parameter_list|,
name|Set
name|set
parameter_list|)
block|{
name|Subroutine
index|[]
name|subs
init|=
name|sub
operator|.
name|subSubs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
operator|(
operator|(
name|RET
operator|)
operator|(
name|subs
index|[
name|i
index|]
operator|.
name|getLeavingRET
argument_list|()
operator|.
name|getInstruction
argument_list|()
operator|)
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|set
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
comment|// Don't use toString() here because of possibly infinite recursive subSubs() calls then.
name|SubroutineImpl
name|si
init|=
operator|(
name|SubroutineImpl
operator|)
name|subs
index|[
name|i
index|]
decl_stmt|;
throw|throw
operator|new
name|StructuralCodeConstraintException
argument_list|(
literal|"Subroutine with local variable '"
operator|+
name|si
operator|.
name|localVariable
operator|+
literal|"', JSRs '"
operator|+
name|si
operator|.
name|theJSRs
operator|+
literal|"', RET '"
operator|+
name|si
operator|.
name|theRET
operator|+
literal|"' is called by a subroutine which uses the same local variable index as itself; maybe even a recursive call? JustIce's clean definition of a subroutine forbids both."
argument_list|)
throw|;
block|}
name|noRecursiveCalls
argument_list|(
name|subs
index|[
name|i
index|]
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|set
operator|.
name|remove
argument_list|(
operator|new
name|Integer
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * Returns the Subroutine object associated with the given 	 * leader (that is, the first instruction of the subroutine). 	 * You must not use this to get the top-level instructions 	 * modeled as a Subroutine object. 	 * 	 * @see #getTopLevel() 	 */
specifier|public
name|Subroutine
name|getSubroutine
parameter_list|(
name|InstructionHandle
name|leader
parameter_list|)
block|{
name|Subroutine
name|ret
init|=
operator|(
name|Subroutine
operator|)
name|subroutines
operator|.
name|get
argument_list|(
name|leader
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Subroutine requested for an InstructionHandle that is not a leader of a subroutine."
argument_list|)
throw|;
block|}
if|if
condition|(
name|ret
operator|==
name|TOPLEVEL
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"TOPLEVEL special subroutine requested; use getTopLevel()."
argument_list|)
throw|;
block|}
return|return
name|ret
return|;
block|}
comment|/** 	 * Returns the subroutine object associated with the 	 * given instruction. This is a costly operation, you 	 * should consider using getSubroutine(InstructionHandle). 	 * Returns 'null' if the given InstructionHandle lies 	 * in so-called 'dead code', i.e. code that can never 	 * be executed. 	 * 	 * @see #getSubroutine(InstructionHandle) 	 * @see #getTopLevel() 	 */
specifier|public
name|Subroutine
name|subroutineOf
parameter_list|(
name|InstructionHandle
name|any
parameter_list|)
block|{
name|Iterator
name|i
init|=
name|subroutines
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Subroutine
name|s
init|=
operator|(
name|Subroutine
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|contains
argument_list|(
name|any
argument_list|)
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"DEBUG: Please verify '"
operator|+
name|any
operator|.
name|toString
argument_list|(
literal|true
argument_list|)
operator|+
literal|"' lies in dead code."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|//throw new AssertionViolatedException("No subroutine for InstructionHandle found (DEAD CODE?).");
block|}
comment|/** 	 * For easy handling, the piece of code that is<B>not</B> a 	 * subroutine, the top-level, is also modeled as a Subroutine 	 * object. 	 * It is a special Subroutine object where<B>you must not invoke 	 * getEnteringJsrInstructions() or getLeavingRET()</B>. 	 * 	 * @see Subroutine#getEnteringJsrInstructions() 	 * @see Subroutine#getLeavingRET() 	 */
specifier|public
name|Subroutine
name|getTopLevel
parameter_list|()
block|{
return|return
name|TOPLEVEL
return|;
block|}
comment|/** 	 * A utility method that calculates the successors of a given InstructionHandle 	 *<B>in the same subroutine</B>. That means, a RET does not have any successors 	 * as defined here. A JsrInstruction has its physical successor as its successor 	 * (opposed to its target) as defined here. 	 */
specifier|private
specifier|static
name|InstructionHandle
index|[]
name|getSuccessors
parameter_list|(
name|InstructionHandle
name|instruction
parameter_list|)
block|{
specifier|final
name|InstructionHandle
index|[]
name|empty
init|=
operator|new
name|InstructionHandle
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|InstructionHandle
index|[]
name|single
init|=
operator|new
name|InstructionHandle
index|[
literal|1
index|]
decl_stmt|;
name|Instruction
name|inst
init|=
name|instruction
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
if|if
condition|(
name|inst
operator|instanceof
name|RET
condition|)
block|{
return|return
name|empty
return|;
block|}
comment|// Terminates method normally.
if|if
condition|(
name|inst
operator|instanceof
name|ReturnInstruction
condition|)
block|{
return|return
name|empty
return|;
block|}
comment|// Terminates method abnormally, because JustIce mandates
comment|// subroutines not to be protected by exception handlers.
if|if
condition|(
name|inst
operator|instanceof
name|ATHROW
condition|)
block|{
return|return
name|empty
return|;
block|}
comment|// See method comment.
if|if
condition|(
name|inst
operator|instanceof
name|JsrInstruction
condition|)
block|{
name|single
index|[
literal|0
index|]
operator|=
name|instruction
operator|.
name|getNext
argument_list|()
expr_stmt|;
return|return
name|single
return|;
block|}
if|if
condition|(
name|inst
operator|instanceof
name|GotoInstruction
condition|)
block|{
name|single
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|GotoInstruction
operator|)
name|inst
operator|)
operator|.
name|getTarget
argument_list|()
expr_stmt|;
return|return
name|single
return|;
block|}
if|if
condition|(
name|inst
operator|instanceof
name|BranchInstruction
condition|)
block|{
if|if
condition|(
name|inst
operator|instanceof
name|Select
condition|)
block|{
comment|// BCEL's getTargets() returns only the non-default targets,
comment|// thanks to Eli Tilevich for reporting.
name|InstructionHandle
index|[]
name|matchTargets
init|=
operator|(
operator|(
name|Select
operator|)
name|inst
operator|)
operator|.
name|getTargets
argument_list|()
decl_stmt|;
name|InstructionHandle
index|[]
name|ret
init|=
operator|new
name|InstructionHandle
index|[
name|matchTargets
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|ret
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|Select
operator|)
name|inst
operator|)
operator|.
name|getTarget
argument_list|()
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|matchTargets
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|1
argument_list|,
name|matchTargets
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
specifier|final
name|InstructionHandle
index|[]
name|pair
init|=
operator|new
name|InstructionHandle
index|[
literal|2
index|]
decl_stmt|;
name|pair
index|[
literal|0
index|]
operator|=
name|instruction
operator|.
name|getNext
argument_list|()
expr_stmt|;
name|pair
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|BranchInstruction
operator|)
name|inst
operator|)
operator|.
name|getTarget
argument_list|()
expr_stmt|;
return|return
name|pair
return|;
block|}
block|}
comment|// default case: Fall through.
name|single
index|[
literal|0
index|]
operator|=
name|instruction
operator|.
name|getNext
argument_list|()
expr_stmt|;
return|return
name|single
return|;
block|}
comment|/** 	 * Returns a String representation of this object; merely for debugging puposes. 	 */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"---\n"
operator|+
name|subroutines
operator|.
name|toString
argument_list|()
operator|+
literal|"\n---\n"
return|;
block|}
block|}
end_class

end_unit

