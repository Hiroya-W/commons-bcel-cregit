begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|structurals
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ASTORE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ATHROW
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|BranchInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|CodeExceptionGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|GotoInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|IndexedInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|Instruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|InstructionHandle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|JsrInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|LocalVariableInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|MethodGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|RET
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ReturnInstruction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|Select
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|exc
operator|.
name|AssertionViolatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|verifier
operator|.
name|exc
operator|.
name|StructuralCodeConstraintException
import|;
end_import

begin_comment
comment|/**  * Instances of this class contain information about the subroutines found in a code array of a method. This  * implementation considers the top-level (the instructions reachable without a JSR or JSR_W starting off from the first  * instruction in a code array of a method) being a special subroutine; see getTopLevel() for that. Please note that the  * definition of subroutines in the Java Virtual Machine Specification, Second Edition is somewhat incomplete.  * Therefore, JustIce uses an own, more rigid notion. Basically, a subroutine is a piece of code that starts at the  * target of a JSR of JSR_W instruction and ends at a corresponding RET instruction. Note also that the control flow of  * a subroutine may be complex and non-linear; and that subroutines may be nested. JustIce also mandates subroutines not  * to be protected by exception handling code (for the sake of control flow predictability). To understand JustIce's  * notion of subroutines, please read  *  * TODO: refer to the paper.  *  * @see #getTopLevel()  */
end_comment

begin_class
specifier|public
class|class
name|Subroutines
block|{
comment|// Node coloring constants
specifier|private
enum|enum
name|ColourConstants
block|{
name|WHITE
block|,
name|GRAY
block|,
name|BLACK
block|}
comment|/**      * This inner class implements the Subroutine interface.      */
specifier|private
class|class
name|SubroutineImpl
implements|implements
name|Subroutine
block|{
comment|/**          * UNSET, a symbol for an uninitialized localVariable field. This is used for the "top-level" Subroutine; i.e. no          * subroutine.          */
specifier|private
specifier|static
specifier|final
name|int
name|UNSET
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|final
name|SubroutineImpl
index|[]
name|EMPTY_ARRAY
init|=
block|{}
decl_stmt|;
comment|/**          * The Local Variable slot where the first instruction of this subroutine (an ASTORE) stores the JsrInstruction's          * ReturnAddress in and the RET of this subroutine operates on.          */
specifier|private
name|int
name|localVariable
init|=
name|UNSET
decl_stmt|;
comment|/** The instructions that belong to this subroutine. */
specifier|private
specifier|final
name|Set
argument_list|<
name|InstructionHandle
argument_list|>
name|instructions
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Elements: InstructionHandle
comment|/**          * The JSR or JSR_W instructions that define this subroutine by targeting it.          */
specifier|private
specifier|final
name|Set
argument_list|<
name|InstructionHandle
argument_list|>
name|theJSRs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**          * The RET instruction that leaves this subroutine.          */
specifier|private
name|InstructionHandle
name|theRET
decl_stmt|;
comment|/**          * The default constructor.          */
specifier|public
name|SubroutineImpl
parameter_list|()
block|{
block|}
comment|/**          * A recursive helper method for getRecursivelyAccessedLocalsIndices().          *          * @see #getRecursivelyAccessedLocalsIndices()          */
specifier|private
name|void
name|_getRecursivelyAccessedLocalsIndicesHelper
parameter_list|(
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|set
parameter_list|,
specifier|final
name|Subroutine
index|[]
name|subs
parameter_list|)
block|{
for|for
control|(
specifier|final
name|Subroutine
name|sub
range|:
name|subs
control|)
block|{
specifier|final
name|int
index|[]
name|lvs
init|=
name|sub
operator|.
name|getAccessedLocalsIndices
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|int
name|lv
range|:
name|lvs
control|)
block|{
name|set
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|lv
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sub
operator|.
name|subSubs
argument_list|()
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|_getRecursivelyAccessedLocalsIndicesHelper
argument_list|(
name|set
argument_list|,
name|sub
operator|.
name|subSubs
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Adds a new JSR or JSR_W that has this subroutine as its target.          */
specifier|public
name|void
name|addEnteringJsrInstruction
parameter_list|(
specifier|final
name|InstructionHandle
name|jsrInst
parameter_list|)
block|{
if|if
condition|(
name|jsrInst
operator|==
literal|null
operator|||
operator|!
operator|(
name|jsrInst
operator|.
name|getInstruction
argument_list|()
operator|instanceof
name|JsrInstruction
operator|)
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Expecting JsrInstruction InstructionHandle."
argument_list|)
throw|;
block|}
if|if
condition|(
name|localVariable
operator|==
name|UNSET
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Set the localVariable first!"
argument_list|)
throw|;
block|}
comment|// Something is wrong when an ASTORE is targeted that does not operate on the same local variable than the rest of the
comment|// JsrInstruction-targets and the RET.
comment|// (We don't know out leader here so we cannot check if we're really targeted!)
if|if
condition|(
name|localVariable
operator|!=
operator|(
operator|(
name|ASTORE
operator|)
operator|(
operator|(
name|JsrInstruction
operator|)
name|jsrInst
operator|.
name|getInstruction
argument_list|()
operator|)
operator|.
name|getTarget
argument_list|()
operator|.
name|getInstruction
argument_list|()
operator|)
operator|.
name|getIndex
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Setting a wrong JsrInstruction."
argument_list|)
throw|;
block|}
name|theJSRs
operator|.
name|add
argument_list|(
name|jsrInst
argument_list|)
expr_stmt|;
block|}
comment|/*          * Adds an instruction to this subroutine. All instructions must have been added before invoking setLeavingRET().          *          * @see #setLeavingRET          */
name|void
name|addInstruction
parameter_list|(
specifier|final
name|InstructionHandle
name|ih
parameter_list|)
block|{
if|if
condition|(
name|theRET
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"All instructions must have been added before invoking setLeavingRET()."
argument_list|)
throw|;
block|}
name|instructions
operator|.
name|add
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
comment|/*          * Refer to the Subroutine interface for documentation.          */
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
specifier|final
name|InstructionHandle
name|inst
parameter_list|)
block|{
return|return
name|instructions
operator|.
name|contains
argument_list|(
name|inst
argument_list|)
return|;
block|}
comment|/*          * Satisfies Subroutine.getAccessedLocalIndices().          */
annotation|@
name|Override
specifier|public
name|int
index|[]
name|getAccessedLocalsIndices
parameter_list|()
block|{
comment|// TODO: Implement caching.
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|acc
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|theRET
operator|==
literal|null
operator|&&
name|this
operator|!=
name|getTopLevel
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"This subroutine object must be built up completely before calculating accessed locals."
argument_list|)
throw|;
block|}
block|{
for|for
control|(
specifier|final
name|InstructionHandle
name|ih
range|:
name|instructions
control|)
block|{
comment|// RET is not a LocalVariableInstruction in the current version of BCEL.
if|if
condition|(
name|ih
operator|.
name|getInstruction
argument_list|()
operator|instanceof
name|LocalVariableInstruction
operator|||
name|ih
operator|.
name|getInstruction
argument_list|()
operator|instanceof
name|RET
condition|)
block|{
specifier|final
name|int
name|idx
init|=
operator|(
operator|(
name|IndexedInstruction
operator|)
name|ih
operator|.
name|getInstruction
argument_list|()
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|acc
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
comment|// LONG? DOUBLE?.
try|try
block|{
comment|// LocalVariableInstruction instances are typed without the need to look into
comment|// the constant pool.
if|if
condition|(
name|ih
operator|.
name|getInstruction
argument_list|()
operator|instanceof
name|LocalVariableInstruction
condition|)
block|{
specifier|final
name|int
name|s
init|=
operator|(
operator|(
name|LocalVariableInstruction
operator|)
name|ih
operator|.
name|getInstruction
argument_list|()
operator|)
operator|.
name|getType
argument_list|(
literal|null
argument_list|)
operator|.
name|getSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|2
condition|)
block|{
name|acc
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|RuntimeException
name|re
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"BCEL did not like NULL as a ConstantPoolGen object."
argument_list|,
name|re
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|{
specifier|final
name|int
index|[]
name|ret
init|=
operator|new
name|int
index|[
name|acc
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|j
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
specifier|final
name|Integer
name|accessedLocal
range|:
name|acc
control|)
block|{
name|j
operator|++
expr_stmt|;
name|ret
index|[
name|j
index|]
operator|=
name|accessedLocal
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
block|}
comment|/*          * Refer to the Subroutine interface for documentation.          */
annotation|@
name|Override
specifier|public
name|InstructionHandle
index|[]
name|getEnteringJsrInstructions
parameter_list|()
block|{
if|if
condition|(
name|this
operator|==
name|getTopLevel
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"getLeavingRET() called on top level pseudo-subroutine."
argument_list|)
throw|;
block|}
return|return
name|theJSRs
operator|.
name|toArray
argument_list|(
name|InstructionHandle
operator|.
name|EMPTY_ARRAY
argument_list|)
return|;
block|}
comment|/*          * Refer to the Subroutine interface for documentation.          */
annotation|@
name|Override
specifier|public
name|InstructionHandle
index|[]
name|getInstructions
parameter_list|()
block|{
return|return
name|instructions
operator|.
name|toArray
argument_list|(
name|InstructionHandle
operator|.
name|EMPTY_ARRAY
argument_list|)
return|;
block|}
comment|/*          * Refer to the Subroutine interface for documentation.          */
annotation|@
name|Override
specifier|public
name|InstructionHandle
name|getLeavingRET
parameter_list|()
block|{
if|if
condition|(
name|this
operator|==
name|getTopLevel
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"getLeavingRET() called on top level pseudo-subroutine."
argument_list|)
throw|;
block|}
return|return
name|theRET
return|;
block|}
comment|/* Satisfies Subroutine.getRecursivelyAccessedLocalsIndices(). */
annotation|@
name|Override
specifier|public
name|int
index|[]
name|getRecursivelyAccessedLocalsIndices
parameter_list|()
block|{
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|s
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|int
index|[]
name|lvs
init|=
name|getAccessedLocalsIndices
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|int
name|lv
range|:
name|lvs
control|)
block|{
name|s
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|lv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|_getRecursivelyAccessedLocalsIndicesHelper
argument_list|(
name|s
argument_list|,
name|this
operator|.
name|subSubs
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
index|[]
name|ret
init|=
operator|new
name|int
index|[
name|s
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|j
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
specifier|final
name|Integer
name|index
range|:
name|s
control|)
block|{
name|j
operator|++
expr_stmt|;
name|ret
index|[
name|j
index|]
operator|=
name|index
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**          * Sets the leaving RET instruction. Must be invoked after all instructions are added. Must not be invoked for top-level          * 'subroutine'.          */
name|void
name|setLeavingRET
parameter_list|()
block|{
if|if
condition|(
name|localVariable
operator|==
name|UNSET
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"setLeavingRET() called for top-level 'subroutine' or forgot to set local variable first."
argument_list|)
throw|;
block|}
name|InstructionHandle
name|ret
init|=
literal|null
decl_stmt|;
for|for
control|(
specifier|final
name|InstructionHandle
name|actual
range|:
name|instructions
control|)
block|{
if|if
condition|(
name|actual
operator|.
name|getInstruction
argument_list|()
operator|instanceof
name|RET
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|StructuralCodeConstraintException
argument_list|(
literal|"Subroutine with more then one RET detected: '"
operator|+
name|ret
operator|+
literal|"' and '"
operator|+
name|actual
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|ret
operator|=
name|actual
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|StructuralCodeConstraintException
argument_list|(
literal|"Subroutine without a RET detected."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
operator|(
name|RET
operator|)
name|ret
operator|.
name|getInstruction
argument_list|()
operator|)
operator|.
name|getIndex
argument_list|()
operator|!=
name|localVariable
condition|)
block|{
throw|throw
operator|new
name|StructuralCodeConstraintException
argument_list|(
literal|"Subroutine uses '"
operator|+
name|ret
operator|+
literal|"' which does not match the correct local variable '"
operator|+
name|localVariable
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|theRET
operator|=
name|ret
expr_stmt|;
block|}
comment|/*          * Sets the local variable slot the ASTORE that is targeted by the JsrInstructions of this subroutine operates on. This          * subroutine's RET operates on that same local variable slot, of course.          */
name|void
name|setLocalVariable
parameter_list|(
specifier|final
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|localVariable
operator|!=
name|UNSET
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"localVariable set twice."
argument_list|)
throw|;
block|}
name|localVariable
operator|=
name|i
expr_stmt|;
block|}
comment|/*          * Satisfies Subroutine.subSubs().          */
annotation|@
name|Override
specifier|public
name|Subroutine
index|[]
name|subSubs
parameter_list|()
block|{
specifier|final
name|Set
argument_list|<
name|Subroutine
argument_list|>
name|h
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|InstructionHandle
name|ih
range|:
name|instructions
control|)
block|{
specifier|final
name|Instruction
name|inst
init|=
name|ih
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
if|if
condition|(
name|inst
operator|instanceof
name|JsrInstruction
condition|)
block|{
specifier|final
name|InstructionHandle
name|targ
init|=
operator|(
operator|(
name|JsrInstruction
operator|)
name|inst
operator|)
operator|.
name|getTarget
argument_list|()
decl_stmt|;
name|h
operator|.
name|add
argument_list|(
name|getSubroutine
argument_list|(
name|targ
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|h
operator|.
name|toArray
argument_list|(
name|EMPTY_ARRAY
argument_list|)
return|;
block|}
comment|/**          * Returns a String representation of this object, merely for debugging purposes. (Internal) Warning: Verbosity on a          * problematic subroutine may cause stack overflow errors due to recursive subSubs() calls. Don't use this, then.          */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|ret
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|ret
operator|.
name|append
argument_list|(
literal|"Subroutine: Local variable is '"
argument_list|)
operator|.
name|append
argument_list|(
name|localVariable
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
literal|"', JSRs are '"
argument_list|)
operator|.
name|append
argument_list|(
name|theJSRs
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
literal|"', RET is '"
argument_list|)
operator|.
name|append
argument_list|(
name|theRET
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
literal|"', Instructions: '"
argument_list|)
operator|.
name|append
argument_list|(
name|instructions
argument_list|)
operator|.
name|append
argument_list|(
literal|"'."
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
literal|" Accessed local variable slots: '"
argument_list|)
expr_stmt|;
name|int
index|[]
name|alv
init|=
name|getAccessedLocalsIndices
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|int
name|element
range|:
name|alv
control|)
block|{
name|ret
operator|.
name|append
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|ret
operator|.
name|append
argument_list|(
literal|"'."
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
literal|" Recursively (via subsub...routines) accessed local variable slots: '"
argument_list|)
expr_stmt|;
name|alv
operator|=
name|getRecursivelyAccessedLocalsIndices
argument_list|()
expr_stmt|;
for|for
control|(
specifier|final
name|int
name|element
range|:
name|alv
control|)
block|{
name|ret
operator|.
name|append
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|ret
operator|.
name|append
argument_list|(
literal|"'."
argument_list|)
expr_stmt|;
return|return
name|ret
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|// end Inner Class SubrouteImpl
comment|/**      * A utility method that calculates the successors of a given InstructionHandle<B>in the same subroutine</B>. That      * means, a RET does not have any successors as defined here. A JsrInstruction has its physical successor as its      * successor (opposed to its target) as defined here.      */
specifier|private
specifier|static
name|InstructionHandle
index|[]
name|getSuccessors
parameter_list|(
specifier|final
name|InstructionHandle
name|instruction
parameter_list|)
block|{
specifier|final
name|InstructionHandle
index|[]
name|single
init|=
operator|new
name|InstructionHandle
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|Instruction
name|inst
init|=
name|instruction
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
comment|// Terminates method normally.
comment|// Terminates method abnormally, because JustIce mandates
comment|// subroutines not to be protected by exception handlers.
if|if
condition|(
name|inst
operator|instanceof
name|RET
operator|||
name|inst
operator|instanceof
name|ReturnInstruction
operator|||
name|inst
operator|instanceof
name|ATHROW
condition|)
block|{
return|return
name|InstructionHandle
operator|.
name|EMPTY_ARRAY
return|;
block|}
comment|// See method comment.
if|if
condition|(
name|inst
operator|instanceof
name|JsrInstruction
condition|)
block|{
name|single
index|[
literal|0
index|]
operator|=
name|instruction
operator|.
name|getNext
argument_list|()
expr_stmt|;
return|return
name|single
return|;
block|}
if|if
condition|(
name|inst
operator|instanceof
name|GotoInstruction
condition|)
block|{
name|single
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|GotoInstruction
operator|)
name|inst
operator|)
operator|.
name|getTarget
argument_list|()
expr_stmt|;
return|return
name|single
return|;
block|}
if|if
condition|(
name|inst
operator|instanceof
name|BranchInstruction
condition|)
block|{
if|if
condition|(
name|inst
operator|instanceof
name|Select
condition|)
block|{
comment|// BCEL's getTargets() returns only the non-default targets,
comment|// thanks to Eli Tilevich for reporting.
specifier|final
name|InstructionHandle
index|[]
name|matchTargets
init|=
operator|(
operator|(
name|Select
operator|)
name|inst
operator|)
operator|.
name|getTargets
argument_list|()
decl_stmt|;
specifier|final
name|InstructionHandle
index|[]
name|ret
init|=
operator|new
name|InstructionHandle
index|[
name|matchTargets
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|ret
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|Select
operator|)
name|inst
operator|)
operator|.
name|getTarget
argument_list|()
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|matchTargets
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
literal|1
argument_list|,
name|matchTargets
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
specifier|final
name|InstructionHandle
index|[]
name|pair
init|=
operator|new
name|InstructionHandle
index|[
literal|2
index|]
decl_stmt|;
name|pair
index|[
literal|0
index|]
operator|=
name|instruction
operator|.
name|getNext
argument_list|()
expr_stmt|;
name|pair
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|BranchInstruction
operator|)
name|inst
operator|)
operator|.
name|getTarget
argument_list|()
expr_stmt|;
return|return
name|pair
return|;
block|}
comment|// default case: Fall through.
name|single
index|[
literal|0
index|]
operator|=
name|instruction
operator|.
name|getNext
argument_list|()
expr_stmt|;
return|return
name|single
return|;
block|}
comment|/**      * The map containing the subroutines found. Key: InstructionHandle of the leader of the subroutine. Elements:      * SubroutineImpl objects.      */
specifier|private
specifier|final
name|Map
argument_list|<
name|InstructionHandle
argument_list|,
name|Subroutine
argument_list|>
name|subroutines
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * This is referring to a special subroutine, namely the top level. This is not really a subroutine but we use it to      * distinguish between top level instructions and unreachable instructions.      */
comment|// CHECKSTYLE:OFF
specifier|public
specifier|final
name|Subroutine
name|TOPLEVEL
decl_stmt|;
comment|// TODO can this be made private?
comment|// CHECKSTYLE:ON
comment|/**      * Constructor.      *      * @param mg A MethodGen object representing method to create the Subroutine objects of. Assumes that JustIce strict      *        checks are needed.      */
specifier|public
name|Subroutines
parameter_list|(
specifier|final
name|MethodGen
name|mg
parameter_list|)
block|{
name|this
argument_list|(
name|mg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor.      *      * @param mg A MethodGen object representing method to create the Subroutine objects of.      * @param enableJustIceCheck whether to enable additional JustIce checks      * @since 6.0      */
specifier|public
name|Subroutines
parameter_list|(
specifier|final
name|MethodGen
name|mg
parameter_list|,
specifier|final
name|boolean
name|enableJustIceCheck
parameter_list|)
block|{
specifier|final
name|InstructionHandle
index|[]
name|all
init|=
name|mg
operator|.
name|getInstructionList
argument_list|()
operator|.
name|getInstructionHandles
argument_list|()
decl_stmt|;
specifier|final
name|CodeExceptionGen
index|[]
name|handlers
init|=
name|mg
operator|.
name|getExceptionHandlers
argument_list|()
decl_stmt|;
comment|// Define our "Toplevel" fake subroutine.
name|TOPLEVEL
operator|=
operator|new
name|SubroutineImpl
argument_list|()
expr_stmt|;
comment|// Calculate "real" subroutines.
specifier|final
name|Set
argument_list|<
name|InstructionHandle
argument_list|>
name|sub_leaders
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Elements: InstructionHandle
for|for
control|(
specifier|final
name|InstructionHandle
name|element
range|:
name|all
control|)
block|{
specifier|final
name|Instruction
name|inst
init|=
name|element
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
if|if
condition|(
name|inst
operator|instanceof
name|JsrInstruction
condition|)
block|{
name|sub_leaders
operator|.
name|add
argument_list|(
operator|(
operator|(
name|JsrInstruction
operator|)
name|inst
operator|)
operator|.
name|getTarget
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Build up the database.
for|for
control|(
specifier|final
name|InstructionHandle
name|astore
range|:
name|sub_leaders
control|)
block|{
specifier|final
name|SubroutineImpl
name|sr
init|=
operator|new
name|SubroutineImpl
argument_list|()
decl_stmt|;
name|sr
operator|.
name|setLocalVariable
argument_list|(
operator|(
operator|(
name|ASTORE
operator|)
name|astore
operator|.
name|getInstruction
argument_list|()
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|subroutines
operator|.
name|put
argument_list|(
name|astore
argument_list|,
name|sr
argument_list|)
expr_stmt|;
block|}
comment|// Fake it a bit. We want a virtual "TopLevel" subroutine.
name|subroutines
operator|.
name|put
argument_list|(
name|all
index|[
literal|0
index|]
argument_list|,
name|TOPLEVEL
argument_list|)
expr_stmt|;
name|sub_leaders
operator|.
name|add
argument_list|(
name|all
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Tell the subroutines about their JsrInstructions.
comment|// Note that there cannot be a JSR targeting the top-level
comment|// since "Jsr 0" is disallowed in Pass 3a.
comment|// Instructions shared by a subroutine and the toplevel are
comment|// disallowed and checked below, after the BFS.
for|for
control|(
specifier|final
name|InstructionHandle
name|element
range|:
name|all
control|)
block|{
specifier|final
name|Instruction
name|inst
init|=
name|element
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
if|if
condition|(
name|inst
operator|instanceof
name|JsrInstruction
condition|)
block|{
specifier|final
name|InstructionHandle
name|leader
init|=
operator|(
operator|(
name|JsrInstruction
operator|)
name|inst
operator|)
operator|.
name|getTarget
argument_list|()
decl_stmt|;
operator|(
operator|(
name|SubroutineImpl
operator|)
name|getSubroutine
argument_list|(
name|leader
argument_list|)
operator|)
operator|.
name|addEnteringJsrInstruction
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Now do a BFS from every subroutine leader to find all the
comment|// instructions that belong to a subroutine.
comment|// we don't want to assign an instruction to two or more Subroutine objects.
specifier|final
name|Set
argument_list|<
name|InstructionHandle
argument_list|>
name|instructions_assigned
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Graph coloring. Key: InstructionHandle, Value: ColourConstants enum .
specifier|final
name|Map
argument_list|<
name|InstructionHandle
argument_list|,
name|ColourConstants
argument_list|>
name|colors
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|InstructionHandle
argument_list|>
name|qList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|InstructionHandle
name|actual
range|:
name|sub_leaders
control|)
block|{
comment|// Do some BFS with "actual" as the root of the graph.
comment|// Init colors
for|for
control|(
specifier|final
name|InstructionHandle
name|element
range|:
name|all
control|)
block|{
name|colors
operator|.
name|put
argument_list|(
name|element
argument_list|,
name|ColourConstants
operator|.
name|WHITE
argument_list|)
expr_stmt|;
block|}
name|colors
operator|.
name|put
argument_list|(
name|actual
argument_list|,
name|ColourConstants
operator|.
name|GRAY
argument_list|)
expr_stmt|;
comment|// Init Queue
name|qList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qList
operator|.
name|add
argument_list|(
name|actual
argument_list|)
expr_stmt|;
comment|// add(Obj) adds to the end, remove(0) removes from the start.
comment|/*              * BFS ALGORITHM MODIFICATION: Start out with multiple "root" nodes, as exception handlers are starting points of              * top-level code, too. [why top-level? TODO: Refer to the special JustIce notion of subroutines.]              */
if|if
condition|(
name|actual
operator|==
name|all
index|[
literal|0
index|]
condition|)
block|{
for|for
control|(
specifier|final
name|CodeExceptionGen
name|handler
range|:
name|handlers
control|)
block|{
name|colors
operator|.
name|put
argument_list|(
name|handler
operator|.
name|getHandlerPC
argument_list|()
argument_list|,
name|ColourConstants
operator|.
name|GRAY
argument_list|)
expr_stmt|;
name|qList
operator|.
name|add
argument_list|(
name|handler
operator|.
name|getHandlerPC
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* CONTINUE NORMAL BFS ALGORITHM */
comment|// Loop until Queue is empty
while|while
condition|(
operator|!
name|qList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|InstructionHandle
name|u
init|=
name|qList
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|InstructionHandle
index|[]
name|successors
init|=
name|getSuccessors
argument_list|(
name|u
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|InstructionHandle
name|successor
range|:
name|successors
control|)
block|{
if|if
condition|(
name|colors
operator|.
name|get
argument_list|(
name|successor
argument_list|)
operator|==
name|ColourConstants
operator|.
name|WHITE
condition|)
block|{
name|colors
operator|.
name|put
argument_list|(
name|successor
argument_list|,
name|ColourConstants
operator|.
name|GRAY
argument_list|)
expr_stmt|;
name|qList
operator|.
name|add
argument_list|(
name|successor
argument_list|)
expr_stmt|;
block|}
block|}
name|colors
operator|.
name|put
argument_list|(
name|u
argument_list|,
name|ColourConstants
operator|.
name|BLACK
argument_list|)
expr_stmt|;
block|}
comment|// BFS ended above.
for|for
control|(
specifier|final
name|InstructionHandle
name|element
range|:
name|all
control|)
block|{
if|if
condition|(
name|colors
operator|.
name|get
argument_list|(
name|element
argument_list|)
operator|==
name|ColourConstants
operator|.
name|BLACK
condition|)
block|{
operator|(
operator|(
name|SubroutineImpl
operator|)
operator|(
name|actual
operator|==
name|all
index|[
literal|0
index|]
condition|?
name|getTopLevel
argument_list|()
else|:
name|getSubroutine
argument_list|(
name|actual
argument_list|)
operator|)
operator|)
operator|.
name|addInstruction
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|instructions_assigned
operator|.
name|contains
argument_list|(
name|element
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|StructuralCodeConstraintException
argument_list|(
literal|"Instruction '"
operator|+
name|element
operator|+
literal|"' is part of more than one subroutine (or of the top level and a subroutine)."
argument_list|)
throw|;
block|}
name|instructions_assigned
operator|.
name|add
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|actual
operator|!=
name|all
index|[
literal|0
index|]
condition|)
block|{
comment|// If we don't deal with the top-level 'subroutine'
operator|(
operator|(
name|SubroutineImpl
operator|)
name|getSubroutine
argument_list|(
name|actual
argument_list|)
operator|)
operator|.
name|setLeavingRET
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|enableJustIceCheck
condition|)
block|{
comment|// Now make sure no instruction of a Subroutine is protected by exception handling code
comment|// as is mandated by JustIces notion of subroutines.
for|for
control|(
specifier|final
name|CodeExceptionGen
name|handler
range|:
name|handlers
control|)
block|{
name|InstructionHandle
name|_protected
init|=
name|handler
operator|.
name|getStartPC
argument_list|()
decl_stmt|;
while|while
condition|(
name|_protected
operator|!=
name|handler
operator|.
name|getEndPC
argument_list|()
operator|.
name|getNext
argument_list|()
condition|)
block|{
comment|// Note the inclusive/inclusive notation of "generic API" exception handlers!
for|for
control|(
specifier|final
name|Subroutine
name|sub
range|:
name|subroutines
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|sub
operator|!=
name|subroutines
operator|.
name|get
argument_list|(
name|all
index|[
literal|0
index|]
argument_list|)
operator|&&
name|sub
operator|.
name|contains
argument_list|(
name|_protected
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|StructuralCodeConstraintException
argument_list|(
literal|"Subroutine instruction '"
operator|+
name|_protected
operator|+
literal|"' is protected by an exception handler, '"
operator|+
name|handler
operator|+
literal|"'. This is forbidden by the JustIce verifier due to its clear definition of subroutines."
argument_list|)
throw|;
block|}
block|}
name|_protected
operator|=
name|_protected
operator|.
name|getNext
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Now make sure no subroutine is calling a subroutine
comment|// that uses the same local variable for the RET as themselves
comment|// (recursively).
comment|// This includes that subroutines may not call themselves
comment|// recursively, even not through intermediate calls to other
comment|// subroutines.
name|noRecursiveCalls
argument_list|(
name|getTopLevel
argument_list|()
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the Subroutine object associated with the given leader (that is, the first instruction of the subroutine).      * You must not use this to get the top-level instructions modeled as a Subroutine object.      *      * @see #getTopLevel()      */
specifier|public
name|Subroutine
name|getSubroutine
parameter_list|(
specifier|final
name|InstructionHandle
name|leader
parameter_list|)
block|{
specifier|final
name|Subroutine
name|ret
init|=
name|subroutines
operator|.
name|get
argument_list|(
name|leader
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"Subroutine requested for an InstructionHandle that is not a leader of a subroutine."
argument_list|)
throw|;
block|}
if|if
condition|(
name|ret
operator|==
name|TOPLEVEL
condition|)
block|{
throw|throw
operator|new
name|AssertionViolatedException
argument_list|(
literal|"TOPLEVEL special subroutine requested; use getTopLevel()."
argument_list|)
throw|;
block|}
return|return
name|ret
return|;
block|}
comment|/**      * For easy handling, the piece of code that is<B>not</B> a subroutine, the top-level, is also modeled as a Subroutine      * object. It is a special Subroutine object where<B>you must not invoke getEnteringJsrInstructions() or      * getLeavingRET()</B>.      *      * @see Subroutine#getEnteringJsrInstructions()      * @see Subroutine#getLeavingRET()      */
specifier|public
name|Subroutine
name|getTopLevel
parameter_list|()
block|{
return|return
name|TOPLEVEL
return|;
block|}
comment|/**      * This (recursive) utility method makes sure that no subroutine is calling a subroutine that uses the same local      * variable for the RET as themselves (recursively). This includes that subroutines may not call themselves recursively,      * even not through intermediate calls to other subroutines.      *      * @throws StructuralCodeConstraintException if the above constraint is not satisfied.      */
specifier|private
name|void
name|noRecursiveCalls
parameter_list|(
specifier|final
name|Subroutine
name|sub
parameter_list|,
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|set
parameter_list|)
block|{
specifier|final
name|Subroutine
index|[]
name|subs
init|=
name|sub
operator|.
name|subSubs
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Subroutine
name|sub2
range|:
name|subs
control|)
block|{
specifier|final
name|int
name|index
init|=
operator|(
operator|(
name|RET
operator|)
name|sub2
operator|.
name|getLeavingRET
argument_list|()
operator|.
name|getInstruction
argument_list|()
operator|)
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|set
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
comment|// Don't use toString() here because of possibly infinite recursive subSubs() calls then.
specifier|final
name|SubroutineImpl
name|si
init|=
operator|(
name|SubroutineImpl
operator|)
name|sub2
decl_stmt|;
throw|throw
operator|new
name|StructuralCodeConstraintException
argument_list|(
literal|"Subroutine with local variable '"
operator|+
name|si
operator|.
name|localVariable
operator|+
literal|"', JSRs '"
operator|+
name|si
operator|.
name|theJSRs
operator|+
literal|"', RET '"
operator|+
name|si
operator|.
name|theRET
operator|+
literal|"' is called by a subroutine which uses the same local variable index as itself; maybe even a recursive call?"
operator|+
literal|" JustIce's clean definition of a subroutine forbids both."
argument_list|)
throw|;
block|}
name|noRecursiveCalls
argument_list|(
name|sub2
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|set
operator|.
name|remove
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the subroutine object associated with the given instruction. This is a costly operation, you should consider      * using getSubroutine(InstructionHandle). Returns 'null' if the given InstructionHandle lies in so-called 'dead code',      * i.e. code that can never be executed.      *      * @see #getSubroutine(InstructionHandle)      * @see #getTopLevel()      */
specifier|public
name|Subroutine
name|subroutineOf
parameter_list|(
specifier|final
name|InstructionHandle
name|any
parameter_list|)
block|{
for|for
control|(
specifier|final
name|Subroutine
name|s
range|:
name|subroutines
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|s
operator|.
name|contains
argument_list|(
name|any
argument_list|)
condition|)
block|{
return|return
name|s
return|;
block|}
block|}
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"DEBUG: Please verify '"
operator|+
name|any
operator|.
name|toString
argument_list|(
literal|true
argument_list|)
operator|+
literal|"' lies in dead code."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// throw new AssertionViolatedException("No subroutine for InstructionHandle found (DEAD CODE?).");
block|}
comment|/**      * Returns a String representation of this object; merely for debugging puposes.      */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"---\n"
operator|+
name|subroutines
operator|+
literal|"\n---\n"
return|;
block|}
block|}
end_class

end_unit

