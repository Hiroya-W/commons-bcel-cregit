begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|CharArrayReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|CharArrayWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|AnnotationEntryGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
operator|.
name|ConstantPoolGen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|util
operator|.
name|ByteSequence
import|;
end_import

begin_comment
comment|/**  * Utility functions that do not really belong to any class in particular.  *  * @version $Id$  * @author<A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|Utility
block|{
specifier|private
specifier|static
name|int
name|unwrap
parameter_list|(
name|ThreadLocal
argument_list|<
name|Integer
argument_list|>
name|tl
parameter_list|)
block|{
return|return
name|tl
operator|.
name|get
argument_list|()
operator|.
name|intValue
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|wrap
parameter_list|(
name|ThreadLocal
argument_list|<
name|Integer
argument_list|>
name|tl
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|tl
operator|.
name|set
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|ThreadLocal
argument_list|<
name|Integer
argument_list|>
name|consumed_chars
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Integer
name|initialValue
parameter_list|()
block|{
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/* How many chars have been consumed      * during parsing in signatureToString().      * Read by methodSignatureToString().      * Set by side effect,but only internally.      */
specifier|private
specifier|static
name|boolean
name|wide
init|=
literal|false
decl_stmt|;
comment|/* The `WIDE' instruction is used in the      * byte code to allow 16-bit wide indices      * for local variables. This opcode      * precedes an `ILOAD', e.g.. The opcode      * immediately following takes an extra      * byte which is combined with the      * following byte to form a      * 16-bit value.      */
comment|/**      * Convert bit field of flags into string such as `static final'.      *      * @param  access_flags Access flags      * @return String representation of flags      */
specifier|public
specifier|static
name|String
name|accessToString
parameter_list|(
name|int
name|access_flags
parameter_list|)
block|{
return|return
name|accessToString
argument_list|(
name|access_flags
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Convert bit field of flags into string such as `static final'.      *      * Special case: Classes compiled with new compilers and with the      * `ACC_SUPER' flag would be said to be "synchronized". This is      * because SUN used the same value for the flags `ACC_SUPER' and      * `ACC_SYNCHRONIZED'.       *      * @param  access_flags Access flags      * @param  for_class access flags are for class qualifiers ?      * @return String representation of flags      */
specifier|public
specifier|static
name|String
name|accessToString
parameter_list|(
name|int
name|access_flags
parameter_list|,
name|boolean
name|for_class
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|p
operator|<
name|Constants
operator|.
name|MAX_ACC_FLAG
condition|;
name|i
operator|++
control|)
block|{
comment|// Loop through known flags
name|p
operator|=
name|pow2
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|access_flags
operator|&
name|p
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Special case: Classes compiled with new compilers and with the                  * `ACC_SUPER' flag would be said to be "synchronized". This is                  * because SUN used the same value for the flags `ACC_SUPER' and                  * `ACC_SYNCHRONIZED'.                  */
if|if
condition|(
name|for_class
operator|&&
operator|(
operator|(
name|p
operator|==
name|Constants
operator|.
name|ACC_SUPER
operator|)
operator|||
operator|(
name|p
operator|==
name|Constants
operator|.
name|ACC_INTERFACE
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
name|buf
operator|.
name|append
argument_list|(
name|Constants
operator|.
name|ACCESS_NAMES
index|[
name|i
index|]
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
return|;
block|}
comment|/**      * @param access_flags the class flags      *       * @return "class" or "interface", depending on the ACC_INTERFACE flag      */
specifier|public
specifier|static
name|String
name|classOrInterface
parameter_list|(
name|int
name|access_flags
parameter_list|)
block|{
return|return
operator|(
operator|(
name|access_flags
operator|&
name|Constants
operator|.
name|ACC_INTERFACE
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|"interface"
else|:
literal|"class"
return|;
block|}
comment|/**      * Disassemble a byte array of JVM byte codes starting from code line       * `index' and return the disassembled string representation. Decode only      * `num' opcodes (including their operands), use -1 if you want to      * decompile everything.      *      * @param  code byte code array      * @param  constant_pool Array of constants      * @param  index offset in `code' array      *<EM>(number of opcodes, not bytes!)</EM>      * @param  length number of opcodes to decompile, -1 for all      * @param  verbose be verbose, e.g. print constant pool index      * @return String representation of byte codes      */
specifier|public
specifier|static
name|String
name|codeToString
parameter_list|(
name|byte
index|[]
name|code
parameter_list|,
name|ConstantPool
name|constant_pool
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|verbose
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
name|code
operator|.
name|length
operator|*
literal|20
argument_list|)
decl_stmt|;
comment|// Should be sufficient
name|ByteSequence
name|stream
init|=
operator|new
name|ByteSequence
argument_list|(
name|code
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|index
condition|;
name|i
operator|++
control|)
block|{
name|codeToString
argument_list|(
name|stream
argument_list|,
name|constant_pool
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|stream
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|length
operator|<
literal|0
operator|)
operator|||
operator|(
name|i
operator|<
name|length
operator|)
condition|)
block|{
name|String
name|indices
init|=
name|fillup
argument_list|(
name|stream
operator|.
name|getIndex
argument_list|()
operator|+
literal|":"
argument_list|,
literal|6
argument_list|,
literal|true
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|indices
argument_list|)
operator|.
name|append
argument_list|(
name|codeToString
argument_list|(
name|stream
argument_list|,
name|constant_pool
argument_list|,
name|verbose
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Byte code error: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|String
name|codeToString
parameter_list|(
name|byte
index|[]
name|code
parameter_list|,
name|ConstantPool
name|constant_pool
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|codeToString
argument_list|(
name|code
argument_list|,
name|constant_pool
argument_list|,
name|index
argument_list|,
name|length
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Disassemble a stream of byte codes and return the      * string representation.      *      * @param  bytes stream of bytes      * @param  constant_pool Array of constants      * @param  verbose be verbose, e.g. print constant pool index      * @return String representation of byte code      *       * @throws IOException if a failure from reading from the bytes argument occurs      */
specifier|public
specifier|static
name|String
name|codeToString
parameter_list|(
name|ByteSequence
name|bytes
parameter_list|,
name|ConstantPool
name|constant_pool
parameter_list|,
name|boolean
name|verbose
parameter_list|)
throws|throws
name|IOException
block|{
name|short
name|opcode
init|=
operator|(
name|short
operator|)
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
decl_stmt|;
name|int
name|default_offset
init|=
literal|0
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|,
name|npairs
decl_stmt|;
name|int
name|index
decl_stmt|,
name|vindex
decl_stmt|,
name|constant
decl_stmt|;
name|int
index|[]
name|match
decl_stmt|,
name|jump_table
decl_stmt|;
name|int
name|no_pad_bytes
init|=
literal|0
decl_stmt|,
name|offset
decl_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
name|Constants
operator|.
name|OPCODE_NAMES
index|[
name|opcode
index|]
argument_list|)
decl_stmt|;
comment|/* Special case: Skip (0-3) padding bytes, i.e., the          * following bytes are 4-byte-aligned          */
if|if
condition|(
operator|(
name|opcode
operator|==
name|Constants
operator|.
name|TABLESWITCH
operator|)
operator|||
operator|(
name|opcode
operator|==
name|Constants
operator|.
name|LOOKUPSWITCH
operator|)
condition|)
block|{
name|int
name|remainder
init|=
name|bytes
operator|.
name|getIndex
argument_list|()
operator|%
literal|4
decl_stmt|;
name|no_pad_bytes
operator|=
operator|(
name|remainder
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|4
operator|-
name|remainder
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|no_pad_bytes
condition|;
name|i
operator|++
control|)
block|{
name|byte
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|bytes
operator|.
name|readByte
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Warning: Padding byte != 0 in "
operator|+
name|Constants
operator|.
name|OPCODE_NAMES
index|[
name|opcode
index|]
operator|+
literal|":"
operator|+
name|b
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Both cases have a field default_offset in common
name|default_offset
operator|=
name|bytes
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|opcode
condition|)
block|{
comment|/* Table switch has variable length arguments.              */
case|case
name|Constants
operator|.
name|TABLESWITCH
case|:
name|low
operator|=
name|bytes
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|high
operator|=
name|bytes
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|offset
operator|=
name|bytes
operator|.
name|getIndex
argument_list|()
operator|-
literal|12
operator|-
name|no_pad_bytes
operator|-
literal|1
expr_stmt|;
name|default_offset
operator|+=
name|offset
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\tdefault = "
argument_list|)
operator|.
name|append
argument_list|(
name|default_offset
argument_list|)
operator|.
name|append
argument_list|(
literal|", low = "
argument_list|)
operator|.
name|append
argument_list|(
name|low
argument_list|)
operator|.
name|append
argument_list|(
literal|", high = "
argument_list|)
operator|.
name|append
argument_list|(
name|high
argument_list|)
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|jump_table
operator|=
operator|new
name|int
index|[
name|high
operator|-
name|low
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|jump_table
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|jump_table
index|[
name|i
index|]
operator|=
name|offset
operator|+
name|bytes
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|jump_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|jump_table
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
break|break;
comment|/* Lookup switch has variable length arguments.              */
case|case
name|Constants
operator|.
name|LOOKUPSWITCH
case|:
block|{
name|npairs
operator|=
name|bytes
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|offset
operator|=
name|bytes
operator|.
name|getIndex
argument_list|()
operator|-
literal|8
operator|-
name|no_pad_bytes
operator|-
literal|1
expr_stmt|;
name|match
operator|=
operator|new
name|int
index|[
name|npairs
index|]
expr_stmt|;
name|jump_table
operator|=
operator|new
name|int
index|[
name|npairs
index|]
expr_stmt|;
name|default_offset
operator|+=
name|offset
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\tdefault = "
argument_list|)
operator|.
name|append
argument_list|(
name|default_offset
argument_list|)
operator|.
name|append
argument_list|(
literal|", npairs = "
argument_list|)
operator|.
name|append
argument_list|(
name|npairs
argument_list|)
operator|.
name|append
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|npairs
condition|;
name|i
operator|++
control|)
block|{
name|match
index|[
name|i
index|]
operator|=
name|bytes
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|jump_table
index|[
name|i
index|]
operator|=
name|offset
operator|+
name|bytes
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
operator|.
name|append
argument_list|(
name|match
index|[
name|i
index|]
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|jump_table
index|[
name|i
index|]
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|npairs
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Two address bytes + offset from start of byte stream form the              * jump target              */
case|case
name|Constants
operator|.
name|GOTO
case|:
case|case
name|Constants
operator|.
name|IFEQ
case|:
case|case
name|Constants
operator|.
name|IFGE
case|:
case|case
name|Constants
operator|.
name|IFGT
case|:
case|case
name|Constants
operator|.
name|IFLE
case|:
case|case
name|Constants
operator|.
name|IFLT
case|:
case|case
name|Constants
operator|.
name|JSR
case|:
case|case
name|Constants
operator|.
name|IFNE
case|:
case|case
name|Constants
operator|.
name|IFNONNULL
case|:
case|case
name|Constants
operator|.
name|IFNULL
case|:
case|case
name|Constants
operator|.
name|IF_ACMPEQ
case|:
case|case
name|Constants
operator|.
name|IF_ACMPNE
case|:
case|case
name|Constants
operator|.
name|IF_ICMPEQ
case|:
case|case
name|Constants
operator|.
name|IF_ICMPGE
case|:
case|case
name|Constants
operator|.
name|IF_ICMPGT
case|:
case|case
name|Constants
operator|.
name|IF_ICMPLE
case|:
case|case
name|Constants
operator|.
name|IF_ICMPLT
case|:
case|case
name|Constants
operator|.
name|IF_ICMPNE
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t#"
argument_list|)
operator|.
name|append
argument_list|(
operator|(
name|bytes
operator|.
name|getIndex
argument_list|()
operator|-
literal|1
operator|)
operator|+
name|bytes
operator|.
name|readShort
argument_list|()
argument_list|)
expr_stmt|;
break|break;
comment|/* 32-bit wide jumps              */
case|case
name|Constants
operator|.
name|GOTO_W
case|:
case|case
name|Constants
operator|.
name|JSR_W
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t#"
argument_list|)
operator|.
name|append
argument_list|(
operator|(
operator|(
name|bytes
operator|.
name|getIndex
argument_list|()
operator|-
literal|1
operator|)
operator|+
name|bytes
operator|.
name|readInt
argument_list|()
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Index byte references local variable (register)              */
case|case
name|Constants
operator|.
name|ALOAD
case|:
case|case
name|Constants
operator|.
name|ASTORE
case|:
case|case
name|Constants
operator|.
name|DLOAD
case|:
case|case
name|Constants
operator|.
name|DSTORE
case|:
case|case
name|Constants
operator|.
name|FLOAD
case|:
case|case
name|Constants
operator|.
name|FSTORE
case|:
case|case
name|Constants
operator|.
name|ILOAD
case|:
case|case
name|Constants
operator|.
name|ISTORE
case|:
case|case
name|Constants
operator|.
name|LLOAD
case|:
case|case
name|Constants
operator|.
name|LSTORE
case|:
case|case
name|Constants
operator|.
name|RET
case|:
if|if
condition|(
name|wide
condition|)
block|{
name|vindex
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|wide
operator|=
literal|false
expr_stmt|;
comment|// Clear flag
block|}
else|else
block|{
name|vindex
operator|=
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t%"
argument_list|)
operator|.
name|append
argument_list|(
name|vindex
argument_list|)
expr_stmt|;
break|break;
comment|/*              * Remember wide byte which is used to form a 16-bit address in the              * following instruction. Relies on that the method is called again with              * the following opcode.              */
case|case
name|Constants
operator|.
name|WIDE
case|:
name|wide
operator|=
literal|true
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t(wide)"
argument_list|)
expr_stmt|;
break|break;
comment|/* Array of basic type.              */
case|case
name|Constants
operator|.
name|NEWARRAY
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t<"
argument_list|)
operator|.
name|append
argument_list|(
name|Constants
operator|.
name|TYPE_NAMES
index|[
name|bytes
operator|.
name|readByte
argument_list|()
index|]
argument_list|)
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
break|break;
comment|/* Access object/class fields.              */
case|case
name|Constants
operator|.
name|GETFIELD
case|:
case|case
name|Constants
operator|.
name|GETSTATIC
case|:
case|case
name|Constants
operator|.
name|PUTFIELD
case|:
case|case
name|Constants
operator|.
name|PUTSTATIC
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t"
argument_list|)
operator|.
name|append
argument_list|(
name|constant_pool
operator|.
name|constantToString
argument_list|(
name|index
argument_list|,
name|Constants
operator|.
name|CONSTANT_Fieldref
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
operator|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Operands are references to classes in constant pool              */
case|case
name|Constants
operator|.
name|NEW
case|:
case|case
name|Constants
operator|.
name|CHECKCAST
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
comment|//$FALL-THROUGH$
case|case
name|Constants
operator|.
name|INSTANCEOF
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t<"
argument_list|)
operator|.
name|append
argument_list|(
name|constant_pool
operator|.
name|constantToString
argument_list|(
name|index
argument_list|,
name|Constants
operator|.
name|CONSTANT_Class
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
operator|.
name|append
argument_list|(
operator|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Operands are references to methods in constant pool              */
case|case
name|Constants
operator|.
name|INVOKESPECIAL
case|:
case|case
name|Constants
operator|.
name|INVOKESTATIC
case|:
case|case
name|Constants
operator|.
name|INVOKEVIRTUAL
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|Constant
name|c
init|=
name|constant_pool
operator|.
name|getConstant
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|getTag
argument_list|()
operator|!=
name|Constants
operator|.
name|CONSTANT_Methodref
operator|&&
name|c
operator|.
name|getTag
argument_list|()
operator|!=
name|Constants
operator|.
name|CONSTANT_InterfaceMethodref
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Expected class `CONSTANT_Methodref' or 'CONSTANT_InterfaceMethodref' at index "
operator|+
name|index
operator|+
literal|" and got "
operator|+
name|c
argument_list|)
throw|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|constant_pool
operator|.
name|constantToString
argument_list|(
name|c
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
operator|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|INVOKEINTERFACE
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|int
name|nargs
init|=
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
decl_stmt|;
comment|// historical, redundant
name|buf
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|constant_pool
operator|.
name|constantToString
argument_list|(
name|index
argument_list|,
name|Constants
operator|.
name|CONSTANT_InterfaceMethodref
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")\t"
else|:
literal|""
argument_list|)
operator|.
name|append
argument_list|(
name|nargs
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
argument_list|)
expr_stmt|;
comment|// Last byte is a reserved space
break|break;
case|case
name|Constants
operator|.
name|INVOKEDYNAMIC
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|int
name|ignored
init|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
decl_stmt|;
name|ConstantInvokeDynamic
name|id
init|=
operator|(
name|ConstantInvokeDynamic
operator|)
name|constant_pool
operator|.
name|getConstant
argument_list|(
name|index
argument_list|,
name|Constants
operator|.
name|CONSTANT_InvokeDynamic
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
literal|"<dyn>."
argument_list|)
operator|.
name|append
argument_list|(
name|constant_pool
operator|.
name|constantToString
argument_list|(
name|id
operator|.
name|getNameAndTypeIndex
argument_list|()
argument_list|,
name|Constants
operator|.
name|CONSTANT_NameAndType
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" ("
operator|+
name|index
operator|+
literal|"/"
operator|+
name|id
operator|.
name|getNameAndTypeIndex
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Operands are references to items in constant pool              */
case|case
name|Constants
operator|.
name|LDC_W
case|:
case|case
name|Constants
operator|.
name|LDC2_W
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t"
argument_list|)
operator|.
name|append
argument_list|(
name|constant_pool
operator|.
name|constantToString
argument_list|(
name|index
argument_list|,
name|constant_pool
operator|.
name|getConstant
argument_list|(
name|index
argument_list|)
operator|.
name|getTag
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
operator|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|LDC
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t"
argument_list|)
operator|.
name|append
argument_list|(
name|constant_pool
operator|.
name|constantToString
argument_list|(
name|index
argument_list|,
name|constant_pool
operator|.
name|getConstant
argument_list|(
name|index
argument_list|)
operator|.
name|getTag
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
operator|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Array of references.              */
case|case
name|Constants
operator|.
name|ANEWARRAY
case|:
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t<"
argument_list|)
operator|.
name|append
argument_list|(
name|compactClassName
argument_list|(
name|constant_pool
operator|.
name|getConstantString
argument_list|(
name|index
argument_list|,
name|Constants
operator|.
name|CONSTANT_Class
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
operator|.
name|append
argument_list|(
operator|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Multidimensional array of references.              */
case|case
name|Constants
operator|.
name|MULTIANEWARRAY
case|:
block|{
name|index
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|int
name|dimensions
init|=
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"\t<"
argument_list|)
operator|.
name|append
argument_list|(
name|compactClassName
argument_list|(
name|constant_pool
operator|.
name|getConstantString
argument_list|(
name|index
argument_list|,
name|Constants
operator|.
name|CONSTANT_Class
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|">\t"
argument_list|)
operator|.
name|append
argument_list|(
name|dimensions
argument_list|)
operator|.
name|append
argument_list|(
operator|(
name|verbose
condition|?
literal|" ("
operator|+
name|index
operator|+
literal|")"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Increment local variable.              */
case|case
name|Constants
operator|.
name|IINC
case|:
if|if
condition|(
name|wide
condition|)
block|{
name|vindex
operator|=
name|bytes
operator|.
name|readUnsignedShort
argument_list|()
expr_stmt|;
name|constant
operator|=
name|bytes
operator|.
name|readShort
argument_list|()
expr_stmt|;
name|wide
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|vindex
operator|=
name|bytes
operator|.
name|readUnsignedByte
argument_list|()
expr_stmt|;
name|constant
operator|=
name|bytes
operator|.
name|readByte
argument_list|()
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t%"
argument_list|)
operator|.
name|append
argument_list|(
name|vindex
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|constant
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|Constants
operator|.
name|NO_OF_OPERANDS
index|[
name|opcode
index|]
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Constants
operator|.
name|TYPE_OF_OPERANDS
index|[
name|opcode
index|]
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"\t\t"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Constants
operator|.
name|TYPE_OF_OPERANDS
index|[
name|opcode
index|]
index|[
name|i
index|]
condition|)
block|{
case|case
name|Constants
operator|.
name|T_BYTE
case|:
name|buf
operator|.
name|append
argument_list|(
name|bytes
operator|.
name|readByte
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|T_SHORT
case|:
name|buf
operator|.
name|append
argument_list|(
name|bytes
operator|.
name|readShort
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|T_INT
case|:
name|buf
operator|.
name|append
argument_list|(
name|bytes
operator|.
name|readInt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Never reached
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Unreachable default case reached!"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|String
name|codeToString
parameter_list|(
name|ByteSequence
name|bytes
parameter_list|,
name|ConstantPool
name|constant_pool
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|codeToString
argument_list|(
name|bytes
argument_list|,
name|constant_pool
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Shorten long class names,<em>java/lang/String</em> becomes       *<em>String</em>.      *      * @param str The long class name      * @return Compacted class name      */
specifier|public
specifier|static
name|String
name|compactClassName
parameter_list|(
name|String
name|str
parameter_list|)
block|{
return|return
name|compactClassName
argument_list|(
name|str
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Shorten long class name<em>str</em>, i.e., chop off the<em>prefix</em>,      * if the      * class name starts with this string and the flag<em>chopit</em> is true.      * Slashes<em>/</em> are converted to dots<em>.</em>.      *      * @param str The long class name      * @param prefix The prefix the get rid off      * @param chopit Flag that determines whether chopping is executed or not      * @return Compacted class name      */
specifier|public
specifier|static
name|String
name|compactClassName
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|prefix
parameter_list|,
name|boolean
name|chopit
parameter_list|)
block|{
name|int
name|len
init|=
name|prefix
operator|.
name|length
argument_list|()
decl_stmt|;
name|str
operator|=
name|str
operator|.
name|replace
argument_list|(
literal|'/'
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
comment|// Is `/' on all systems, even DOS
if|if
condition|(
name|chopit
condition|)
block|{
comment|// If string starts with `prefix' and contains no further dots
if|if
condition|(
name|str
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
operator|&&
operator|(
name|str
operator|.
name|substring
argument_list|(
name|len
argument_list|)
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|str
operator|=
name|str
operator|.
name|substring
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|str
return|;
block|}
comment|/**      * Shorten long class names,<em>java/lang/String</em> becomes       *<em>java.lang.String</em>,      * e.g.. If<em>chopit</em> is<em>true</em> the prefix<em>java.lang</em>      * is also removed.      *      * @param str The long class name      * @param chopit Flag that determines whether chopping is executed or not      * @return Compacted class name      */
specifier|public
specifier|static
name|String
name|compactClassName
parameter_list|(
name|String
name|str
parameter_list|,
name|boolean
name|chopit
parameter_list|)
block|{
return|return
name|compactClassName
argument_list|(
name|str
argument_list|,
literal|"java.lang."
argument_list|,
name|chopit
argument_list|)
return|;
block|}
comment|/**      * @return `flag' with bit `i' set to 1      */
specifier|public
specifier|static
name|int
name|setBit
parameter_list|(
name|int
name|flag
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
name|flag
operator||
name|pow2
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/**      * @return `flag' with bit `i' set to 0      */
specifier|public
specifier|static
name|int
name|clearBit
parameter_list|(
name|int
name|flag
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|int
name|bit
init|=
name|pow2
argument_list|(
name|i
argument_list|)
decl_stmt|;
return|return
operator|(
name|flag
operator|&
name|bit
operator|)
operator|==
literal|0
condition|?
name|flag
else|:
name|flag
operator|^
name|bit
return|;
block|}
comment|/**      * @return true, if bit `i' in `flag' is set      */
specifier|public
specifier|static
name|boolean
name|isSet
parameter_list|(
name|int
name|flag
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|flag
operator|&
name|pow2
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
literal|0
return|;
block|}
comment|/**      * Converts string containing the method return and argument types       * to a byte code method signature.      *      * @param  ret Return type of method      * @param  argv Types of method arguments      * @return Byte code representation of method signature      *       * @throws ClassFormatException if the signature is for Void      */
specifier|public
specifier|static
name|String
name|methodTypeToSignature
parameter_list|(
name|String
name|ret
parameter_list|,
name|String
index|[]
name|argv
parameter_list|)
throws|throws
name|ClassFormatException
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"("
argument_list|)
decl_stmt|;
name|String
name|str
decl_stmt|;
if|if
condition|(
name|argv
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|element
range|:
name|argv
control|)
block|{
name|str
operator|=
name|getSignature
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|endsWith
argument_list|(
literal|"V"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid type: "
operator|+
name|element
argument_list|)
throw|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
name|str
operator|=
name|getSignature
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
operator|.
name|append
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * @param  signature    Method signature      * @return Array of argument types      * @throws  ClassFormatException        */
specifier|public
specifier|static
name|String
index|[]
name|methodSignatureArgumentTypes
parameter_list|(
name|String
name|signature
parameter_list|)
throws|throws
name|ClassFormatException
block|{
return|return
name|methodSignatureArgumentTypes
argument_list|(
name|signature
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * @param  signature    Method signature      * @param chopit Shorten class names ?      * @return Array of argument types      * @throws  ClassFormatException        */
specifier|public
specifier|static
name|String
index|[]
name|methodSignatureArgumentTypes
parameter_list|(
name|String
name|signature
parameter_list|,
name|boolean
name|chopit
parameter_list|)
throws|throws
name|ClassFormatException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|vec
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|index
decl_stmt|;
try|try
block|{
comment|// Read all declarations between for `(' and `)'
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'('
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid method signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
name|index
operator|=
literal|1
expr_stmt|;
comment|// current string position
while|while
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|!=
literal|')'
condition|)
block|{
name|vec
operator|.
name|add
argument_list|(
name|signatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
argument_list|)
expr_stmt|;
comment|//corrected concurrent private static field acess
name|index
operator|+=
name|unwrap
argument_list|(
name|consumed_chars
argument_list|)
expr_stmt|;
comment|// update position
block|}
block|}
catch|catch
parameter_list|(
name|StringIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// Should never occur
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid method signature: "
operator|+
name|signature
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|vec
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|vec
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * @param  signature    Method signature      * @return return type of method      * @throws  ClassFormatException        */
specifier|public
specifier|static
name|String
name|methodSignatureReturnType
parameter_list|(
name|String
name|signature
parameter_list|)
throws|throws
name|ClassFormatException
block|{
return|return
name|methodSignatureReturnType
argument_list|(
name|signature
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * @param  signature    Method signature      * @param chopit Shorten class names ?      * @return return type of method      * @throws  ClassFormatException        */
specifier|public
specifier|static
name|String
name|methodSignatureReturnType
parameter_list|(
name|String
name|signature
parameter_list|,
name|boolean
name|chopit
parameter_list|)
throws|throws
name|ClassFormatException
block|{
name|int
name|index
decl_stmt|;
name|String
name|type
decl_stmt|;
try|try
block|{
comment|// Read return type after `)'
name|index
operator|=
name|signature
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|type
operator|=
name|signatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StringIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// Should never occur
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid method signature: "
operator|+
name|signature
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|type
return|;
block|}
comment|/**      * Converts method signature to string with all class names compacted.      *      * @param signature to convert      * @param name of method      * @param access flags of method      * @return Human readable signature      */
specifier|public
specifier|static
name|String
name|methodSignatureToString
parameter_list|(
name|String
name|signature
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|access
parameter_list|)
block|{
return|return
name|methodSignatureToString
argument_list|(
name|signature
argument_list|,
name|name
argument_list|,
name|access
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|methodSignatureToString
parameter_list|(
name|String
name|signature
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|access
parameter_list|,
name|boolean
name|chopit
parameter_list|)
block|{
return|return
name|methodSignatureToString
argument_list|(
name|signature
argument_list|,
name|name
argument_list|,
name|access
argument_list|,
name|chopit
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * A returntype signature represents the return value from a method.      * It is a series of bytes in the following grammar:      *      *<pre>      *&lt;return_signature&gt; ::=&lt;field_type&gt; | V      *</pre>      *      * The character V indicates that the method returns no value. Otherwise, the      * signature indicates the type of the return value.      * An argument signature represents an argument passed to a method:      *      *<pre>      *&lt;argument_signature&gt; ::=&lt;field_type&gt;      *</pre>      *      * A method signature represents the arguments that the method expects, and      * the value that it returns.      *<pre>      *&lt;method_signature&gt; ::= (&lt;arguments_signature&gt;)&lt;return_signature&gt;      *&lt;arguments_signature&gt;::=&lt;argument_signature&gt;*      *</pre>      *      * This method converts such a string into a Java type declaration like      * `void main(String[])' and throws a `ClassFormatException' when the parsed       * type is invalid.      *      * @param  signature    Method signature      * @param  name         Method name      * @param  access       Method access rights      * @param chopit      * @param vars      * @return Java type declaration      * @throws  ClassFormatException        */
specifier|public
specifier|static
name|String
name|methodSignatureToString
parameter_list|(
name|String
name|signature
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|access
parameter_list|,
name|boolean
name|chopit
parameter_list|,
name|LocalVariableTable
name|vars
parameter_list|)
throws|throws
name|ClassFormatException
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"("
argument_list|)
decl_stmt|;
name|String
name|type
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|var_index
init|=
name|access
operator|.
name|contains
argument_list|(
literal|"static"
argument_list|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
try|try
block|{
comment|// Read all declarations between for `(' and `)'
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'('
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid method signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
name|index
operator|=
literal|1
expr_stmt|;
comment|// current string position
while|while
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|!=
literal|')'
condition|)
block|{
name|String
name|param_type
init|=
name|signatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|param_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|!=
literal|null
condition|)
block|{
name|LocalVariable
name|l
init|=
name|vars
operator|.
name|getLocalVariable
argument_list|(
name|var_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|l
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" arg"
argument_list|)
operator|.
name|append
argument_list|(
name|var_index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"double"
operator|.
name|equals
argument_list|(
name|param_type
argument_list|)
operator|||
literal|"long"
operator|.
name|equals
argument_list|(
name|param_type
argument_list|)
condition|)
block|{
name|var_index
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|var_index
operator|++
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
comment|//corrected concurrent private static field acess
name|index
operator|+=
name|unwrap
argument_list|(
name|consumed_chars
argument_list|)
expr_stmt|;
comment|// update position
block|}
name|index
operator|++
expr_stmt|;
comment|// update position
comment|// Read return type after `)'
name|type
operator|=
name|signatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|StringIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// Should never occur
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid method signature: "
operator|+
name|signature
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|buf
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|buf
operator|.
name|setLength
argument_list|(
name|buf
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|access
operator|+
operator|(
operator|(
name|access
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
condition|?
literal|" "
else|:
literal|""
operator|)
operator|+
comment|// May be an empty string
name|type
operator|+
literal|" "
operator|+
name|name
operator|+
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|// Guess what this does
specifier|private
specifier|static
name|int
name|pow2
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
literal|1
operator|<<
name|n
return|;
block|}
comment|/**      * Replace all occurrences of<em>old</em> in<em>str</em> with<em>new</em>.      *      * @param str String to permute      * @param old String to be replaced      * @param new_ Replacement string      * @return new String object      */
specifier|public
specifier|static
name|String
name|replace
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|old
parameter_list|,
name|String
name|new_
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|old_index
decl_stmt|;
try|try
block|{
if|if
condition|(
name|str
operator|.
name|contains
argument_list|(
name|old
argument_list|)
condition|)
block|{
comment|// `old' found in str
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|old_index
operator|=
literal|0
expr_stmt|;
comment|// String start offset
comment|// While we have something to replace
while|while
condition|(
operator|(
name|index
operator|=
name|str
operator|.
name|indexOf
argument_list|(
name|old
argument_list|,
name|old_index
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|old_index
argument_list|,
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|// append prefix
name|buf
operator|.
name|append
argument_list|(
name|new_
argument_list|)
expr_stmt|;
comment|// append replacement
name|old_index
operator|=
name|index
operator|+
name|old
operator|.
name|length
argument_list|()
expr_stmt|;
comment|// Skip `old'.length chars
block|}
name|buf
operator|.
name|append
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|old_index
argument_list|)
argument_list|)
expr_stmt|;
comment|// append rest of string
name|str
operator|=
name|buf
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|StringIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// Should not occur
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
comment|/**      * Converts signature to string with all class names compacted.      *      * @param signature to convert      * @return Human readable signature      */
specifier|public
specifier|static
name|String
name|signatureToString
parameter_list|(
name|String
name|signature
parameter_list|)
block|{
return|return
name|signatureToString
argument_list|(
name|signature
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * The field signature represents the value of an argument to a function or       * the value of a variable. It is a series of bytes generated by the       * following grammar:      *      *<PRE>      *&lt;field_signature&gt; ::=&lt;field_type&gt;      *&lt;field_type&gt;      ::=&lt;base_type&gt;|&lt;object_type&gt;|&lt;array_type&gt;      *&lt;base_type&gt;       ::= B|C|D|F|I|J|S|Z      *&lt;object_type&gt;     ::= L&lt;fullclassname&gt;;      *&lt;array_type&gt;      ::= [&lt;field_type&gt;      *      * The meaning of the base types is as follows:      * B byte signed byte      * C char character      * D double double precision IEEE float      * F float single precision IEEE float      * I int integer      * J long long integer      * L&lt;fullclassname&gt;; ... an object of the given class      * S short signed short      * Z boolean true or false      * [&lt;field sig&gt; ... array      *</PRE>      *      * This method converts this string into a Java type declaration such as      * `String[]' and throws a `ClassFormatException' when the parsed type is       * invalid.      *      * @param  signature  Class signature      * @param chopit Flag that determines whether chopping is executed or not      * @return Java type declaration      * @throws ClassFormatException      */
specifier|public
specifier|static
name|String
name|signatureToString
parameter_list|(
name|String
name|signature
parameter_list|,
name|boolean
name|chopit
parameter_list|)
block|{
comment|//corrected concurrent private static field acess
name|wrap
argument_list|(
name|consumed_chars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// This is the default, read just one char like `B'
try|try
block|{
switch|switch
condition|(
name|signature
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
literal|'B'
case|:
return|return
literal|"byte"
return|;
case|case
literal|'C'
case|:
return|return
literal|"char"
return|;
case|case
literal|'D'
case|:
return|return
literal|"double"
return|;
case|case
literal|'F'
case|:
return|return
literal|"float"
return|;
case|case
literal|'I'
case|:
return|return
literal|"int"
return|;
case|case
literal|'J'
case|:
return|return
literal|"long"
return|;
case|case
literal|'T'
case|:
block|{
comment|// TypeVariableSignature
name|int
name|index
init|=
name|signature
operator|.
name|indexOf
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
comment|// Look for closing `;'
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
comment|//corrected concurrent private static field acess
name|wrap
argument_list|(
name|consumed_chars
argument_list|,
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// "Tblabla;" `T' and `;' are removed
return|return
name|compactClassName
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
return|;
block|}
case|case
literal|'L'
case|:
block|{
comment|// Full class name
name|int
name|index
init|=
name|signature
operator|.
name|indexOf
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
comment|// Look for closing `;'
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
comment|// check to see if there are any TypeArguments
name|int
name|bracketIndex
init|=
name|signature
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
operator|.
name|indexOf
argument_list|(
literal|'<'
argument_list|)
decl_stmt|;
if|if
condition|(
name|bracketIndex
operator|<
literal|0
condition|)
block|{
comment|// just a class identifier
name|wrap
argument_list|(
name|consumed_chars
argument_list|,
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// "Lblabla;" `L' and `;' are removed
return|return
name|compactClassName
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|index
argument_list|)
argument_list|,
name|chopit
argument_list|)
return|;
block|}
comment|// we have TypeArguments; build up partial result
comment|// as we recurse for each TypeArgument
name|String
name|type
init|=
name|compactClassName
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|bracketIndex
argument_list|)
argument_list|,
name|chopit
argument_list|)
operator|+
literal|"<"
decl_stmt|;
name|int
name|consumed_chars
init|=
name|bracketIndex
operator|+
literal|1
decl_stmt|;
comment|// Shadows global var
comment|// check for wildcards
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumed_chars
argument_list|)
operator|==
literal|'+'
condition|)
block|{
name|type
operator|=
name|type
operator|+
literal|"? extends "
expr_stmt|;
name|consumed_chars
operator|=
operator|++
name|consumed_chars
expr_stmt|;
block|}
if|else if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumed_chars
argument_list|)
operator|==
literal|'-'
condition|)
block|{
name|type
operator|=
name|type
operator|+
literal|"? super "
expr_stmt|;
name|consumed_chars
operator|=
operator|++
name|consumed_chars
expr_stmt|;
block|}
if|else if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumed_chars
argument_list|)
operator|==
literal|'*'
condition|)
block|{
comment|// must be at end of signature
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumed_chars
operator|+
literal|1
argument_list|)
operator|!=
literal|'>'
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumed_chars
operator|+
literal|2
argument_list|)
operator|!=
literal|';'
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
name|wrap
argument_list|(
name|Utility
operator|.
name|consumed_chars
argument_list|,
name|consumed_chars
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|// remove final "*>;"
return|return
name|type
operator|+
literal|"?>..."
return|;
block|}
comment|// get the first TypeArgument
name|type
operator|=
name|type
operator|+
name|signatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|consumed_chars
argument_list|)
argument_list|,
name|chopit
argument_list|)
expr_stmt|;
comment|// update our consumed count by the number of characters the for type argument
name|consumed_chars
operator|=
name|unwrap
argument_list|(
name|Utility
operator|.
name|consumed_chars
argument_list|)
operator|+
name|consumed_chars
expr_stmt|;
name|wrap
argument_list|(
name|Utility
operator|.
name|consumed_chars
argument_list|,
name|consumed_chars
argument_list|)
expr_stmt|;
comment|// are there more TypeArguments?
while|while
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumed_chars
argument_list|)
operator|!=
literal|'>'
condition|)
block|{
name|type
operator|=
name|type
operator|+
literal|", "
operator|+
name|signatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|consumed_chars
argument_list|)
argument_list|,
name|chopit
argument_list|)
expr_stmt|;
comment|// update our consumed count by the number of characters the for type argument
name|consumed_chars
operator|=
name|unwrap
argument_list|(
name|Utility
operator|.
name|consumed_chars
argument_list|)
operator|+
name|consumed_chars
expr_stmt|;
name|wrap
argument_list|(
name|Utility
operator|.
name|consumed_chars
argument_list|,
name|consumed_chars
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
name|consumed_chars
operator|+
literal|1
argument_list|)
operator|!=
literal|';'
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
name|wrap
argument_list|(
name|Utility
operator|.
name|consumed_chars
argument_list|,
name|consumed_chars
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|// remove final ">;"
return|return
name|type
operator|+
literal|">"
return|;
block|}
case|case
literal|'S'
case|:
return|return
literal|"short"
return|;
case|case
literal|'Z'
case|:
return|return
literal|"boolean"
return|;
case|case
literal|'['
case|:
block|{
comment|// Array declaration
name|int
name|n
decl_stmt|;
name|StringBuilder
name|brackets
decl_stmt|;
name|String
name|type
decl_stmt|;
name|int
name|consumed_chars
decl_stmt|;
comment|// Shadows global var
name|brackets
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
comment|// Accumulate []'s
comment|// Count opening brackets and look for optional size argument
for|for
control|(
name|n
operator|=
literal|0
init|;
name|signature
operator|.
name|charAt
argument_list|(
name|n
argument_list|)
operator|==
literal|'['
condition|;
name|n
operator|++
control|)
block|{
name|brackets
operator|.
name|append
argument_list|(
literal|"[]"
argument_list|)
expr_stmt|;
block|}
name|consumed_chars
operator|=
name|n
expr_stmt|;
comment|// Remember value
comment|// The rest of the string denotes a `<field_type>'
name|type
operator|=
name|signatureToString
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|n
argument_list|)
argument_list|,
name|chopit
argument_list|)
expr_stmt|;
comment|//corrected concurrent private static field acess
comment|//Utility.consumed_chars += consumed_chars; is replaced by:
name|int
name|_temp
init|=
name|unwrap
argument_list|(
name|Utility
operator|.
name|consumed_chars
argument_list|)
operator|+
name|consumed_chars
decl_stmt|;
name|wrap
argument_list|(
name|Utility
operator|.
name|consumed_chars
argument_list|,
name|_temp
argument_list|)
expr_stmt|;
return|return
name|type
operator|+
name|brackets
operator|.
name|toString
argument_list|()
return|;
block|}
case|case
literal|'V'
case|:
return|return
literal|"void"
return|;
default|default:
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid signature: `"
operator|+
name|signature
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|StringIndexOutOfBoundsException
name|e
parameter_list|)
block|{
comment|// Should never occur
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid signature: "
operator|+
name|signature
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Parse Java type such as "char", or "java.lang.String[]" and return the      * signature in byte code format, e.g. "C" or "[Ljava/lang/String;" respectively.      *      * @param  type Java type      * @return byte code signature      */
specifier|public
specifier|static
name|String
name|getSignature
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|char
index|[]
name|chars
init|=
name|type
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|boolean
name|char_found
init|=
literal|false
decl_stmt|,
name|delim
init|=
literal|false
decl_stmt|;
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|loop
label|:
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|chars
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|chars
index|[
name|i
index|]
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\f'
case|:
if|if
condition|(
name|char_found
condition|)
block|{
name|delim
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
literal|'['
case|:
if|if
condition|(
operator|!
name|char_found
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Illegal type: "
operator|+
name|type
argument_list|)
throw|;
block|}
name|index
operator|=
name|i
expr_stmt|;
break|break
name|loop
break|;
default|default:
name|char_found
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|delim
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|chars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|int
name|brackets
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|index
operator|>
literal|0
condition|)
block|{
name|brackets
operator|=
name|countBrackets
argument_list|(
name|type
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|buf
operator|.
name|toString
argument_list|()
expr_stmt|;
name|buf
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|brackets
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
block|}
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|Constants
operator|.
name|T_BOOLEAN
init|;
operator|(
name|i
operator|<=
name|Constants
operator|.
name|T_VOID
operator|)
operator|&&
operator|!
name|found
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Constants
operator|.
name|TYPE_NAMES
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|Constants
operator|.
name|SHORT_TYPE_NAMES
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'L'
argument_list|)
operator|.
name|append
argument_list|(
name|type
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|int
name|countBrackets
parameter_list|(
name|String
name|brackets
parameter_list|)
block|{
name|char
index|[]
name|chars
init|=
name|brackets
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|boolean
name|open
init|=
literal|false
decl_stmt|;
for|for
control|(
name|char
name|c
range|:
name|chars
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'['
case|:
if|if
condition|(
name|open
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Illegally nested brackets:"
operator|+
name|brackets
argument_list|)
throw|;
block|}
name|open
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|']'
case|:
if|if
condition|(
operator|!
name|open
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Illegally nested brackets:"
operator|+
name|brackets
argument_list|)
throw|;
block|}
name|open
operator|=
literal|false
expr_stmt|;
name|count
operator|++
expr_stmt|;
break|break;
default|default:
comment|// Don't care
block|}
block|}
if|if
condition|(
name|open
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Illegally nested brackets:"
operator|+
name|brackets
argument_list|)
throw|;
block|}
return|return
name|count
return|;
block|}
comment|/**      * Return type of method signature as a byte value as defined in<em>Constants</em>      *      * @param  signature in format described above      * @return type of method signature      * @see    Constants      *       * @throws ClassFormatException if signature is not a method signature      */
specifier|public
specifier|static
name|byte
name|typeOfMethodSignature
parameter_list|(
name|String
name|signature
parameter_list|)
throws|throws
name|ClassFormatException
block|{
name|int
name|index
decl_stmt|;
try|try
block|{
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'('
condition|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid method signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
name|index
operator|=
name|signature
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|typeOfSignature
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|index
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|StringIndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid method signature: "
operator|+
name|signature
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Return type of signature as a byte value as defined in<em>Constants</em>      *      * @param  signature in format described above      * @return type of signature      * @see    Constants      *       * @throws ClassFormatException if signature isn't a known type      */
specifier|public
specifier|static
name|byte
name|typeOfSignature
parameter_list|(
name|String
name|signature
parameter_list|)
throws|throws
name|ClassFormatException
block|{
try|try
block|{
switch|switch
condition|(
name|signature
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
condition|)
block|{
case|case
literal|'B'
case|:
return|return
name|Constants
operator|.
name|T_BYTE
return|;
case|case
literal|'C'
case|:
return|return
name|Constants
operator|.
name|T_CHAR
return|;
case|case
literal|'D'
case|:
return|return
name|Constants
operator|.
name|T_DOUBLE
return|;
case|case
literal|'F'
case|:
return|return
name|Constants
operator|.
name|T_FLOAT
return|;
case|case
literal|'I'
case|:
return|return
name|Constants
operator|.
name|T_INT
return|;
case|case
literal|'J'
case|:
return|return
name|Constants
operator|.
name|T_LONG
return|;
case|case
literal|'L'
case|:
case|case
literal|'T'
case|:
return|return
name|Constants
operator|.
name|T_REFERENCE
return|;
case|case
literal|'['
case|:
return|return
name|Constants
operator|.
name|T_ARRAY
return|;
case|case
literal|'V'
case|:
return|return
name|Constants
operator|.
name|T_VOID
return|;
case|case
literal|'Z'
case|:
return|return
name|Constants
operator|.
name|T_BOOLEAN
return|;
case|case
literal|'S'
case|:
return|return
name|Constants
operator|.
name|T_SHORT
return|;
default|default:
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid method signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|StringIndexOutOfBoundsException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ClassFormatException
argument_list|(
literal|"Invalid method signature: "
operator|+
name|signature
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Map opcode names to opcode numbers. E.g., return Constants.ALOAD for "aload"      */
specifier|public
specifier|static
name|short
name|searchOpcode
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|name
operator|=
name|name
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
expr_stmt|;
for|for
control|(
name|short
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Constants
operator|.
name|OPCODE_NAMES
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Constants
operator|.
name|OPCODE_NAMES
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**      * Convert (signed) byte to (unsigned) short value, i.e., all negative      * values become positive.      */
specifier|private
specifier|static
name|short
name|byteToShort
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
return|return
operator|(
name|b
operator|<
literal|0
operator|)
condition|?
operator|(
name|short
operator|)
operator|(
literal|256
operator|+
name|b
operator|)
else|:
operator|(
name|short
operator|)
name|b
return|;
block|}
comment|/** Convert bytes into hexadecimal string      *      * @param bytes an array of bytes to convert to hexadecimal      *       * @return bytes as hexadecimal string, e.g. 00 FA 12 ...      */
specifier|public
specifier|static
name|String
name|toHexString
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|short
name|b
init|=
name|byteToShort
argument_list|(
name|bytes
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|String
name|hex
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|b
argument_list|,
literal|0x10
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|<
literal|0x10
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|hex
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|bytes
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Return a string for an integer justified left or right and filled up with      * `fill' characters if necessary.      *      * @param i integer to format      * @param length length of desired string      * @param left_justify format left or right      * @param fill fill character      * @return formatted int      */
specifier|public
specifier|static
name|String
name|format
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|left_justify
parameter_list|,
name|char
name|fill
parameter_list|)
block|{
return|return
name|fillup
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|i
argument_list|)
argument_list|,
name|length
argument_list|,
name|left_justify
argument_list|,
name|fill
argument_list|)
return|;
block|}
comment|/**      * Fillup char with up to length characters with char `fill' and justify it left or right.      *      * @param str string to format      * @param length length of desired string      * @param left_justify format left or right      * @param fill fill character      * @return formatted string      */
specifier|public
specifier|static
name|String
name|fillup
parameter_list|(
name|String
name|str
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|left_justify
parameter_list|,
name|char
name|fill
parameter_list|)
block|{
name|int
name|len
init|=
name|length
operator|-
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
name|char
index|[]
name|buf
init|=
operator|new
name|char
index|[
operator|(
name|len
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|buf
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|buf
index|[
name|j
index|]
operator|=
name|fill
expr_stmt|;
block|}
if|if
condition|(
name|left_justify
condition|)
block|{
return|return
name|str
operator|+
operator|new
name|String
argument_list|(
name|buf
argument_list|)
return|;
block|}
return|return
operator|new
name|String
argument_list|(
name|buf
argument_list|)
operator|+
name|str
return|;
block|}
specifier|static
name|boolean
name|equals
parameter_list|(
name|byte
index|[]
name|a
parameter_list|,
name|byte
index|[]
name|b
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|size
operator|=
name|a
operator|.
name|length
operator|)
operator|!=
name|b
operator|.
name|length
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a
index|[
name|i
index|]
operator|!=
name|b
index|[
name|i
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|void
name|printArray
parameter_list|(
name|PrintStream
name|out
parameter_list|,
name|Object
index|[]
name|obj
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
name|printArray
argument_list|(
name|obj
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|printArray
parameter_list|(
name|PrintWriter
name|out
parameter_list|,
name|Object
index|[]
name|obj
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
name|printArray
argument_list|(
name|obj
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|String
name|printArray
parameter_list|(
name|Object
index|[]
name|obj
parameter_list|)
block|{
return|return
name|printArray
argument_list|(
name|obj
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|printArray
parameter_list|(
name|Object
index|[]
name|obj
parameter_list|,
name|boolean
name|braces
parameter_list|)
block|{
return|return
name|printArray
argument_list|(
name|obj
argument_list|,
name|braces
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|printArray
parameter_list|(
name|Object
index|[]
name|obj
parameter_list|,
name|boolean
name|braces
parameter_list|,
name|boolean
name|quote
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|braces
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|obj
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|obj
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
operator|(
name|quote
condition|?
literal|"\""
else|:
literal|""
operator|)
argument_list|)
operator|.
name|append
argument_list|(
name|obj
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
operator|(
name|quote
condition|?
literal|"\""
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"null"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|obj
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|braces
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**       * @param ch the character to test if it's part of an identifier      *       * @return true, if character is one of (a, ... z, A, ... Z, 0, ... 9, _)      */
specifier|public
specifier|static
name|boolean
name|isJavaIdentifierPart
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'z'
operator|)
operator|)
operator|||
operator|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'Z'
operator|)
operator|)
operator|||
operator|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'_'
operator|)
return|;
block|}
comment|/**      * Encode byte array it into Java identifier string, i.e., a string      * that only contains the following characters: (a, ... z, A, ... Z,      * 0, ... 9, _, $).  The encoding algorithm itself is not too      * clever: if the current byte's ASCII value already is a valid Java      * identifier part, leave it as it is. Otherwise it writes the      * escape character($) followed by:      *       *<ul>      *<li> the ASCII value as a hexadecimal string, if the value is not in the range 200..247</li>      *<li>a Java identifier char not used in a lowercase hexadecimal string, if the value is in the range 200..247</li>      *</ul>      *      *<p>This operation inflates the original byte array by roughly 40-50%</p>      *      * @param bytes the byte array to convert      * @param compress use gzip to minimize string      *       * @throws IOException if there's a gzip exception      */
specifier|public
specifier|static
name|String
name|encode
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|boolean
name|compress
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|compress
condition|)
block|{
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|GZIPOutputStream
name|gos
init|=
operator|new
name|GZIPOutputStream
argument_list|(
name|baos
argument_list|)
decl_stmt|;
name|gos
operator|.
name|write
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
expr_stmt|;
name|gos
operator|.
name|close
argument_list|()
expr_stmt|;
name|baos
operator|.
name|close
argument_list|()
expr_stmt|;
name|bytes
operator|=
name|baos
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
block|}
name|CharArrayWriter
name|caw
init|=
operator|new
name|CharArrayWriter
argument_list|()
decl_stmt|;
name|JavaWriter
name|jw
init|=
operator|new
name|JavaWriter
argument_list|(
name|caw
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
name|b
range|:
name|bytes
control|)
block|{
name|int
name|in
init|=
name|b
operator|&
literal|0x000000ff
decl_stmt|;
comment|// Normalize to unsigned
name|jw
operator|.
name|write
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|jw
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|caw
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Decode a string back to a byte array.      *      * @param s the string to convert      * @param uncompress use gzip to uncompress the stream of bytes      *       * @throws IOException if there's a gzip exception      */
specifier|public
specifier|static
name|byte
index|[]
name|decode
parameter_list|(
name|String
name|s
parameter_list|,
name|boolean
name|uncompress
parameter_list|)
throws|throws
name|IOException
block|{
name|char
index|[]
name|chars
init|=
name|s
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|CharArrayReader
name|car
init|=
operator|new
name|CharArrayReader
argument_list|(
name|chars
argument_list|)
decl_stmt|;
name|JavaReader
name|jr
init|=
operator|new
name|JavaReader
argument_list|(
name|car
argument_list|)
decl_stmt|;
name|ByteArrayOutputStream
name|bos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|jr
operator|.
name|read
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
name|bos
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|bos
operator|.
name|close
argument_list|()
expr_stmt|;
name|car
operator|.
name|close
argument_list|()
expr_stmt|;
name|jr
operator|.
name|close
argument_list|()
expr_stmt|;
name|byte
index|[]
name|bytes
init|=
name|bos
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|uncompress
condition|)
block|{
name|GZIPInputStream
name|gis
init|=
operator|new
name|GZIPInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|bytes
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|tmp
init|=
operator|new
name|byte
index|[
name|bytes
operator|.
name|length
operator|*
literal|3
index|]
decl_stmt|;
comment|// Rough estimate
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|b
decl_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
name|gis
operator|.
name|read
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
name|tmp
index|[
name|count
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
block|}
name|bytes
operator|=
operator|new
name|byte
index|[
name|count
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
comment|// A-Z, g-z, _, $
specifier|private
specifier|static
specifier|final
name|int
name|FREE_CHARS
init|=
literal|48
decl_stmt|;
specifier|static
name|int
index|[]
name|CHAR_MAP
init|=
operator|new
name|int
index|[
name|FREE_CHARS
index|]
decl_stmt|;
specifier|static
name|int
index|[]
name|MAP_CHAR
init|=
operator|new
name|int
index|[
literal|256
index|]
decl_stmt|;
comment|// Reverse map
specifier|private
specifier|static
specifier|final
name|char
name|ESCAPE_CHAR
init|=
literal|'$'
decl_stmt|;
static|static
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
name|i
operator|++
control|)
block|{
name|CHAR_MAP
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
name|MAP_CHAR
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|'g'
init|;
name|i
operator|<=
literal|'z'
condition|;
name|i
operator|++
control|)
block|{
name|CHAR_MAP
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
name|MAP_CHAR
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|CHAR_MAP
index|[
name|j
index|]
operator|=
literal|'$'
expr_stmt|;
name|MAP_CHAR
index|[
literal|'$'
index|]
operator|=
name|j
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|CHAR_MAP
index|[
name|j
index|]
operator|=
literal|'_'
expr_stmt|;
name|MAP_CHAR
index|[
literal|'_'
index|]
operator|=
name|j
expr_stmt|;
block|}
comment|/**      * Decode characters into bytes.      * Used by<a href="Utility.html#decode(java.lang.String, boolean)">decode()</a>      */
specifier|private
specifier|static
class|class
name|JavaReader
extends|extends
name|FilterReader
block|{
specifier|public
name|JavaReader
parameter_list|(
name|Reader
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|b
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|b
operator|!=
name|ESCAPE_CHAR
condition|)
block|{
return|return
name|b
return|;
block|}
name|int
name|i
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|i
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|i
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|(
name|i
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|i
operator|<=
literal|'f'
operator|)
operator|)
condition|)
block|{
comment|// Normal escape
name|int
name|j
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|char
index|[]
name|tmp
init|=
block|{
operator|(
name|char
operator|)
name|i
block|,
operator|(
name|char
operator|)
name|j
block|}
decl_stmt|;
name|int
name|s
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
operator|new
name|String
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|16
argument_list|)
decl_stmt|;
return|return
name|s
return|;
block|}
return|return
name|MAP_CHAR
index|[
name|i
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
name|char
index|[]
name|cbuf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|cbuf
index|[
name|off
operator|+
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|read
argument_list|()
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
block|}
comment|/**      * Encode bytes into valid java identifier characters.      * Used by<a href="Utility.html#encode(byte[], boolean)">encode()</a>      */
specifier|private
specifier|static
class|class
name|JavaWriter
extends|extends
name|FilterWriter
block|{
specifier|public
name|JavaWriter
parameter_list|(
name|Writer
name|out
parameter_list|)
block|{
name|super
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isJavaIdentifierPart
argument_list|(
operator|(
name|char
operator|)
name|b
argument_list|)
operator|&&
operator|(
name|b
operator|!=
name|ESCAPE_CHAR
operator|)
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
name|ESCAPE_CHAR
argument_list|)
expr_stmt|;
comment|// Escape character
comment|// Special escape
if|if
condition|(
name|b
operator|>=
literal|0
operator|&&
name|b
operator|<
name|FREE_CHARS
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|CHAR_MAP
index|[
name|b
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Normal escape
name|char
index|[]
name|tmp
init|=
name|Integer
operator|.
name|toHexString
argument_list|(
name|b
argument_list|)
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|write
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|char
index|[]
name|cbuf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|write
argument_list|(
name|cbuf
index|[
name|off
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|String
name|str
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|str
operator|.
name|toCharArray
argument_list|()
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Escape all occurences of newline chars '\n', quotes \", etc.      */
specifier|public
specifier|static
name|String
name|convertString
parameter_list|(
name|String
name|label
parameter_list|)
block|{
name|char
index|[]
name|ch
init|=
name|label
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|char
name|element
range|:
name|ch
control|)
block|{
switch|switch
condition|(
name|element
condition|)
block|{
case|case
literal|'\n'
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|buf
operator|.
name|append
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|buf
operator|.
name|append
argument_list|(
name|element
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Converts a list of AnnotationGen objects into a set of attributes       * that can be attached to the class file.      *      * @param cp The constant pool gen where we can create the necessary name refs      * @param vec A list of AnnotationGen objects      */
specifier|public
specifier|static
name|Attribute
index|[]
name|getAnnotationAttributes
parameter_list|(
name|ConstantPoolGen
name|cp
parameter_list|,
name|List
argument_list|<
name|AnnotationEntryGen
argument_list|>
name|vec
parameter_list|)
block|{
if|if
condition|(
name|vec
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|new
name|Attribute
index|[
literal|0
index|]
return|;
block|}
try|try
block|{
name|int
name|countVisible
init|=
literal|0
decl_stmt|;
name|int
name|countInvisible
init|=
literal|0
decl_stmt|;
comment|//  put the annotations in the right output stream
for|for
control|(
name|AnnotationEntryGen
name|a
range|:
name|vec
control|)
block|{
if|if
condition|(
name|a
operator|.
name|isRuntimeVisible
argument_list|()
condition|)
block|{
name|countVisible
operator|++
expr_stmt|;
block|}
else|else
block|{
name|countInvisible
operator|++
expr_stmt|;
block|}
block|}
name|ByteArrayOutputStream
name|rvaBytes
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|ByteArrayOutputStream
name|riaBytes
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|DataOutputStream
name|rvaDos
init|=
operator|new
name|DataOutputStream
argument_list|(
name|rvaBytes
argument_list|)
decl_stmt|;
name|DataOutputStream
name|riaDos
init|=
operator|new
name|DataOutputStream
argument_list|(
name|riaBytes
argument_list|)
decl_stmt|;
name|rvaDos
operator|.
name|writeShort
argument_list|(
name|countVisible
argument_list|)
expr_stmt|;
name|riaDos
operator|.
name|writeShort
argument_list|(
name|countInvisible
argument_list|)
expr_stmt|;
comment|// put the annotations in the right output stream
for|for
control|(
name|AnnotationEntryGen
name|a
range|:
name|vec
control|)
block|{
if|if
condition|(
name|a
operator|.
name|isRuntimeVisible
argument_list|()
condition|)
block|{
name|a
operator|.
name|dump
argument_list|(
name|rvaDos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|.
name|dump
argument_list|(
name|riaDos
argument_list|)
expr_stmt|;
block|}
block|}
name|rvaDos
operator|.
name|close
argument_list|()
expr_stmt|;
name|riaDos
operator|.
name|close
argument_list|()
expr_stmt|;
name|byte
index|[]
name|rvaData
init|=
name|rvaBytes
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|byte
index|[]
name|riaData
init|=
name|riaBytes
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|int
name|rvaIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|riaIndex
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|rvaData
operator|.
name|length
operator|>
literal|2
condition|)
block|{
name|rvaIndex
operator|=
name|cp
operator|.
name|addUtf8
argument_list|(
literal|"RuntimeVisibleAnnotations"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|riaData
operator|.
name|length
operator|>
literal|2
condition|)
block|{
name|riaIndex
operator|=
name|cp
operator|.
name|addUtf8
argument_list|(
literal|"RuntimeInvisibleAnnotations"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Attribute
argument_list|>
name|newAttributes
init|=
operator|new
name|ArrayList
argument_list|<
name|Attribute
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|rvaData
operator|.
name|length
operator|>
literal|2
condition|)
block|{
name|newAttributes
operator|.
name|add
argument_list|(
operator|new
name|RuntimeVisibleAnnotations
argument_list|(
name|rvaIndex
argument_list|,
name|rvaData
operator|.
name|length
argument_list|,
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|rvaData
argument_list|)
argument_list|)
argument_list|,
name|cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|riaData
operator|.
name|length
operator|>
literal|2
condition|)
block|{
name|newAttributes
operator|.
name|add
argument_list|(
operator|new
name|RuntimeInvisibleAnnotations
argument_list|(
name|riaIndex
argument_list|,
name|riaData
operator|.
name|length
argument_list|,
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|riaData
argument_list|)
argument_list|)
argument_list|,
name|cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|newAttributes
operator|.
name|toArray
argument_list|(
operator|new
name|Attribute
index|[
name|newAttributes
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"IOException whilst processing annotations"
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Annotations against a class are stored in one of four attribute kinds:      * - RuntimeVisibleParameterAnnotations      * - RuntimeInvisibleParameterAnnotations      */
specifier|public
specifier|static
name|Attribute
index|[]
name|getParameterAnnotationAttributes
parameter_list|(
name|ConstantPoolGen
name|cp
parameter_list|,
name|List
argument_list|<
name|AnnotationEntryGen
argument_list|>
index|[]
comment|/*Array of lists, array size depends on #params */
name|vec
parameter_list|)
block|{
name|int
name|visCount
index|[]
init|=
operator|new
name|int
index|[
name|vec
operator|.
name|length
index|]
decl_stmt|;
name|int
name|totalVisCount
init|=
literal|0
decl_stmt|;
name|int
name|invisCount
index|[]
init|=
operator|new
name|int
index|[
name|vec
operator|.
name|length
index|]
decl_stmt|;
name|int
name|totalInvisCount
init|=
literal|0
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vec
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vec
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|AnnotationEntryGen
name|element
range|:
name|vec
index|[
name|i
index|]
control|)
block|{
if|if
condition|(
name|element
operator|.
name|isRuntimeVisible
argument_list|()
condition|)
block|{
name|visCount
index|[
name|i
index|]
operator|++
expr_stmt|;
name|totalVisCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|invisCount
index|[
name|i
index|]
operator|++
expr_stmt|;
name|totalInvisCount
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Lets do the visible ones
name|ByteArrayOutputStream
name|rvaBytes
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|DataOutputStream
name|rvaDos
init|=
operator|new
name|DataOutputStream
argument_list|(
name|rvaBytes
argument_list|)
decl_stmt|;
name|rvaDos
operator|.
name|writeByte
argument_list|(
name|vec
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// First goes number of parameters
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vec
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|rvaDos
operator|.
name|writeShort
argument_list|(
name|visCount
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|visCount
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|AnnotationEntryGen
name|element
range|:
name|vec
index|[
name|i
index|]
control|)
block|{
if|if
condition|(
name|element
operator|.
name|isRuntimeVisible
argument_list|()
condition|)
block|{
name|element
operator|.
name|dump
argument_list|(
name|rvaDos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|rvaDos
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Lets do the invisible ones
name|ByteArrayOutputStream
name|riaBytes
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|DataOutputStream
name|riaDos
init|=
operator|new
name|DataOutputStream
argument_list|(
name|riaBytes
argument_list|)
decl_stmt|;
name|riaDos
operator|.
name|writeByte
argument_list|(
name|vec
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// First goes number of parameters
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vec
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|riaDos
operator|.
name|writeShort
argument_list|(
name|invisCount
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|invisCount
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|AnnotationEntryGen
name|element
range|:
name|vec
index|[
name|i
index|]
control|)
block|{
if|if
condition|(
operator|!
name|element
operator|.
name|isRuntimeVisible
argument_list|()
condition|)
block|{
name|element
operator|.
name|dump
argument_list|(
name|riaDos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|riaDos
operator|.
name|close
argument_list|()
expr_stmt|;
name|byte
index|[]
name|rvaData
init|=
name|rvaBytes
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|byte
index|[]
name|riaData
init|=
name|riaBytes
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|int
name|rvaIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|riaIndex
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|totalVisCount
operator|>
literal|0
condition|)
block|{
name|rvaIndex
operator|=
name|cp
operator|.
name|addUtf8
argument_list|(
literal|"RuntimeVisibleParameterAnnotations"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|totalInvisCount
operator|>
literal|0
condition|)
block|{
name|riaIndex
operator|=
name|cp
operator|.
name|addUtf8
argument_list|(
literal|"RuntimeInvisibleParameterAnnotations"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Attribute
argument_list|>
name|newAttributes
init|=
operator|new
name|ArrayList
argument_list|<
name|Attribute
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|totalVisCount
operator|>
literal|0
condition|)
block|{
name|newAttributes
operator|.
name|add
argument_list|(
operator|new
name|RuntimeVisibleParameterAnnotations
argument_list|(
name|rvaIndex
argument_list|,
name|rvaData
operator|.
name|length
argument_list|,
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|rvaData
argument_list|)
argument_list|)
argument_list|,
name|cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|totalInvisCount
operator|>
literal|0
condition|)
block|{
name|newAttributes
operator|.
name|add
argument_list|(
operator|new
name|RuntimeInvisibleParameterAnnotations
argument_list|(
name|riaIndex
argument_list|,
name|riaData
operator|.
name|length
argument_list|,
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|riaData
argument_list|)
argument_list|)
argument_list|,
name|cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|newAttributes
operator|.
name|toArray
argument_list|(
operator|new
name|Attribute
index|[
name|newAttributes
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"IOException whilst processing parameter annotations"
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
end_class

end_unit

