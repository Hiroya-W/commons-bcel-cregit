begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|Const
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|AnnotationEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Annotations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Attribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Code
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|CodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ExceptionTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|LineNumber
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|LineNumberTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|LocalVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|LocalVariableTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|LocalVariableTypeTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ParameterAnnotationEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|ParameterAnnotations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|RuntimeVisibleParameterAnnotations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|classfile
operator|.
name|Utility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|util
operator|.
name|BCELComparator
import|;
end_import

begin_comment
comment|/**  * Template class for building up a method. This is done by defining exception  * handlers, adding thrown exceptions, local variables and attributes, whereas  * the `LocalVariableTable' and `LineNumberTable' attributes will be set  * automatically for the code. Use stripAttributes() if you don't like this.  *  * While generating code it may be necessary to insert NOP operations. You can  * use the `removeNOPs' method to get rid off them.  * The resulting method object can be obtained via the `getMethod()' method.  *  * @see     InstructionList  * @see     Method  */
end_comment

begin_class
specifier|public
class|class
name|MethodGen
extends|extends
name|FieldGenOrMethodGen
block|{
specifier|private
name|String
name|class_name
decl_stmt|;
specifier|private
name|Type
index|[]
name|arg_types
decl_stmt|;
specifier|private
name|String
index|[]
name|arg_names
decl_stmt|;
specifier|private
name|int
name|max_locals
decl_stmt|;
specifier|private
name|int
name|max_stack
decl_stmt|;
specifier|private
name|InstructionList
name|il
decl_stmt|;
specifier|private
name|boolean
name|strip_attributes
decl_stmt|;
specifier|private
name|LocalVariableTypeTable
name|local_variable_type_table
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|LocalVariableGen
argument_list|>
name|variable_vec
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|LineNumberGen
argument_list|>
name|line_number_vec
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|CodeExceptionGen
argument_list|>
name|exception_vec
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|throws_vec
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|Attribute
argument_list|>
name|code_attrs_vec
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|AnnotationEntryGen
argument_list|>
index|[]
name|param_annotations
decl_stmt|;
comment|// Array of lists containing AnnotationGen objects
specifier|private
name|boolean
name|hasParameterAnnotations
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|haveUnpackedParameterAnnotations
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
name|BCELComparator
name|bcelComparator
init|=
operator|new
name|BCELComparator
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
specifier|final
name|Object
name|o1
parameter_list|,
specifier|final
name|Object
name|o2
parameter_list|)
block|{
specifier|final
name|MethodGen
name|THIS
init|=
operator|(
name|MethodGen
operator|)
name|o1
decl_stmt|;
specifier|final
name|MethodGen
name|THAT
init|=
operator|(
name|MethodGen
operator|)
name|o2
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|THIS
operator|.
name|getName
argument_list|()
argument_list|,
name|THAT
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|THIS
operator|.
name|getSignature
argument_list|()
argument_list|,
name|THAT
operator|.
name|getSignature
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|(
specifier|final
name|Object
name|o
parameter_list|)
block|{
specifier|final
name|MethodGen
name|THIS
init|=
operator|(
name|MethodGen
operator|)
name|o
decl_stmt|;
return|return
name|THIS
operator|.
name|getSignature
argument_list|()
operator|.
name|hashCode
argument_list|()
operator|^
name|THIS
operator|.
name|getName
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/**      * Declare method. If the method is non-static the constructor      * automatically declares a local variable `$this' in slot 0. The      * actual code is contained in the `il' parameter, which may further      * manipulated by the user. But he must take care not to remove any      * instruction (handles) that are still referenced from this object.      *      * For example one may not add a local variable and later remove the      * instructions it refers to without causing havoc. It is safe      * however if you remove that local variable, too.      *      * @param access_flags access qualifiers      * @param return_type  method type      * @param arg_types argument types      * @param arg_names argument names (if this is null, default names will be provided      * for them)      * @param method_name name of method      * @param class_name class name containing this method (may be null, if you don't care)      * @param il instruction list associated with this method, may be null only for      * abstract or native methods      * @param cp constant pool      */
specifier|public
name|MethodGen
parameter_list|(
specifier|final
name|int
name|access_flags
parameter_list|,
specifier|final
name|Type
name|return_type
parameter_list|,
specifier|final
name|Type
index|[]
name|arg_types
parameter_list|,
name|String
index|[]
name|arg_names
parameter_list|,
specifier|final
name|String
name|method_name
parameter_list|,
specifier|final
name|String
name|class_name
parameter_list|,
specifier|final
name|InstructionList
name|il
parameter_list|,
specifier|final
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
name|super
argument_list|(
name|access_flags
argument_list|)
expr_stmt|;
name|setType
argument_list|(
name|return_type
argument_list|)
expr_stmt|;
name|setArgumentTypes
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
name|setArgumentNames
argument_list|(
name|arg_names
argument_list|)
expr_stmt|;
name|setName
argument_list|(
name|method_name
argument_list|)
expr_stmt|;
name|setClassName
argument_list|(
name|class_name
argument_list|)
expr_stmt|;
name|setInstructionList
argument_list|(
name|il
argument_list|)
expr_stmt|;
name|setConstantPool
argument_list|(
name|cp
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|abstract_
init|=
name|isAbstract
argument_list|()
operator|||
name|isNative
argument_list|()
decl_stmt|;
name|InstructionHandle
name|start
init|=
literal|null
decl_stmt|;
specifier|final
name|InstructionHandle
name|end
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|abstract_
condition|)
block|{
name|start
operator|=
name|il
operator|.
name|getStart
argument_list|()
expr_stmt|;
comment|// end == null => live to end of method
comment|/* Add local variables, namely the implicit `this' and the arguments              */
if|if
condition|(
operator|!
name|isStatic
argument_list|()
operator|&&
operator|(
name|class_name
operator|!=
literal|null
operator|)
condition|)
block|{
comment|// Instance method -> `this' is local var 0
name|addLocalVariable
argument_list|(
literal|"this"
argument_list|,
name|ObjectType
operator|.
name|getInstance
argument_list|(
name|class_name
argument_list|)
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|arg_types
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|size
init|=
name|arg_types
operator|.
name|length
decl_stmt|;
for|for
control|(
specifier|final
name|Type
name|arg_type
range|:
name|arg_types
control|)
block|{
if|if
condition|(
name|Type
operator|.
name|VOID
operator|==
name|arg_type
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"'void' is an illegal argument type for a method"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|arg_names
operator|!=
literal|null
condition|)
block|{
comment|// Names for variables provided?
if|if
condition|(
name|size
operator|!=
name|arg_names
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Mismatch in argument array lengths: "
operator|+
name|size
operator|+
literal|" vs. "
operator|+
name|arg_names
operator|.
name|length
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// Give them dummy names
name|arg_names
operator|=
operator|new
name|String
index|[
name|size
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|arg_names
index|[
name|i
index|]
operator|=
literal|"arg"
operator|+
name|i
expr_stmt|;
block|}
name|setArgumentNames
argument_list|(
name|arg_names
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|abstract_
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|addLocalVariable
argument_list|(
name|arg_names
index|[
name|i
index|]
argument_list|,
name|arg_types
index|[
name|i
index|]
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Instantiate from existing method.      *      * @param m method      * @param class_name class name containing this method      * @param cp constant pool      */
specifier|public
name|MethodGen
parameter_list|(
specifier|final
name|Method
name|m
parameter_list|,
specifier|final
name|String
name|class_name
parameter_list|,
specifier|final
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
name|this
argument_list|(
name|m
operator|.
name|getAccessFlags
argument_list|()
argument_list|,
name|Type
operator|.
name|getReturnType
argument_list|(
name|m
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|Type
operator|.
name|getArgumentTypes
argument_list|(
name|m
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
literal|null
comment|/* may be overridden anyway */
argument_list|,
name|m
operator|.
name|getName
argument_list|()
argument_list|,
name|class_name
argument_list|,
operator|(
operator|(
name|m
operator|.
name|getAccessFlags
argument_list|()
operator|&
operator|(
name|Const
operator|.
name|ACC_ABSTRACT
operator||
name|Const
operator|.
name|ACC_NATIVE
operator|)
operator|)
operator|==
literal|0
operator|)
condition|?
operator|new
name|InstructionList
argument_list|(
name|m
operator|.
name|getCode
argument_list|()
operator|.
name|getCode
argument_list|()
argument_list|)
else|:
literal|null
argument_list|,
name|cp
argument_list|)
expr_stmt|;
specifier|final
name|Attribute
index|[]
name|attributes
init|=
name|m
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Attribute
name|attribute
range|:
name|attributes
control|)
block|{
name|Attribute
name|a
init|=
name|attribute
decl_stmt|;
if|if
condition|(
name|a
operator|instanceof
name|Code
condition|)
block|{
specifier|final
name|Code
name|c
init|=
operator|(
name|Code
operator|)
name|a
decl_stmt|;
name|setMaxStack
argument_list|(
name|c
operator|.
name|getMaxStack
argument_list|()
argument_list|)
expr_stmt|;
name|setMaxLocals
argument_list|(
name|c
operator|.
name|getMaxLocals
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|CodeException
index|[]
name|ces
init|=
name|c
operator|.
name|getExceptionTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|ces
operator|!=
literal|null
condition|)
block|{
for|for
control|(
specifier|final
name|CodeException
name|ce
range|:
name|ces
control|)
block|{
specifier|final
name|int
name|type
init|=
name|ce
operator|.
name|getCatchType
argument_list|()
decl_stmt|;
name|ObjectType
name|c_type
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|type
operator|>
literal|0
condition|)
block|{
specifier|final
name|String
name|cen
init|=
name|m
operator|.
name|getConstantPool
argument_list|()
operator|.
name|getConstantString
argument_list|(
name|type
argument_list|,
name|Const
operator|.
name|CONSTANT_Class
argument_list|)
decl_stmt|;
name|c_type
operator|=
name|ObjectType
operator|.
name|getInstance
argument_list|(
name|cen
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|end_pc
init|=
name|ce
operator|.
name|getEndPC
argument_list|()
decl_stmt|;
specifier|final
name|int
name|length
init|=
name|m
operator|.
name|getCode
argument_list|()
operator|.
name|getCode
argument_list|()
operator|.
name|length
decl_stmt|;
name|InstructionHandle
name|end
decl_stmt|;
if|if
condition|(
name|length
operator|==
name|end_pc
condition|)
block|{
comment|// May happen, because end_pc is exclusive
name|end
operator|=
name|il
operator|.
name|getEnd
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|end
operator|=
name|il
operator|.
name|findHandle
argument_list|(
name|end_pc
argument_list|)
expr_stmt|;
name|end
operator|=
name|end
operator|.
name|getPrev
argument_list|()
expr_stmt|;
comment|// Make it inclusive
block|}
name|addExceptionHandler
argument_list|(
name|il
operator|.
name|findHandle
argument_list|(
name|ce
operator|.
name|getStartPC
argument_list|()
argument_list|)
argument_list|,
name|end
argument_list|,
name|il
operator|.
name|findHandle
argument_list|(
name|ce
operator|.
name|getHandlerPC
argument_list|()
argument_list|)
argument_list|,
name|c_type
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|Attribute
index|[]
name|c_attributes
init|=
name|c
operator|.
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Attribute
name|c_attribute
range|:
name|c_attributes
control|)
block|{
name|a
operator|=
name|c_attribute
expr_stmt|;
if|if
condition|(
name|a
operator|instanceof
name|LineNumberTable
condition|)
block|{
specifier|final
name|LineNumber
index|[]
name|ln
init|=
operator|(
operator|(
name|LineNumberTable
operator|)
name|a
operator|)
operator|.
name|getLineNumberTable
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|LineNumber
name|l
range|:
name|ln
control|)
block|{
specifier|final
name|InstructionHandle
name|ih
init|=
name|il
operator|.
name|findHandle
argument_list|(
name|l
operator|.
name|getStartPC
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ih
operator|!=
literal|null
condition|)
block|{
name|addLineNumber
argument_list|(
name|ih
argument_list|,
name|l
operator|.
name|getLineNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|else if
condition|(
name|a
operator|instanceof
name|LocalVariableTable
condition|)
block|{
name|updateLocalVariableTable
argument_list|(
operator|(
name|LocalVariableTable
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|a
operator|instanceof
name|LocalVariableTypeTable
condition|)
block|{
name|this
operator|.
name|local_variable_type_table
operator|=
operator|(
name|LocalVariableTypeTable
operator|)
name|a
operator|.
name|copy
argument_list|(
name|cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addCodeAttribute
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|else if
condition|(
name|a
operator|instanceof
name|ExceptionTable
condition|)
block|{
specifier|final
name|String
index|[]
name|names
init|=
operator|(
operator|(
name|ExceptionTable
operator|)
name|a
operator|)
operator|.
name|getExceptionNames
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|String
name|name2
range|:
name|names
control|)
block|{
name|addException
argument_list|(
name|name2
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|a
operator|instanceof
name|Annotations
condition|)
block|{
specifier|final
name|Annotations
name|runtimeAnnotations
init|=
operator|(
name|Annotations
operator|)
name|a
decl_stmt|;
specifier|final
name|AnnotationEntry
index|[]
name|aes
init|=
name|runtimeAnnotations
operator|.
name|getAnnotationEntries
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|AnnotationEntry
name|element
range|:
name|aes
control|)
block|{
name|addAnnotationEntry
argument_list|(
operator|new
name|AnnotationEntryGen
argument_list|(
name|element
argument_list|,
name|cp
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|addAttribute
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Adds a local variable to this method.      *      * @param name variable name      * @param type variable type      * @param slot the index of the local variable, if type is long or double, the next available      * index is slot+2      * @param start from where the variable is valid      * @param end until where the variable is valid      * @param orig_index the index of the local variable prior to any modifications      * @return new local variable object      * @see LocalVariable      */
specifier|public
name|LocalVariableGen
name|addLocalVariable
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|int
name|slot
parameter_list|,
specifier|final
name|InstructionHandle
name|start
parameter_list|,
specifier|final
name|InstructionHandle
name|end
parameter_list|,
specifier|final
name|int
name|orig_index
parameter_list|)
block|{
specifier|final
name|byte
name|t
init|=
name|type
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|Const
operator|.
name|T_ADDRESS
condition|)
block|{
specifier|final
name|int
name|add
init|=
name|type
operator|.
name|getSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|slot
operator|+
name|add
operator|>
name|max_locals
condition|)
block|{
name|max_locals
operator|=
name|slot
operator|+
name|add
expr_stmt|;
block|}
specifier|final
name|LocalVariableGen
name|l
init|=
operator|new
name|LocalVariableGen
argument_list|(
name|slot
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|orig_index
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|variable_vec
operator|.
name|indexOf
argument_list|(
name|l
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|variable_vec
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|variable_vec
operator|.
name|add
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can not use "
operator|+
name|type
operator|+
literal|" as type for local variable"
argument_list|)
throw|;
block|}
comment|/**      * Adds a local variable to this method.      *      * @param name variable name      * @param type variable type      * @param slot the index of the local variable, if type is long or double, the next available      * index is slot+2      * @param start from where the variable is valid      * @param end until where the variable is valid      * @return new local variable object      * @see LocalVariable      */
specifier|public
name|LocalVariableGen
name|addLocalVariable
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|int
name|slot
parameter_list|,
specifier|final
name|InstructionHandle
name|start
parameter_list|,
specifier|final
name|InstructionHandle
name|end
parameter_list|)
block|{
return|return
name|addLocalVariable
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|slot
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|slot
argument_list|)
return|;
block|}
comment|/**      * Adds a local variable to this method and assigns an index automatically.      *      * @param name variable name      * @param type variable type      * @param start from where the variable is valid, if this is null,      * it is valid from the start      * @param end until where the variable is valid, if this is null,      * it is valid to the end      * @return new local variable object      * @see LocalVariable      */
specifier|public
name|LocalVariableGen
name|addLocalVariable
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|InstructionHandle
name|start
parameter_list|,
specifier|final
name|InstructionHandle
name|end
parameter_list|)
block|{
return|return
name|addLocalVariable
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|max_locals
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
return|;
block|}
comment|/**      * Remove a local variable, its slot will not be reused, if you do not use addLocalVariable      * with an explicit index argument.      */
specifier|public
name|void
name|removeLocalVariable
parameter_list|(
specifier|final
name|LocalVariableGen
name|l
parameter_list|)
block|{
name|l
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|variable_vec
operator|.
name|remove
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove all local variables.      */
specifier|public
name|void
name|removeLocalVariables
parameter_list|()
block|{
for|for
control|(
specifier|final
name|LocalVariableGen
name|lv
range|:
name|variable_vec
control|)
block|{
name|lv
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
name|variable_vec
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/*      * If the range of the variable has not been set yet, it will be set to be valid from      * the start to the end of the instruction list.      *      * @return array of declared local variables sorted by index      */
specifier|public
name|LocalVariableGen
index|[]
name|getLocalVariables
parameter_list|()
block|{
specifier|final
name|int
name|size
init|=
name|variable_vec
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|LocalVariableGen
index|[]
name|lg
init|=
operator|new
name|LocalVariableGen
index|[
name|size
index|]
decl_stmt|;
name|variable_vec
operator|.
name|toArray
argument_list|(
name|lg
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|lg
index|[
name|i
index|]
operator|.
name|getStart
argument_list|()
operator|==
literal|null
operator|)
operator|&&
operator|(
name|il
operator|!=
literal|null
operator|)
condition|)
block|{
name|lg
index|[
name|i
index|]
operator|.
name|setStart
argument_list|(
name|il
operator|.
name|getStart
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lg
index|[
name|i
index|]
operator|.
name|getEnd
argument_list|()
operator|==
literal|null
operator|)
operator|&&
operator|(
name|il
operator|!=
literal|null
operator|)
condition|)
block|{
name|lg
index|[
name|i
index|]
operator|.
name|setEnd
argument_list|(
name|il
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|size
operator|>
literal|1
condition|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|lg
argument_list|,
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
name|o1
operator|.
name|getIndex
argument_list|()
operator|-
name|o2
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|lg
return|;
block|}
comment|/**      * @return `LocalVariableTable' attribute of all the local variables of this method.      */
specifier|public
name|LocalVariableTable
name|getLocalVariableTable
parameter_list|(
specifier|final
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
specifier|final
name|LocalVariableGen
index|[]
name|lg
init|=
name|getLocalVariables
argument_list|()
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|lg
operator|.
name|length
decl_stmt|;
specifier|final
name|LocalVariable
index|[]
name|lv
init|=
operator|new
name|LocalVariable
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|lv
index|[
name|i
index|]
operator|=
name|lg
index|[
name|i
index|]
operator|.
name|getLocalVariable
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|LocalVariableTable
argument_list|(
name|cp
operator|.
name|addUtf8
argument_list|(
literal|"LocalVariableTable"
argument_list|)
argument_list|,
literal|2
operator|+
name|lv
operator|.
name|length
operator|*
literal|10
argument_list|,
name|lv
argument_list|,
name|cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @return `LocalVariableTypeTable' attribute of this method.      */
specifier|public
name|LocalVariableTypeTable
name|getLocalVariableTypeTable
parameter_list|()
block|{
return|return
name|local_variable_type_table
return|;
block|}
comment|/**      * Give an instruction a line number corresponding to the source code line.      *      * @param ih instruction to tag      * @return new line number object      * @see LineNumber      */
specifier|public
name|LineNumberGen
name|addLineNumber
parameter_list|(
specifier|final
name|InstructionHandle
name|ih
parameter_list|,
specifier|final
name|int
name|src_line
parameter_list|)
block|{
specifier|final
name|LineNumberGen
name|l
init|=
operator|new
name|LineNumberGen
argument_list|(
name|ih
argument_list|,
name|src_line
argument_list|)
decl_stmt|;
name|line_number_vec
operator|.
name|add
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
comment|/**      * Remove a line number.      */
specifier|public
name|void
name|removeLineNumber
parameter_list|(
specifier|final
name|LineNumberGen
name|l
parameter_list|)
block|{
name|line_number_vec
operator|.
name|remove
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove all line numbers.      */
specifier|public
name|void
name|removeLineNumbers
parameter_list|()
block|{
name|line_number_vec
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/*      * @return array of line numbers      */
specifier|public
name|LineNumberGen
index|[]
name|getLineNumbers
parameter_list|()
block|{
specifier|final
name|LineNumberGen
index|[]
name|lg
init|=
operator|new
name|LineNumberGen
index|[
name|line_number_vec
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|line_number_vec
operator|.
name|toArray
argument_list|(
name|lg
argument_list|)
expr_stmt|;
return|return
name|lg
return|;
block|}
comment|/**      * @return `LineNumberTable' attribute of all the local variables of this method.      */
specifier|public
name|LineNumberTable
name|getLineNumberTable
parameter_list|(
specifier|final
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|line_number_vec
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|LineNumber
index|[]
name|ln
init|=
operator|new
name|LineNumber
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|ln
index|[
name|i
index|]
operator|=
name|line_number_vec
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getLineNumber
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|LineNumberTable
argument_list|(
name|cp
operator|.
name|addUtf8
argument_list|(
literal|"LineNumberTable"
argument_list|)
argument_list|,
literal|2
operator|+
name|ln
operator|.
name|length
operator|*
literal|4
argument_list|,
name|ln
argument_list|,
name|cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Add an exception handler, i.e., specify region where a handler is active and an      * instruction where the actual handling is done.      *      * @param start_pc Start of region (inclusive)      * @param end_pc End of region (inclusive)      * @param handler_pc Where handling is done      * @param catch_type class type of handled exception or null if any      * exception is handled      * @return new exception handler object      */
specifier|public
name|CodeExceptionGen
name|addExceptionHandler
parameter_list|(
specifier|final
name|InstructionHandle
name|start_pc
parameter_list|,
specifier|final
name|InstructionHandle
name|end_pc
parameter_list|,
specifier|final
name|InstructionHandle
name|handler_pc
parameter_list|,
specifier|final
name|ObjectType
name|catch_type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|start_pc
operator|==
literal|null
operator|)
operator|||
operator|(
name|end_pc
operator|==
literal|null
operator|)
operator|||
operator|(
name|handler_pc
operator|==
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Exception handler target is null instruction"
argument_list|)
throw|;
block|}
specifier|final
name|CodeExceptionGen
name|c
init|=
operator|new
name|CodeExceptionGen
argument_list|(
name|start_pc
argument_list|,
name|end_pc
argument_list|,
name|handler_pc
argument_list|,
name|catch_type
argument_list|)
decl_stmt|;
name|exception_vec
operator|.
name|add
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/**      * Remove an exception handler.      */
specifier|public
name|void
name|removeExceptionHandler
parameter_list|(
specifier|final
name|CodeExceptionGen
name|c
parameter_list|)
block|{
name|exception_vec
operator|.
name|remove
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove all line numbers.      */
specifier|public
name|void
name|removeExceptionHandlers
parameter_list|()
block|{
name|exception_vec
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/*      * @return array of declared exception handlers      */
specifier|public
name|CodeExceptionGen
index|[]
name|getExceptionHandlers
parameter_list|()
block|{
specifier|final
name|CodeExceptionGen
index|[]
name|cg
init|=
operator|new
name|CodeExceptionGen
index|[
name|exception_vec
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|exception_vec
operator|.
name|toArray
argument_list|(
name|cg
argument_list|)
expr_stmt|;
return|return
name|cg
return|;
block|}
comment|/**      * @return code exceptions for `Code' attribute      */
specifier|private
name|CodeException
index|[]
name|getCodeExceptions
parameter_list|()
block|{
specifier|final
name|int
name|size
init|=
name|exception_vec
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|CodeException
index|[]
name|c_exc
init|=
operator|new
name|CodeException
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|CodeExceptionGen
name|c
init|=
name|exception_vec
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|c_exc
index|[
name|i
index|]
operator|=
name|c
operator|.
name|getCodeException
argument_list|(
name|super
operator|.
name|getConstantPool
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|c_exc
return|;
block|}
comment|/**      * Add an exception possibly thrown by this method.      *      * @param class_name (fully qualified) name of exception      */
specifier|public
name|void
name|addException
parameter_list|(
specifier|final
name|String
name|class_name
parameter_list|)
block|{
name|throws_vec
operator|.
name|add
argument_list|(
name|class_name
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove an exception.      */
specifier|public
name|void
name|removeException
parameter_list|(
specifier|final
name|String
name|c
parameter_list|)
block|{
name|throws_vec
operator|.
name|remove
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove all exceptions.      */
specifier|public
name|void
name|removeExceptions
parameter_list|()
block|{
name|throws_vec
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/*      * @return array of thrown exceptions      */
specifier|public
name|String
index|[]
name|getExceptions
parameter_list|()
block|{
specifier|final
name|String
index|[]
name|e
init|=
operator|new
name|String
index|[
name|throws_vec
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|throws_vec
operator|.
name|toArray
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
comment|/**      * @return `Exceptions' attribute of all the exceptions thrown by this method.      */
specifier|private
name|ExceptionTable
name|getExceptionTable
parameter_list|(
specifier|final
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|throws_vec
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|int
index|[]
name|ex
init|=
operator|new
name|int
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|ex
index|[
name|i
index|]
operator|=
name|cp
operator|.
name|addClass
argument_list|(
name|throws_vec
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ExceptionTable
argument_list|(
name|cp
operator|.
name|addUtf8
argument_list|(
literal|"Exceptions"
argument_list|)
argument_list|,
literal|2
operator|+
literal|2
operator|*
name|size
argument_list|,
name|ex
argument_list|,
name|cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Add an attribute to the code. Currently, the JVM knows about the      * LineNumberTable, LocalVariableTable and StackMap attributes,      * where the former two will be generated automatically and the      * latter is used for the MIDP only. Other attributes will be      * ignored by the JVM but do no harm.      *      * @param a attribute to be added      */
specifier|public
name|void
name|addCodeAttribute
parameter_list|(
specifier|final
name|Attribute
name|a
parameter_list|)
block|{
name|code_attrs_vec
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove the LocalVariableTypeTable      */
specifier|public
name|void
name|removeLocalVariableTypeTable
parameter_list|( )
block|{
name|local_variable_type_table
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * Remove a code attribute.      */
specifier|public
name|void
name|removeCodeAttribute
parameter_list|(
specifier|final
name|Attribute
name|a
parameter_list|)
block|{
name|code_attrs_vec
operator|.
name|remove
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove all code attributes.      */
specifier|public
name|void
name|removeCodeAttributes
parameter_list|()
block|{
name|local_variable_type_table
operator|=
literal|null
expr_stmt|;
name|code_attrs_vec
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**      * @return all attributes of this method.      */
specifier|public
name|Attribute
index|[]
name|getCodeAttributes
parameter_list|()
block|{
specifier|final
name|Attribute
index|[]
name|attributes
init|=
operator|new
name|Attribute
index|[
name|code_attrs_vec
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|code_attrs_vec
operator|.
name|toArray
argument_list|(
name|attributes
argument_list|)
expr_stmt|;
return|return
name|attributes
return|;
block|}
comment|/**      * @since 6.0      */
specifier|public
name|Attribute
index|[]
name|addAnnotationsAsAttribute
parameter_list|(
specifier|final
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
specifier|final
name|Attribute
index|[]
name|attrs
init|=
name|AnnotationEntryGen
operator|.
name|getAnnotationAttributes
argument_list|(
name|cp
argument_list|,
name|super
operator|.
name|getAnnotationEntries
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Attribute
name|attr
range|:
name|attrs
control|)
block|{
name|addAttribute
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
return|return
name|attrs
return|;
block|}
comment|/**      * @since 6.0      */
specifier|public
name|Attribute
index|[]
name|addParameterAnnotationsAsAttribute
parameter_list|(
specifier|final
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasParameterAnnotations
condition|)
block|{
return|return
operator|new
name|Attribute
index|[
literal|0
index|]
return|;
block|}
specifier|final
name|Attribute
index|[]
name|attrs
init|=
name|AnnotationEntryGen
operator|.
name|getParameterAnnotationAttributes
argument_list|(
name|cp
argument_list|,
name|param_annotations
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Attribute
name|attr
range|:
name|attrs
control|)
block|{
name|addAttribute
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
return|return
name|attrs
return|;
block|}
specifier|private
name|void
name|removeAttributes
parameter_list|(
name|Attribute
index|[]
name|attrs
parameter_list|)
block|{
for|for
control|(
specifier|final
name|Attribute
name|attr
range|:
name|attrs
control|)
block|{
name|removeAttribute
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Get method object. Never forget to call setMaxStack() or setMaxStack(max), respectively,      * before calling this method (the same applies for max locals).      *      * @return method object      */
specifier|public
name|Method
name|getMethod
parameter_list|()
block|{
specifier|final
name|String
name|signature
init|=
name|getSignature
argument_list|()
decl_stmt|;
specifier|final
name|ConstantPoolGen
name|_cp
init|=
name|super
operator|.
name|getConstantPool
argument_list|()
decl_stmt|;
specifier|final
name|int
name|name_index
init|=
name|_cp
operator|.
name|addUtf8
argument_list|(
name|super
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|signature_index
init|=
name|_cp
operator|.
name|addUtf8
argument_list|(
name|signature
argument_list|)
decl_stmt|;
comment|/* Also updates positions of instructions, i.e., their indices          */
name|byte
index|[]
name|byte_code
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|il
operator|!=
literal|null
condition|)
block|{
name|byte_code
operator|=
name|il
operator|.
name|getByteCode
argument_list|()
expr_stmt|;
block|}
name|LineNumberTable
name|lnt
init|=
literal|null
decl_stmt|;
name|LocalVariableTable
name|lvt
init|=
literal|null
decl_stmt|;
comment|/* Create LocalVariableTable and LineNumberTable attributes (for debuggers, e.g.)          */
if|if
condition|(
operator|(
name|variable_vec
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|!
name|strip_attributes
condition|)
block|{
name|updateLocalVariableTable
argument_list|(
name|getLocalVariableTable
argument_list|(
name|_cp
argument_list|)
argument_list|)
expr_stmt|;
name|addCodeAttribute
argument_list|(
name|lvt
operator|=
name|getLocalVariableTable
argument_list|(
name|_cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_variable_type_table
operator|!=
literal|null
condition|)
block|{
comment|// LocalVariable length in LocalVariableTypeTable is not updated automatically. It's a difference with LocalVariableTable.
if|if
condition|(
name|lvt
operator|!=
literal|null
condition|)
block|{
name|adjustLocalVariableTypeTable
argument_list|(
name|lvt
argument_list|)
expr_stmt|;
block|}
name|addCodeAttribute
argument_list|(
name|local_variable_type_table
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|line_number_vec
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|!
name|strip_attributes
condition|)
block|{
name|addCodeAttribute
argument_list|(
name|lnt
operator|=
name|getLineNumberTable
argument_list|(
name|_cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Attribute
index|[]
name|code_attrs
init|=
name|getCodeAttributes
argument_list|()
decl_stmt|;
comment|/* Each attribute causes 6 additional header bytes          */
name|int
name|attrs_len
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|Attribute
name|code_attr
range|:
name|code_attrs
control|)
block|{
name|attrs_len
operator|+=
name|code_attr
operator|.
name|getLength
argument_list|()
operator|+
literal|6
expr_stmt|;
block|}
specifier|final
name|CodeException
index|[]
name|c_exc
init|=
name|getCodeExceptions
argument_list|()
decl_stmt|;
specifier|final
name|int
name|exc_len
init|=
name|c_exc
operator|.
name|length
operator|*
literal|8
decl_stmt|;
comment|// Every entry takes 8 bytes
name|Code
name|code
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|il
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|isAbstract
argument_list|()
operator|&&
operator|!
name|isNative
argument_list|()
condition|)
block|{
comment|// Remove any stale code attribute
specifier|final
name|Attribute
index|[]
name|attributes
init|=
name|getAttributes
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Attribute
name|a
range|:
name|attributes
control|)
block|{
if|if
condition|(
name|a
operator|instanceof
name|Code
condition|)
block|{
name|removeAttribute
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
name|code
operator|=
operator|new
name|Code
argument_list|(
name|_cp
operator|.
name|addUtf8
argument_list|(
literal|"Code"
argument_list|)
argument_list|,
literal|8
operator|+
name|byte_code
operator|.
name|length
operator|+
comment|// prologue byte code
literal|2
operator|+
name|exc_len
operator|+
comment|// exceptions
literal|2
operator|+
name|attrs_len
argument_list|,
comment|// attributes
name|max_stack
argument_list|,
name|max_locals
argument_list|,
name|byte_code
argument_list|,
name|c_exc
argument_list|,
name|code_attrs
argument_list|,
name|_cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
expr_stmt|;
name|addAttribute
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
name|Attribute
index|[]
name|annotations
init|=
name|addAnnotationsAsAttribute
argument_list|(
name|_cp
argument_list|)
decl_stmt|;
name|Attribute
index|[]
name|parameterAnnotations
init|=
name|addParameterAnnotationsAsAttribute
argument_list|(
name|_cp
argument_list|)
decl_stmt|;
name|ExceptionTable
name|et
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|throws_vec
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|addAttribute
argument_list|(
name|et
operator|=
name|getExceptionTable
argument_list|(
name|_cp
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add `Exceptions' if there are "throws" clauses
block|}
specifier|final
name|Method
name|m
init|=
operator|new
name|Method
argument_list|(
name|super
operator|.
name|getAccessFlags
argument_list|()
argument_list|,
name|name_index
argument_list|,
name|signature_index
argument_list|,
name|getAttributes
argument_list|()
argument_list|,
name|_cp
operator|.
name|getConstantPool
argument_list|()
argument_list|)
decl_stmt|;
comment|// Undo effects of adding attributes
if|if
condition|(
name|lvt
operator|!=
literal|null
condition|)
block|{
name|removeCodeAttribute
argument_list|(
name|lvt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_variable_type_table
operator|!=
literal|null
condition|)
block|{
name|removeCodeAttribute
argument_list|(
name|local_variable_type_table
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lnt
operator|!=
literal|null
condition|)
block|{
name|removeCodeAttribute
argument_list|(
name|lnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|!=
literal|null
condition|)
block|{
name|removeAttribute
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|et
operator|!=
literal|null
condition|)
block|{
name|removeAttribute
argument_list|(
name|et
argument_list|)
expr_stmt|;
block|}
name|removeAttributes
argument_list|(
name|annotations
argument_list|)
expr_stmt|;
name|removeAttributes
argument_list|(
name|parameterAnnotations
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
specifier|private
name|void
name|updateLocalVariableTable
parameter_list|(
specifier|final
name|LocalVariableTable
name|a
parameter_list|)
block|{
specifier|final
name|LocalVariable
index|[]
name|lv
init|=
name|a
operator|.
name|getLocalVariableTable
argument_list|()
decl_stmt|;
name|removeLocalVariables
argument_list|()
expr_stmt|;
for|for
control|(
specifier|final
name|LocalVariable
name|l
range|:
name|lv
control|)
block|{
name|InstructionHandle
name|start
init|=
name|il
operator|.
name|findHandle
argument_list|(
name|l
operator|.
name|getStartPC
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|InstructionHandle
name|end
init|=
name|il
operator|.
name|findHandle
argument_list|(
name|l
operator|.
name|getStartPC
argument_list|()
operator|+
name|l
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
comment|// Repair malformed handles
if|if
condition|(
literal|null
operator|==
name|start
condition|)
block|{
name|start
operator|=
name|il
operator|.
name|getStart
argument_list|()
expr_stmt|;
block|}
comment|// end == null => live to end of method
comment|// Since we are recreating the LocalVaraible, we must
comment|// propagate the orig_index to new copy.
name|addLocalVariable
argument_list|(
name|l
operator|.
name|getName
argument_list|()
argument_list|,
name|Type
operator|.
name|getType
argument_list|(
name|l
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|l
operator|.
name|getIndex
argument_list|()
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|l
operator|.
name|getOrigIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|adjustLocalVariableTypeTable
parameter_list|(
specifier|final
name|LocalVariableTable
name|lvt
parameter_list|)
block|{
specifier|final
name|LocalVariable
index|[]
name|lv
init|=
name|lvt
operator|.
name|getLocalVariableTable
argument_list|()
decl_stmt|;
specifier|final
name|LocalVariable
index|[]
name|lvg
init|=
name|local_variable_type_table
operator|.
name|getLocalVariableTypeTable
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|LocalVariable
name|element
range|:
name|lvg
control|)
block|{
for|for
control|(
specifier|final
name|LocalVariable
name|l
range|:
name|lv
control|)
block|{
if|if
condition|(
name|element
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|l
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|element
operator|.
name|getIndex
argument_list|()
operator|==
name|l
operator|.
name|getOrigIndex
argument_list|()
condition|)
block|{
name|element
operator|.
name|setLength
argument_list|(
name|l
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|element
operator|.
name|setStartPC
argument_list|(
name|l
operator|.
name|getStartPC
argument_list|()
argument_list|)
expr_stmt|;
name|element
operator|.
name|setIndex
argument_list|(
name|l
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/**      * Remove all NOPs from the instruction list (if possible) and update every      * object referring to them, i.e., branch instructions, local variables and      * exception handlers.      */
specifier|public
name|void
name|removeNOPs
parameter_list|()
block|{
if|if
condition|(
name|il
operator|!=
literal|null
condition|)
block|{
name|InstructionHandle
name|next
decl_stmt|;
comment|/* Check branch instructions.              */
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|il
operator|.
name|getStart
argument_list|()
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ih
operator|.
name|getNext
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|next
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|ih
operator|.
name|getInstruction
argument_list|()
operator|instanceof
name|NOP
operator|)
condition|)
block|{
try|try
block|{
name|il
operator|.
name|delete
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|TargetLostException
name|e
parameter_list|)
block|{
for|for
control|(
specifier|final
name|InstructionHandle
name|target
range|:
name|e
operator|.
name|getTargets
argument_list|()
control|)
block|{
for|for
control|(
specifier|final
name|InstructionTargeter
name|targeter
range|:
name|target
operator|.
name|getTargeters
argument_list|()
control|)
block|{
name|targeter
operator|.
name|updateTarget
argument_list|(
name|target
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**      * Set maximum number of local variables.      */
specifier|public
name|void
name|setMaxLocals
parameter_list|(
specifier|final
name|int
name|m
parameter_list|)
block|{
name|max_locals
operator|=
name|m
expr_stmt|;
block|}
specifier|public
name|int
name|getMaxLocals
parameter_list|()
block|{
return|return
name|max_locals
return|;
block|}
comment|/**      * Set maximum stack size for this method.      */
specifier|public
name|void
name|setMaxStack
parameter_list|(
specifier|final
name|int
name|m
parameter_list|)
block|{
comment|// TODO could be package-protected?
name|max_stack
operator|=
name|m
expr_stmt|;
block|}
specifier|public
name|int
name|getMaxStack
parameter_list|()
block|{
return|return
name|max_stack
return|;
block|}
comment|/** @return class that contains this method      */
specifier|public
name|String
name|getClassName
parameter_list|()
block|{
return|return
name|class_name
return|;
block|}
specifier|public
name|void
name|setClassName
parameter_list|(
specifier|final
name|String
name|class_name
parameter_list|)
block|{
comment|// TODO could be package-protected?
name|this
operator|.
name|class_name
operator|=
name|class_name
expr_stmt|;
block|}
specifier|public
name|void
name|setReturnType
parameter_list|(
specifier|final
name|Type
name|return_type
parameter_list|)
block|{
name|setType
argument_list|(
name|return_type
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Type
name|getReturnType
parameter_list|()
block|{
return|return
name|getType
argument_list|()
return|;
block|}
specifier|public
name|void
name|setArgumentTypes
parameter_list|(
specifier|final
name|Type
index|[]
name|arg_types
parameter_list|)
block|{
name|this
operator|.
name|arg_types
operator|=
name|arg_types
expr_stmt|;
block|}
specifier|public
name|Type
index|[]
name|getArgumentTypes
parameter_list|()
block|{
return|return
name|arg_types
operator|.
name|clone
argument_list|()
return|;
block|}
specifier|public
name|void
name|setArgumentType
parameter_list|(
specifier|final
name|int
name|i
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|)
block|{
name|arg_types
index|[
name|i
index|]
operator|=
name|type
expr_stmt|;
block|}
specifier|public
name|Type
name|getArgumentType
parameter_list|(
specifier|final
name|int
name|i
parameter_list|)
block|{
return|return
name|arg_types
index|[
name|i
index|]
return|;
block|}
specifier|public
name|void
name|setArgumentNames
parameter_list|(
specifier|final
name|String
index|[]
name|arg_names
parameter_list|)
block|{
name|this
operator|.
name|arg_names
operator|=
name|arg_names
expr_stmt|;
block|}
specifier|public
name|String
index|[]
name|getArgumentNames
parameter_list|()
block|{
return|return
name|arg_names
operator|.
name|clone
argument_list|()
return|;
block|}
specifier|public
name|void
name|setArgumentName
parameter_list|(
specifier|final
name|int
name|i
parameter_list|,
specifier|final
name|String
name|name
parameter_list|)
block|{
name|arg_names
index|[
name|i
index|]
operator|=
name|name
expr_stmt|;
block|}
specifier|public
name|String
name|getArgumentName
parameter_list|(
specifier|final
name|int
name|i
parameter_list|)
block|{
return|return
name|arg_names
index|[
name|i
index|]
return|;
block|}
specifier|public
name|InstructionList
name|getInstructionList
parameter_list|()
block|{
return|return
name|il
return|;
block|}
specifier|public
name|void
name|setInstructionList
parameter_list|(
specifier|final
name|InstructionList
name|il
parameter_list|)
block|{
comment|// TODO could be package-protected?
name|this
operator|.
name|il
operator|=
name|il
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getSignature
parameter_list|()
block|{
return|return
name|Type
operator|.
name|getMethodSignature
argument_list|(
name|super
operator|.
name|getType
argument_list|()
argument_list|,
name|arg_types
argument_list|)
return|;
block|}
comment|/**      * Computes max. stack size by performing control flow analysis.      */
specifier|public
name|void
name|setMaxStack
parameter_list|()
block|{
comment|// TODO could be package-protected? (some tests would need repackaging)
if|if
condition|(
name|il
operator|!=
literal|null
condition|)
block|{
name|max_stack
operator|=
name|getMaxStack
argument_list|(
name|super
operator|.
name|getConstantPool
argument_list|()
argument_list|,
name|il
argument_list|,
name|getExceptionHandlers
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|max_stack
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**      * Compute maximum number of local variables.      */
specifier|public
name|void
name|setMaxLocals
parameter_list|()
block|{
comment|// TODO could be package-protected? (some tests would need repackaging)
if|if
condition|(
name|il
operator|!=
literal|null
condition|)
block|{
name|int
name|max
init|=
name|isStatic
argument_list|()
condition|?
literal|0
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|arg_types
operator|!=
literal|null
condition|)
block|{
for|for
control|(
specifier|final
name|Type
name|arg_type
range|:
name|arg_types
control|)
block|{
name|max
operator|+=
name|arg_type
operator|.
name|getSize
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|il
operator|.
name|getStart
argument_list|()
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|getNext
argument_list|()
control|)
block|{
specifier|final
name|Instruction
name|ins
init|=
name|ih
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|ins
operator|instanceof
name|LocalVariableInstruction
operator|)
operator|||
operator|(
name|ins
operator|instanceof
name|RET
operator|)
operator|||
operator|(
name|ins
operator|instanceof
name|IINC
operator|)
condition|)
block|{
specifier|final
name|int
name|index
init|=
operator|(
operator|(
name|IndexedInstruction
operator|)
name|ins
operator|)
operator|.
name|getIndex
argument_list|()
operator|+
operator|(
operator|(
name|TypedInstruction
operator|)
name|ins
operator|)
operator|.
name|getType
argument_list|(
name|super
operator|.
name|getConstantPool
argument_list|()
argument_list|)
operator|.
name|getSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|index
expr_stmt|;
block|}
block|}
block|}
name|max_locals
operator|=
name|max
expr_stmt|;
block|}
else|else
block|{
name|max_locals
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/** Do not/Do produce attributes code attributesLineNumberTable and      * LocalVariableTable, like javac -O      */
specifier|public
name|void
name|stripAttributes
parameter_list|(
specifier|final
name|boolean
name|flag
parameter_list|)
block|{
name|strip_attributes
operator|=
name|flag
expr_stmt|;
block|}
specifier|static
specifier|final
class|class
name|BranchTarget
block|{
specifier|final
name|InstructionHandle
name|target
decl_stmt|;
specifier|final
name|int
name|stackDepth
decl_stmt|;
name|BranchTarget
parameter_list|(
specifier|final
name|InstructionHandle
name|target
parameter_list|,
specifier|final
name|int
name|stackDepth
parameter_list|)
block|{
name|this
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|this
operator|.
name|stackDepth
operator|=
name|stackDepth
expr_stmt|;
block|}
block|}
specifier|static
specifier|final
class|class
name|BranchStack
block|{
specifier|private
specifier|final
name|Stack
argument_list|<
name|BranchTarget
argument_list|>
name|branchTargets
init|=
operator|new
name|Stack
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Hashtable
argument_list|<
name|InstructionHandle
argument_list|,
name|BranchTarget
argument_list|>
name|visitedTargets
init|=
operator|new
name|Hashtable
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
name|void
name|push
parameter_list|(
specifier|final
name|InstructionHandle
name|target
parameter_list|,
specifier|final
name|int
name|stackDepth
parameter_list|)
block|{
if|if
condition|(
name|visited
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return;
block|}
name|branchTargets
operator|.
name|push
argument_list|(
name|visit
argument_list|(
name|target
argument_list|,
name|stackDepth
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BranchTarget
name|pop
parameter_list|()
block|{
if|if
condition|(
operator|!
name|branchTargets
operator|.
name|empty
argument_list|()
condition|)
block|{
specifier|final
name|BranchTarget
name|bt
init|=
name|branchTargets
operator|.
name|pop
argument_list|()
decl_stmt|;
return|return
name|bt
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|BranchTarget
name|visit
parameter_list|(
specifier|final
name|InstructionHandle
name|target
parameter_list|,
specifier|final
name|int
name|stackDepth
parameter_list|)
block|{
specifier|final
name|BranchTarget
name|bt
init|=
operator|new
name|BranchTarget
argument_list|(
name|target
argument_list|,
name|stackDepth
argument_list|)
decl_stmt|;
name|visitedTargets
operator|.
name|put
argument_list|(
name|target
argument_list|,
name|bt
argument_list|)
expr_stmt|;
return|return
name|bt
return|;
block|}
specifier|private
name|boolean
name|visited
parameter_list|(
specifier|final
name|InstructionHandle
name|target
parameter_list|)
block|{
return|return
name|visitedTargets
operator|.
name|get
argument_list|(
name|target
argument_list|)
operator|!=
literal|null
return|;
block|}
block|}
comment|/**      * Computes stack usage of an instruction list by performing control flow analysis.      *      * @return maximum stack depth used by method      */
specifier|public
specifier|static
name|int
name|getMaxStack
parameter_list|(
specifier|final
name|ConstantPoolGen
name|cp
parameter_list|,
specifier|final
name|InstructionList
name|il
parameter_list|,
specifier|final
name|CodeExceptionGen
index|[]
name|et
parameter_list|)
block|{
specifier|final
name|BranchStack
name|branchTargets
init|=
operator|new
name|BranchStack
argument_list|()
decl_stmt|;
comment|/* Initially, populate the branch stack with the exception          * handlers, because these aren't (necessarily) branched to          * explicitly. in each case, the stack will have depth 1,          * containing the exception object.          */
for|for
control|(
specifier|final
name|CodeExceptionGen
name|element
range|:
name|et
control|)
block|{
specifier|final
name|InstructionHandle
name|handler_pc
init|=
name|element
operator|.
name|getHandlerPC
argument_list|()
decl_stmt|;
if|if
condition|(
name|handler_pc
operator|!=
literal|null
condition|)
block|{
name|branchTargets
operator|.
name|push
argument_list|(
name|handler_pc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|stackDepth
init|=
literal|0
decl_stmt|;
name|int
name|maxStackDepth
init|=
literal|0
decl_stmt|;
name|InstructionHandle
name|ih
init|=
name|il
operator|.
name|getStart
argument_list|()
decl_stmt|;
while|while
condition|(
name|ih
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Instruction
name|instruction
init|=
name|ih
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
specifier|final
name|short
name|opcode
init|=
name|instruction
operator|.
name|getOpcode
argument_list|()
decl_stmt|;
specifier|final
name|int
name|delta
init|=
name|instruction
operator|.
name|produceStack
argument_list|(
name|cp
argument_list|)
operator|-
name|instruction
operator|.
name|consumeStack
argument_list|(
name|cp
argument_list|)
decl_stmt|;
name|stackDepth
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|stackDepth
operator|>
name|maxStackDepth
condition|)
block|{
name|maxStackDepth
operator|=
name|stackDepth
expr_stmt|;
block|}
comment|// choose the next instruction based on whether current is a branch.
if|if
condition|(
name|instruction
operator|instanceof
name|BranchInstruction
condition|)
block|{
specifier|final
name|BranchInstruction
name|branch
init|=
operator|(
name|BranchInstruction
operator|)
name|instruction
decl_stmt|;
if|if
condition|(
name|instruction
operator|instanceof
name|Select
condition|)
block|{
comment|// explore all of the select's targets. the default target is handled below.
specifier|final
name|Select
name|select
init|=
operator|(
name|Select
operator|)
name|branch
decl_stmt|;
specifier|final
name|InstructionHandle
index|[]
name|targets
init|=
name|select
operator|.
name|getTargets
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|InstructionHandle
name|target
range|:
name|targets
control|)
block|{
name|branchTargets
operator|.
name|push
argument_list|(
name|target
argument_list|,
name|stackDepth
argument_list|)
expr_stmt|;
block|}
comment|// nothing to fall through to.
name|ih
operator|=
literal|null
expr_stmt|;
block|}
if|else if
condition|(
operator|!
operator|(
name|branch
operator|instanceof
name|IfInstruction
operator|)
condition|)
block|{
comment|// if an instruction that comes back to following PC,
comment|// push next instruction, with stack depth reduced by 1.
if|if
condition|(
name|opcode
operator|==
name|Const
operator|.
name|JSR
operator|||
name|opcode
operator|==
name|Const
operator|.
name|JSR_W
condition|)
block|{
name|branchTargets
operator|.
name|push
argument_list|(
name|ih
operator|.
name|getNext
argument_list|()
argument_list|,
name|stackDepth
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ih
operator|=
literal|null
expr_stmt|;
block|}
comment|// for all branches, the target of the branch is pushed on the branch stack.
comment|// conditional branches have a fall through case, selects don't, and
comment|// jsr/jsr_w return to the next instruction.
name|branchTargets
operator|.
name|push
argument_list|(
name|branch
operator|.
name|getTarget
argument_list|()
argument_list|,
name|stackDepth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// check for instructions that terminate the method.
if|if
condition|(
name|opcode
operator|==
name|Const
operator|.
name|ATHROW
operator|||
name|opcode
operator|==
name|Const
operator|.
name|RET
operator|||
operator|(
name|opcode
operator|>=
name|Const
operator|.
name|IRETURN
operator|&&
name|opcode
operator|<=
name|Const
operator|.
name|RETURN
operator|)
condition|)
block|{
name|ih
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// normal case, go to the next instruction.
if|if
condition|(
name|ih
operator|!=
literal|null
condition|)
block|{
name|ih
operator|=
name|ih
operator|.
name|getNext
argument_list|()
expr_stmt|;
block|}
comment|// if we have no more instructions, see if there are any deferred branches to explore.
if|if
condition|(
name|ih
operator|==
literal|null
condition|)
block|{
specifier|final
name|BranchTarget
name|bt
init|=
name|branchTargets
operator|.
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|bt
operator|!=
literal|null
condition|)
block|{
name|ih
operator|=
name|bt
operator|.
name|target
expr_stmt|;
name|stackDepth
operator|=
name|bt
operator|.
name|stackDepth
expr_stmt|;
block|}
block|}
block|}
return|return
name|maxStackDepth
return|;
block|}
specifier|private
name|List
argument_list|<
name|MethodObserver
argument_list|>
name|observers
decl_stmt|;
comment|/** Add observer for this object.      */
specifier|public
name|void
name|addObserver
parameter_list|(
specifier|final
name|MethodObserver
name|o
parameter_list|)
block|{
if|if
condition|(
name|observers
operator|==
literal|null
condition|)
block|{
name|observers
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|observers
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
comment|/** Remove observer for this object.      */
specifier|public
name|void
name|removeObserver
parameter_list|(
specifier|final
name|MethodObserver
name|o
parameter_list|)
block|{
if|if
condition|(
name|observers
operator|!=
literal|null
condition|)
block|{
name|observers
operator|.
name|remove
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Call notify() method on all observers. This method is not called      * automatically whenever the state has changed, but has to be      * called by the user after he has finished editing the object.      */
specifier|public
name|void
name|update
parameter_list|()
block|{
if|if
condition|(
name|observers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
specifier|final
name|MethodObserver
name|observer
range|:
name|observers
control|)
block|{
name|observer
operator|.
name|notify
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Return string representation close to declaration format,      * `public static void main(String[]) throws IOException', e.g.      *      * @return String representation of the method.      */
annotation|@
name|Override
specifier|public
specifier|final
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|String
name|access
init|=
name|Utility
operator|.
name|accessToString
argument_list|(
name|super
operator|.
name|getAccessFlags
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|signature
init|=
name|Type
operator|.
name|getMethodSignature
argument_list|(
name|super
operator|.
name|getType
argument_list|()
argument_list|,
name|arg_types
argument_list|)
decl_stmt|;
name|signature
operator|=
name|Utility
operator|.
name|methodSignatureToString
argument_list|(
name|signature
argument_list|,
name|super
operator|.
name|getName
argument_list|()
argument_list|,
name|access
argument_list|,
literal|true
argument_list|,
name|getLocalVariableTable
argument_list|(
name|super
operator|.
name|getConstantPool
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
name|signature
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Attribute
name|a
range|:
name|getAttributes
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|a
operator|instanceof
name|Code
operator|)
operator|||
operator|(
name|a
operator|instanceof
name|ExceptionTable
operator|)
operator|)
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" ["
argument_list|)
operator|.
name|append
argument_list|(
name|a
argument_list|)
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|throws_vec
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
specifier|final
name|String
name|throwsDescriptor
range|:
name|throws_vec
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"\n\t\tthrows "
argument_list|)
operator|.
name|append
argument_list|(
name|throwsDescriptor
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** @return deep copy of this method      */
specifier|public
name|MethodGen
name|copy
parameter_list|(
specifier|final
name|String
name|class_name
parameter_list|,
specifier|final
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
specifier|final
name|Method
name|m
init|=
operator|(
operator|(
name|MethodGen
operator|)
name|clone
argument_list|()
operator|)
operator|.
name|getMethod
argument_list|()
decl_stmt|;
specifier|final
name|MethodGen
name|mg
init|=
operator|new
name|MethodGen
argument_list|(
name|m
argument_list|,
name|class_name
argument_list|,
name|super
operator|.
name|getConstantPool
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|super
operator|.
name|getConstantPool
argument_list|()
operator|!=
name|cp
condition|)
block|{
name|mg
operator|.
name|setConstantPool
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|mg
operator|.
name|getInstructionList
argument_list|()
operator|.
name|replaceConstantPool
argument_list|(
name|super
operator|.
name|getConstantPool
argument_list|()
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
name|mg
return|;
block|}
comment|//J5TODO: Should param_annotations be an array of arrays? Rather than an array of lists, this
comment|// is more likely to suggest to the caller it is readonly (which a List does not).
comment|/**      * Return a list of AnnotationGen objects representing parameter annotations      * @since 6.0      */
specifier|public
name|List
argument_list|<
name|AnnotationEntryGen
argument_list|>
name|getAnnotationsOnParameter
parameter_list|(
specifier|final
name|int
name|i
parameter_list|)
block|{
name|ensureExistingParameterAnnotationsUnpacked
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|hasParameterAnnotations
operator|||
name|i
operator|>
name|arg_types
operator|.
name|length
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|param_annotations
index|[
name|i
index|]
return|;
block|}
comment|/**      * Goes through the attributes on the method and identifies any that are      * RuntimeParameterAnnotations, extracting their contents and storing them      * as parameter annotations. There are two kinds of parameter annotation -      * visible and invisible. Once they have been unpacked, these attributes are      * deleted. (The annotations will be rebuilt as attributes when someone      * builds a Method object out of this MethodGen object).      */
specifier|private
name|void
name|ensureExistingParameterAnnotationsUnpacked
parameter_list|()
block|{
if|if
condition|(
name|haveUnpackedParameterAnnotations
condition|)
block|{
return|return;
block|}
comment|// Find attributes that contain parameter annotation data
specifier|final
name|Attribute
index|[]
name|attrs
init|=
name|getAttributes
argument_list|()
decl_stmt|;
name|ParameterAnnotations
name|paramAnnVisAttr
init|=
literal|null
decl_stmt|;
name|ParameterAnnotations
name|paramAnnInvisAttr
init|=
literal|null
decl_stmt|;
for|for
control|(
specifier|final
name|Attribute
name|attribute
range|:
name|attrs
control|)
block|{
if|if
condition|(
name|attribute
operator|instanceof
name|ParameterAnnotations
condition|)
block|{
comment|// Initialize param_annotations
if|if
condition|(
operator|!
name|hasParameterAnnotations
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// OK
specifier|final
name|List
argument_list|<
name|AnnotationEntryGen
argument_list|>
index|[]
name|parmList
init|=
operator|new
name|List
index|[
name|arg_types
operator|.
name|length
index|]
decl_stmt|;
name|param_annotations
operator|=
name|parmList
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|arg_types
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|param_annotations
index|[
name|j
index|]
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
block|}
name|hasParameterAnnotations
operator|=
literal|true
expr_stmt|;
specifier|final
name|ParameterAnnotations
name|rpa
init|=
operator|(
name|ParameterAnnotations
operator|)
name|attribute
decl_stmt|;
if|if
condition|(
name|rpa
operator|instanceof
name|RuntimeVisibleParameterAnnotations
condition|)
block|{
name|paramAnnVisAttr
operator|=
name|rpa
expr_stmt|;
block|}
else|else
block|{
name|paramAnnInvisAttr
operator|=
name|rpa
expr_stmt|;
block|}
specifier|final
name|ParameterAnnotationEntry
index|[]
name|parameterAnnotationEntries
init|=
name|rpa
operator|.
name|getParameterAnnotationEntries
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|parameterAnnotationEntries
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
comment|// This returns Annotation[] ...
specifier|final
name|ParameterAnnotationEntry
name|immutableArray
init|=
name|rpa
operator|.
name|getParameterAnnotationEntries
argument_list|()
index|[
name|j
index|]
decl_stmt|;
comment|// ... which needs transforming into an AnnotationGen[] ...
specifier|final
name|List
argument_list|<
name|AnnotationEntryGen
argument_list|>
name|mutable
init|=
name|makeMutableVersion
argument_list|(
name|immutableArray
operator|.
name|getAnnotationEntries
argument_list|()
argument_list|)
decl_stmt|;
comment|// ... then add these to any we already know about
name|param_annotations
index|[
name|j
index|]
operator|.
name|addAll
argument_list|(
name|mutable
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|paramAnnVisAttr
operator|!=
literal|null
condition|)
block|{
name|removeAttribute
argument_list|(
name|paramAnnVisAttr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|paramAnnInvisAttr
operator|!=
literal|null
condition|)
block|{
name|removeAttribute
argument_list|(
name|paramAnnInvisAttr
argument_list|)
expr_stmt|;
block|}
name|haveUnpackedParameterAnnotations
operator|=
literal|true
expr_stmt|;
block|}
specifier|private
name|List
argument_list|<
name|AnnotationEntryGen
argument_list|>
name|makeMutableVersion
parameter_list|(
specifier|final
name|AnnotationEntry
index|[]
name|mutableArray
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|AnnotationEntryGen
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|AnnotationEntry
name|element
range|:
name|mutableArray
control|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|new
name|AnnotationEntryGen
argument_list|(
name|element
argument_list|,
name|getConstantPool
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
name|void
name|addParameterAnnotation
parameter_list|(
specifier|final
name|int
name|parameterIndex
parameter_list|,
specifier|final
name|AnnotationEntryGen
name|annotation
parameter_list|)
block|{
name|ensureExistingParameterAnnotationsUnpacked
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|hasParameterAnnotations
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// OK
specifier|final
name|List
argument_list|<
name|AnnotationEntryGen
argument_list|>
index|[]
name|parmList
init|=
operator|new
name|List
index|[
name|arg_types
operator|.
name|length
index|]
decl_stmt|;
name|param_annotations
operator|=
name|parmList
expr_stmt|;
name|hasParameterAnnotations
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|AnnotationEntryGen
argument_list|>
name|existingAnnotations
init|=
name|param_annotations
index|[
name|parameterIndex
index|]
decl_stmt|;
if|if
condition|(
name|existingAnnotations
operator|!=
literal|null
condition|)
block|{
name|existingAnnotations
operator|.
name|add
argument_list|(
name|annotation
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|List
argument_list|<
name|AnnotationEntryGen
argument_list|>
name|l
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|l
operator|.
name|add
argument_list|(
name|annotation
argument_list|)
expr_stmt|;
name|param_annotations
index|[
name|parameterIndex
index|]
operator|=
name|l
expr_stmt|;
block|}
block|}
comment|/**      * @return Comparison strategy object      */
specifier|public
specifier|static
name|BCELComparator
name|getComparator
parameter_list|()
block|{
return|return
name|bcelComparator
return|;
block|}
comment|/**      * @param comparator Comparison strategy object      */
specifier|public
specifier|static
name|void
name|setComparator
parameter_list|(
specifier|final
name|BCELComparator
name|comparator
parameter_list|)
block|{
name|bcelComparator
operator|=
name|comparator
expr_stmt|;
block|}
comment|/**      * Return value as defined by given BCELComparator strategy.      * By default two MethodGen objects are said to be equal when      * their names and signatures are equal.      *      * @see java.lang.Object#equals(java.lang.Object)      */
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
specifier|final
name|Object
name|obj
parameter_list|)
block|{
return|return
name|bcelComparator
operator|.
name|equals
argument_list|(
name|this
argument_list|,
name|obj
argument_list|)
return|;
block|}
comment|/**      * Return value as defined by given BCELComparator strategy.      * By default return the hashcode of the method's name XOR signature.      *      * @see java.lang.Object#hashCode()      */
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|bcelComparator
operator|.
name|hashCode
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
end_class

end_unit

