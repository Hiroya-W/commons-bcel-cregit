begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|generic
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|bcel
operator|.
name|Const
import|;
end_import

begin_comment
comment|/**  * Instances of this class may be used, e.g., to generate typed versions of instructions. Its main purpose is to be used  * as the byte code generating backend of a compiler. You can subclass it to add your own create methods.  *<p>  * Note: The static createXXX methods return singleton instances from the {@link InstructionConst} class.  *</p>  *  * @see Const  * @see InstructionConst  */
end_comment

begin_class
specifier|public
class|class
name|InstructionFactory
implements|implements
name|InstructionConstants
block|{
specifier|private
specifier|static
class|class
name|MethodObject
block|{
specifier|final
name|Type
index|[]
name|argTypes
decl_stmt|;
specifier|final
name|Type
name|resultType
decl_stmt|;
specifier|final
name|String
name|className
decl_stmt|;
specifier|final
name|String
name|name
decl_stmt|;
name|MethodObject
parameter_list|(
specifier|final
name|String
name|c
parameter_list|,
specifier|final
name|String
name|n
parameter_list|,
specifier|final
name|Type
name|r
parameter_list|,
specifier|final
name|Type
index|[]
name|a
parameter_list|)
block|{
name|this
operator|.
name|className
operator|=
name|c
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|n
expr_stmt|;
name|this
operator|.
name|resultType
operator|=
name|r
expr_stmt|;
name|this
operator|.
name|argTypes
operator|=
name|a
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|String
name|APPEND
init|=
literal|"append"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|FQCN_STRING_BUFFER
init|=
literal|"java.lang.StringBuffer"
decl_stmt|;
comment|// N.N. These must agree with the order of Constants.T_CHAR through T_LONG
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|shortNames
init|=
block|{
literal|"C"
block|,
literal|"F"
block|,
literal|"D"
block|,
literal|"B"
block|,
literal|"S"
block|,
literal|"I"
block|,
literal|"L"
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|MethodObject
index|[]
name|appendMethodObjects
init|=
block|{
operator|new
name|MethodObject
argument_list|(
name|FQCN_STRING_BUFFER
argument_list|,
name|APPEND
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|STRING
block|}
argument_list|)
block|,
operator|new
name|MethodObject
argument_list|(
name|FQCN_STRING_BUFFER
argument_list|,
name|APPEND
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|OBJECT
block|}
argument_list|)
block|,
literal|null
block|,
literal|null
block|,
comment|// indices 2, 3
operator|new
name|MethodObject
argument_list|(
name|FQCN_STRING_BUFFER
argument_list|,
name|APPEND
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|BOOLEAN
block|}
argument_list|)
block|,
operator|new
name|MethodObject
argument_list|(
name|FQCN_STRING_BUFFER
argument_list|,
name|APPEND
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|CHAR
block|}
argument_list|)
block|,
operator|new
name|MethodObject
argument_list|(
name|FQCN_STRING_BUFFER
argument_list|,
name|APPEND
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|FLOAT
block|}
argument_list|)
block|,
operator|new
name|MethodObject
argument_list|(
name|FQCN_STRING_BUFFER
argument_list|,
name|APPEND
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|DOUBLE
block|}
argument_list|)
block|,
operator|new
name|MethodObject
argument_list|(
name|FQCN_STRING_BUFFER
argument_list|,
name|APPEND
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|INT
block|}
argument_list|)
block|,
operator|new
name|MethodObject
argument_list|(
name|FQCN_STRING_BUFFER
argument_list|,
name|APPEND
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|INT
block|}
argument_list|)
block|,
comment|// No append(byte)
operator|new
name|MethodObject
argument_list|(
name|FQCN_STRING_BUFFER
argument_list|,
name|APPEND
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|INT
block|}
argument_list|)
block|,
comment|// No append(short)
operator|new
name|MethodObject
argument_list|(
name|FQCN_STRING_BUFFER
argument_list|,
name|APPEND
argument_list|,
name|Type
operator|.
name|STRINGBUFFER
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|LONG
block|}
argument_list|)
block|}
decl_stmt|;
comment|/**      * @param type type of elements of array, i.e., array.getElementType()      */
specifier|public
specifier|static
name|ArrayInstruction
name|createArrayLoad
parameter_list|(
specifier|final
name|Type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Const
operator|.
name|T_BOOLEAN
case|:
case|case
name|Const
operator|.
name|T_BYTE
case|:
return|return
name|InstructionConst
operator|.
name|BALOAD
return|;
case|case
name|Const
operator|.
name|T_CHAR
case|:
return|return
name|InstructionConst
operator|.
name|CALOAD
return|;
case|case
name|Const
operator|.
name|T_SHORT
case|:
return|return
name|InstructionConst
operator|.
name|SALOAD
return|;
case|case
name|Const
operator|.
name|T_INT
case|:
return|return
name|InstructionConst
operator|.
name|IALOAD
return|;
case|case
name|Const
operator|.
name|T_FLOAT
case|:
return|return
name|InstructionConst
operator|.
name|FALOAD
return|;
case|case
name|Const
operator|.
name|T_DOUBLE
case|:
return|return
name|InstructionConst
operator|.
name|DALOAD
return|;
case|case
name|Const
operator|.
name|T_LONG
case|:
return|return
name|InstructionConst
operator|.
name|LALOAD
return|;
case|case
name|Const
operator|.
name|T_ARRAY
case|:
case|case
name|Const
operator|.
name|T_OBJECT
case|:
return|return
name|InstructionConst
operator|.
name|AALOAD
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/**      * @param type type of elements of array, i.e., array.getElementType()      */
specifier|public
specifier|static
name|ArrayInstruction
name|createArrayStore
parameter_list|(
specifier|final
name|Type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Const
operator|.
name|T_BOOLEAN
case|:
case|case
name|Const
operator|.
name|T_BYTE
case|:
return|return
name|InstructionConst
operator|.
name|BASTORE
return|;
case|case
name|Const
operator|.
name|T_CHAR
case|:
return|return
name|InstructionConst
operator|.
name|CASTORE
return|;
case|case
name|Const
operator|.
name|T_SHORT
case|:
return|return
name|InstructionConst
operator|.
name|SASTORE
return|;
case|case
name|Const
operator|.
name|T_INT
case|:
return|return
name|InstructionConst
operator|.
name|IASTORE
return|;
case|case
name|Const
operator|.
name|T_FLOAT
case|:
return|return
name|InstructionConst
operator|.
name|FASTORE
return|;
case|case
name|Const
operator|.
name|T_DOUBLE
case|:
return|return
name|InstructionConst
operator|.
name|DASTORE
return|;
case|case
name|Const
operator|.
name|T_LONG
case|:
return|return
name|InstructionConst
operator|.
name|LASTORE
return|;
case|case
name|Const
operator|.
name|T_ARRAY
case|:
case|case
name|Const
operator|.
name|T_OBJECT
case|:
return|return
name|InstructionConst
operator|.
name|AASTORE
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|ArithmeticInstruction
name|createBinaryDoubleOp
parameter_list|(
specifier|final
name|char
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'-'
case|:
return|return
name|InstructionConst
operator|.
name|DSUB
return|;
case|case
literal|'+'
case|:
return|return
name|InstructionConst
operator|.
name|DADD
return|;
case|case
literal|'*'
case|:
return|return
name|InstructionConst
operator|.
name|DMUL
return|;
case|case
literal|'/'
case|:
return|return
name|InstructionConst
operator|.
name|DDIV
return|;
case|case
literal|'%'
case|:
return|return
name|InstructionConst
operator|.
name|DREM
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid operand "
operator|+
name|op
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|ArithmeticInstruction
name|createBinaryFloatOp
parameter_list|(
specifier|final
name|char
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'-'
case|:
return|return
name|InstructionConst
operator|.
name|FSUB
return|;
case|case
literal|'+'
case|:
return|return
name|InstructionConst
operator|.
name|FADD
return|;
case|case
literal|'*'
case|:
return|return
name|InstructionConst
operator|.
name|FMUL
return|;
case|case
literal|'/'
case|:
return|return
name|InstructionConst
operator|.
name|FDIV
return|;
case|case
literal|'%'
case|:
return|return
name|InstructionConst
operator|.
name|FREM
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid operand "
operator|+
name|op
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|ArithmeticInstruction
name|createBinaryIntOp
parameter_list|(
specifier|final
name|char
name|first
parameter_list|,
specifier|final
name|String
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|first
condition|)
block|{
case|case
literal|'-'
case|:
return|return
name|InstructionConst
operator|.
name|ISUB
return|;
case|case
literal|'+'
case|:
return|return
name|InstructionConst
operator|.
name|IADD
return|;
case|case
literal|'%'
case|:
return|return
name|InstructionConst
operator|.
name|IREM
return|;
case|case
literal|'*'
case|:
return|return
name|InstructionConst
operator|.
name|IMUL
return|;
case|case
literal|'/'
case|:
return|return
name|InstructionConst
operator|.
name|IDIV
return|;
case|case
literal|'&'
case|:
return|return
name|InstructionConst
operator|.
name|IAND
return|;
case|case
literal|'|'
case|:
return|return
name|InstructionConst
operator|.
name|IOR
return|;
case|case
literal|'^'
case|:
return|return
name|InstructionConst
operator|.
name|IXOR
return|;
case|case
literal|'<'
case|:
return|return
name|InstructionConst
operator|.
name|ISHL
return|;
case|case
literal|'>'
case|:
return|return
name|op
operator|.
name|equals
argument_list|(
literal|">>>"
argument_list|)
condition|?
name|InstructionConst
operator|.
name|IUSHR
else|:
name|InstructionConst
operator|.
name|ISHR
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid operand "
operator|+
name|op
argument_list|)
throw|;
block|}
block|}
comment|/**      * Create an invokedynamic instruction.      *      * @param bootstrap_index index into the bootstrap_methods array      * @param name name of the called method      * @param ret_type return type of method      * @param argTypes argument types of method      * @see Const      */
comment|/*      * createInvokeDynamic only needed if instrumentation code wants to generate a new invokedynamic instruction. I don't      * think we need.      *      * public InvokeInstruction createInvokeDynamic( int bootstrap_index, String name, Type ret_type, Type[] argTypes) {      * int index; int nargs = 0; String signature = Type.getMethodSignature(ret_type, argTypes); for (int i = 0; i<      * argTypes.length; i++) { nargs += argTypes[i].getSize(); } // UNDONE - needs to be added to ConstantPoolGen //index      * = cp.addInvokeDynamic(bootstrap_index, name, signature); index = 0; return new INVOKEDYNAMIC(index); }      */
specifier|private
specifier|static
name|ArithmeticInstruction
name|createBinaryLongOp
parameter_list|(
specifier|final
name|char
name|first
parameter_list|,
specifier|final
name|String
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|first
condition|)
block|{
case|case
literal|'-'
case|:
return|return
name|InstructionConst
operator|.
name|LSUB
return|;
case|case
literal|'+'
case|:
return|return
name|InstructionConst
operator|.
name|LADD
return|;
case|case
literal|'%'
case|:
return|return
name|InstructionConst
operator|.
name|LREM
return|;
case|case
literal|'*'
case|:
return|return
name|InstructionConst
operator|.
name|LMUL
return|;
case|case
literal|'/'
case|:
return|return
name|InstructionConst
operator|.
name|LDIV
return|;
case|case
literal|'&'
case|:
return|return
name|InstructionConst
operator|.
name|LAND
return|;
case|case
literal|'|'
case|:
return|return
name|InstructionConst
operator|.
name|LOR
return|;
case|case
literal|'^'
case|:
return|return
name|InstructionConst
operator|.
name|LXOR
return|;
case|case
literal|'<'
case|:
return|return
name|InstructionConst
operator|.
name|LSHL
return|;
case|case
literal|'>'
case|:
return|return
name|op
operator|.
name|equals
argument_list|(
literal|">>>"
argument_list|)
condition|?
name|InstructionConst
operator|.
name|LUSHR
else|:
name|InstructionConst
operator|.
name|LSHR
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid operand "
operator|+
name|op
argument_list|)
throw|;
block|}
block|}
comment|/**      * Create binary operation for simple basic types, such as int and float.      *      * @param op operation, such as "+", "*", "&lt;&lt;", etc.      */
specifier|public
specifier|static
name|ArithmeticInstruction
name|createBinaryOperation
parameter_list|(
specifier|final
name|String
name|op
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|)
block|{
specifier|final
name|char
name|first
init|=
name|op
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Const
operator|.
name|T_BYTE
case|:
case|case
name|Const
operator|.
name|T_SHORT
case|:
case|case
name|Const
operator|.
name|T_INT
case|:
case|case
name|Const
operator|.
name|T_CHAR
case|:
return|return
name|createBinaryIntOp
argument_list|(
name|first
argument_list|,
name|op
argument_list|)
return|;
case|case
name|Const
operator|.
name|T_LONG
case|:
return|return
name|createBinaryLongOp
argument_list|(
name|first
argument_list|,
name|op
argument_list|)
return|;
case|case
name|Const
operator|.
name|T_FLOAT
case|:
return|return
name|createBinaryFloatOp
argument_list|(
name|first
argument_list|)
return|;
case|case
name|Const
operator|.
name|T_DOUBLE
case|:
return|return
name|createBinaryDoubleOp
argument_list|(
name|first
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/**      * Create branch instruction by given opcode, except LOOKUPSWITCH and TABLESWITCH. For those you should use the SWITCH      * compound instruction.      */
specifier|public
specifier|static
name|BranchInstruction
name|createBranchInstruction
parameter_list|(
specifier|final
name|short
name|opcode
parameter_list|,
specifier|final
name|InstructionHandle
name|target
parameter_list|)
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|Const
operator|.
name|IFEQ
case|:
return|return
operator|new
name|IFEQ
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IFNE
case|:
return|return
operator|new
name|IFNE
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IFLT
case|:
return|return
operator|new
name|IFLT
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IFGE
case|:
return|return
operator|new
name|IFGE
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IFGT
case|:
return|return
operator|new
name|IFGT
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IFLE
case|:
return|return
operator|new
name|IFLE
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IF_ICMPEQ
case|:
return|return
operator|new
name|IF_ICMPEQ
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IF_ICMPNE
case|:
return|return
operator|new
name|IF_ICMPNE
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IF_ICMPLT
case|:
return|return
operator|new
name|IF_ICMPLT
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IF_ICMPGE
case|:
return|return
operator|new
name|IF_ICMPGE
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IF_ICMPGT
case|:
return|return
operator|new
name|IF_ICMPGT
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IF_ICMPLE
case|:
return|return
operator|new
name|IF_ICMPLE
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IF_ACMPEQ
case|:
return|return
operator|new
name|IF_ACMPEQ
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IF_ACMPNE
case|:
return|return
operator|new
name|IF_ACMPNE
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|GOTO
case|:
return|return
operator|new
name|GOTO
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|JSR
case|:
return|return
operator|new
name|JSR
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IFNULL
case|:
return|return
operator|new
name|IFNULL
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|IFNONNULL
case|:
return|return
operator|new
name|IFNONNULL
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|GOTO_W
case|:
return|return
operator|new
name|GOTO_W
argument_list|(
name|target
argument_list|)
return|;
case|case
name|Const
operator|.
name|JSR_W
case|:
return|return
operator|new
name|JSR_W
argument_list|(
name|target
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid opcode: "
operator|+
name|opcode
argument_list|)
throw|;
block|}
block|}
comment|/**      * @param size size of operand, either 1 (int, e.g.) or 2 (double)      */
specifier|public
specifier|static
name|StackInstruction
name|createDup
parameter_list|(
specifier|final
name|int
name|size
parameter_list|)
block|{
return|return
name|size
operator|==
literal|2
condition|?
name|InstructionConst
operator|.
name|DUP2
else|:
name|InstructionConst
operator|.
name|DUP
return|;
block|}
comment|/**      * @param size size of operand, either 1 (int, e.g.) or 2 (double)      */
specifier|public
specifier|static
name|StackInstruction
name|createDup_1
parameter_list|(
specifier|final
name|int
name|size
parameter_list|)
block|{
return|return
name|size
operator|==
literal|2
condition|?
name|InstructionConst
operator|.
name|DUP2_X1
else|:
name|InstructionConst
operator|.
name|DUP_X1
return|;
block|}
comment|/**      * @param size size of operand, either 1 (int, e.g.) or 2 (double)      */
specifier|public
specifier|static
name|StackInstruction
name|createDup_2
parameter_list|(
specifier|final
name|int
name|size
parameter_list|)
block|{
return|return
name|size
operator|==
literal|2
condition|?
name|InstructionConst
operator|.
name|DUP2_X2
else|:
name|InstructionConst
operator|.
name|DUP_X2
return|;
block|}
comment|/**      * @param index index of local variable      */
specifier|public
specifier|static
name|LocalVariableInstruction
name|createLoad
parameter_list|(
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Const
operator|.
name|T_BOOLEAN
case|:
case|case
name|Const
operator|.
name|T_CHAR
case|:
case|case
name|Const
operator|.
name|T_BYTE
case|:
case|case
name|Const
operator|.
name|T_SHORT
case|:
case|case
name|Const
operator|.
name|T_INT
case|:
return|return
operator|new
name|ILOAD
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Const
operator|.
name|T_FLOAT
case|:
return|return
operator|new
name|FLOAD
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Const
operator|.
name|T_DOUBLE
case|:
return|return
operator|new
name|DLOAD
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Const
operator|.
name|T_LONG
case|:
return|return
operator|new
name|LLOAD
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Const
operator|.
name|T_ARRAY
case|:
case|case
name|Const
operator|.
name|T_OBJECT
case|:
return|return
operator|new
name|ALOAD
argument_list|(
name|index
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/**      * Create "null" value for reference types, 0 for basic types like int      */
specifier|public
specifier|static
name|Instruction
name|createNull
parameter_list|(
specifier|final
name|Type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Const
operator|.
name|T_ARRAY
case|:
case|case
name|Const
operator|.
name|T_OBJECT
case|:
return|return
name|InstructionConst
operator|.
name|ACONST_NULL
return|;
case|case
name|Const
operator|.
name|T_INT
case|:
case|case
name|Const
operator|.
name|T_SHORT
case|:
case|case
name|Const
operator|.
name|T_BOOLEAN
case|:
case|case
name|Const
operator|.
name|T_CHAR
case|:
case|case
name|Const
operator|.
name|T_BYTE
case|:
return|return
name|InstructionConst
operator|.
name|ICONST_0
return|;
case|case
name|Const
operator|.
name|T_FLOAT
case|:
return|return
name|InstructionConst
operator|.
name|FCONST_0
return|;
case|case
name|Const
operator|.
name|T_DOUBLE
case|:
return|return
name|InstructionConst
operator|.
name|DCONST_0
return|;
case|case
name|Const
operator|.
name|T_LONG
case|:
return|return
name|InstructionConst
operator|.
name|LCONST_0
return|;
case|case
name|Const
operator|.
name|T_VOID
case|:
return|return
name|InstructionConst
operator|.
name|NOP
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid type: "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/**      * @param size size of operand, either 1 (int, e.g.) or 2 (double)      */
specifier|public
specifier|static
name|StackInstruction
name|createPop
parameter_list|(
specifier|final
name|int
name|size
parameter_list|)
block|{
return|return
name|size
operator|==
literal|2
condition|?
name|InstructionConst
operator|.
name|POP2
else|:
name|InstructionConst
operator|.
name|POP
return|;
block|}
comment|/**      * Create typed return      */
specifier|public
specifier|static
name|ReturnInstruction
name|createReturn
parameter_list|(
specifier|final
name|Type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Const
operator|.
name|T_ARRAY
case|:
case|case
name|Const
operator|.
name|T_OBJECT
case|:
return|return
name|InstructionConst
operator|.
name|ARETURN
return|;
case|case
name|Const
operator|.
name|T_INT
case|:
case|case
name|Const
operator|.
name|T_SHORT
case|:
case|case
name|Const
operator|.
name|T_BOOLEAN
case|:
case|case
name|Const
operator|.
name|T_CHAR
case|:
case|case
name|Const
operator|.
name|T_BYTE
case|:
return|return
name|InstructionConst
operator|.
name|IRETURN
return|;
case|case
name|Const
operator|.
name|T_FLOAT
case|:
return|return
name|InstructionConst
operator|.
name|FRETURN
return|;
case|case
name|Const
operator|.
name|T_DOUBLE
case|:
return|return
name|InstructionConst
operator|.
name|DRETURN
return|;
case|case
name|Const
operator|.
name|T_LONG
case|:
return|return
name|InstructionConst
operator|.
name|LRETURN
return|;
case|case
name|Const
operator|.
name|T_VOID
case|:
return|return
name|InstructionConst
operator|.
name|RETURN
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid type: "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/**      * @param index index of local variable      */
specifier|public
specifier|static
name|LocalVariableInstruction
name|createStore
parameter_list|(
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Const
operator|.
name|T_BOOLEAN
case|:
case|case
name|Const
operator|.
name|T_CHAR
case|:
case|case
name|Const
operator|.
name|T_BYTE
case|:
case|case
name|Const
operator|.
name|T_SHORT
case|:
case|case
name|Const
operator|.
name|T_INT
case|:
return|return
operator|new
name|ISTORE
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Const
operator|.
name|T_FLOAT
case|:
return|return
operator|new
name|FSTORE
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Const
operator|.
name|T_DOUBLE
case|:
return|return
operator|new
name|DSTORE
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Const
operator|.
name|T_LONG
case|:
return|return
operator|new
name|LSTORE
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Const
operator|.
name|T_ARRAY
case|:
case|case
name|Const
operator|.
name|T_OBJECT
case|:
return|return
operator|new
name|ASTORE
argument_list|(
name|index
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid type "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/**      * Create reference to `this'      */
specifier|public
specifier|static
name|Instruction
name|createThis
parameter_list|()
block|{
return|return
operator|new
name|ALOAD
argument_list|(
literal|0
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isString
parameter_list|(
specifier|final
name|Type
name|type
parameter_list|)
block|{
return|return
name|type
operator|instanceof
name|ObjectType
operator|&&
operator|(
operator|(
name|ObjectType
operator|)
name|type
operator|)
operator|.
name|getClassName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"java.lang.String"
argument_list|)
return|;
block|}
comment|/**      * @deprecated (since 6.0) will be made private; do not access directly, use getter/setter      */
annotation|@
name|Deprecated
specifier|protected
name|ClassGen
name|cg
decl_stmt|;
comment|/**      * @deprecated (since 6.0) will be made private; do not access directly, use getter/setter      */
annotation|@
name|Deprecated
specifier|protected
name|ConstantPoolGen
name|cp
decl_stmt|;
comment|/**      * Initialize with ClassGen object      */
specifier|public
name|InstructionFactory
parameter_list|(
specifier|final
name|ClassGen
name|cg
parameter_list|)
block|{
name|this
argument_list|(
name|cg
argument_list|,
name|cg
operator|.
name|getConstantPool
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|InstructionFactory
parameter_list|(
specifier|final
name|ClassGen
name|cg
parameter_list|,
specifier|final
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
name|this
operator|.
name|cg
operator|=
name|cg
expr_stmt|;
name|this
operator|.
name|cp
operator|=
name|cp
expr_stmt|;
block|}
comment|/**      * Initialize just with ConstantPoolGen object      */
specifier|public
name|InstructionFactory
parameter_list|(
specifier|final
name|ConstantPoolGen
name|cp
parameter_list|)
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Instruction
name|createAppend
parameter_list|(
specifier|final
name|Type
name|type
parameter_list|)
block|{
specifier|final
name|byte
name|t
init|=
name|type
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|isString
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
name|createInvoke
argument_list|(
name|appendMethodObjects
index|[
literal|0
index|]
argument_list|,
name|Const
operator|.
name|INVOKEVIRTUAL
argument_list|)
return|;
block|}
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|Const
operator|.
name|T_BOOLEAN
case|:
case|case
name|Const
operator|.
name|T_CHAR
case|:
case|case
name|Const
operator|.
name|T_FLOAT
case|:
case|case
name|Const
operator|.
name|T_DOUBLE
case|:
case|case
name|Const
operator|.
name|T_BYTE
case|:
case|case
name|Const
operator|.
name|T_SHORT
case|:
case|case
name|Const
operator|.
name|T_INT
case|:
case|case
name|Const
operator|.
name|T_LONG
case|:
return|return
name|createInvoke
argument_list|(
name|appendMethodObjects
index|[
name|t
index|]
argument_list|,
name|Const
operator|.
name|INVOKEVIRTUAL
argument_list|)
return|;
case|case
name|Const
operator|.
name|T_ARRAY
case|:
case|case
name|Const
operator|.
name|T_OBJECT
case|:
return|return
name|createInvoke
argument_list|(
name|appendMethodObjects
index|[
literal|1
index|]
argument_list|,
name|Const
operator|.
name|INVOKEVIRTUAL
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No append for this type? "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
comment|/**      * Create conversion operation for two stack operands, this may be an I2C, instruction, e.g., if the operands are basic      * types and CHECKCAST if they are reference types.      */
specifier|public
name|Instruction
name|createCast
parameter_list|(
specifier|final
name|Type
name|srcType
parameter_list|,
specifier|final
name|Type
name|destType
parameter_list|)
block|{
if|if
condition|(
name|srcType
operator|instanceof
name|BasicType
operator|&&
name|destType
operator|instanceof
name|BasicType
condition|)
block|{
specifier|final
name|byte
name|dest
init|=
name|destType
operator|.
name|getType
argument_list|()
decl_stmt|;
name|byte
name|src
init|=
name|srcType
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|dest
operator|==
name|Const
operator|.
name|T_LONG
operator|&&
operator|(
name|src
operator|==
name|Const
operator|.
name|T_CHAR
operator|||
name|src
operator|==
name|Const
operator|.
name|T_BYTE
operator|||
name|src
operator|==
name|Const
operator|.
name|T_SHORT
operator|)
condition|)
block|{
name|src
operator|=
name|Const
operator|.
name|T_INT
expr_stmt|;
block|}
specifier|final
name|String
name|name
init|=
literal|"org.apache.bcel.generic."
operator|+
name|shortNames
index|[
name|src
operator|-
name|Const
operator|.
name|T_CHAR
index|]
operator|+
literal|"2"
operator|+
name|shortNames
index|[
name|dest
operator|-
name|Const
operator|.
name|T_CHAR
index|]
decl_stmt|;
name|Instruction
name|i
init|=
literal|null
decl_stmt|;
try|try
block|{
name|i
operator|=
operator|(
name|Instruction
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|name
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Could not find instruction: "
operator|+
name|name
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|i
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|srcType
operator|instanceof
name|ReferenceType
operator|)
operator|||
operator|!
operator|(
name|destType
operator|instanceof
name|ReferenceType
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot cast "
operator|+
name|srcType
operator|+
literal|" to "
operator|+
name|destType
argument_list|)
throw|;
block|}
if|if
condition|(
name|destType
operator|instanceof
name|ArrayType
condition|)
block|{
return|return
operator|new
name|CHECKCAST
argument_list|(
name|cp
operator|.
name|addArrayClass
argument_list|(
operator|(
name|ArrayType
operator|)
name|destType
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|new
name|CHECKCAST
argument_list|(
name|cp
operator|.
name|addClass
argument_list|(
operator|(
operator|(
name|ObjectType
operator|)
name|destType
operator|)
operator|.
name|getClassName
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|CHECKCAST
name|createCheckCast
parameter_list|(
specifier|final
name|ReferenceType
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
block|{
return|return
operator|new
name|CHECKCAST
argument_list|(
name|cp
operator|.
name|addArrayClass
argument_list|(
operator|(
name|ArrayType
operator|)
name|t
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|new
name|CHECKCAST
argument_list|(
name|cp
operator|.
name|addClass
argument_list|(
operator|(
name|ObjectType
operator|)
name|t
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Uses PUSH to push a constant value onto the stack.      *      * @param value must be of type Number, Boolean, Character or String      */
specifier|public
name|Instruction
name|createConstant
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
name|PUSH
name|push
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
name|push
operator|=
operator|new
name|PUSH
argument_list|(
name|cp
argument_list|,
operator|(
name|Number
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
name|push
operator|=
operator|new
name|PUSH
argument_list|(
name|cp
argument_list|,
operator|(
name|String
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
name|push
operator|=
operator|new
name|PUSH
argument_list|(
name|cp
argument_list|,
operator|(
name|Boolean
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
name|push
operator|=
operator|new
name|PUSH
argument_list|(
name|cp
argument_list|,
operator|(
name|Character
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Illegal type: "
operator|+
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|push
operator|.
name|getInstruction
argument_list|()
return|;
block|}
comment|/**      * Create a field instruction.      *      * @param className name of the accessed class      * @param name name of the referenced field      * @param type type of field      * @param kind how to access, i.e., GETFIELD, PUTFIELD, GETSTATIC, PUTSTATIC      * @see Const      */
specifier|public
name|FieldInstruction
name|createFieldAccess
parameter_list|(
specifier|final
name|String
name|className
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|short
name|kind
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
specifier|final
name|String
name|signature
init|=
name|type
operator|.
name|getSignature
argument_list|()
decl_stmt|;
name|index
operator|=
name|cp
operator|.
name|addFieldref
argument_list|(
name|className
argument_list|,
name|name
argument_list|,
name|signature
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|Const
operator|.
name|GETFIELD
case|:
return|return
operator|new
name|GETFIELD
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Const
operator|.
name|PUTFIELD
case|:
return|return
operator|new
name|PUTFIELD
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Const
operator|.
name|GETSTATIC
case|:
return|return
operator|new
name|GETSTATIC
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Const
operator|.
name|PUTSTATIC
case|:
return|return
operator|new
name|PUTSTATIC
argument_list|(
name|index
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown getfield kind:"
operator|+
name|kind
argument_list|)
throw|;
block|}
block|}
specifier|public
name|GETFIELD
name|createGetField
parameter_list|(
specifier|final
name|String
name|className
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Type
name|t
parameter_list|)
block|{
return|return
operator|new
name|GETFIELD
argument_list|(
name|cp
operator|.
name|addFieldref
argument_list|(
name|className
argument_list|,
name|name
argument_list|,
name|t
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|GETSTATIC
name|createGetStatic
parameter_list|(
specifier|final
name|String
name|className
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Type
name|t
parameter_list|)
block|{
return|return
operator|new
name|GETSTATIC
argument_list|(
name|cp
operator|.
name|addFieldref
argument_list|(
name|className
argument_list|,
name|name
argument_list|,
name|t
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|INSTANCEOF
name|createInstanceOf
parameter_list|(
specifier|final
name|ReferenceType
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
block|{
return|return
operator|new
name|INSTANCEOF
argument_list|(
name|cp
operator|.
name|addArrayClass
argument_list|(
operator|(
name|ArrayType
operator|)
name|t
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|new
name|INSTANCEOF
argument_list|(
name|cp
operator|.
name|addClass
argument_list|(
operator|(
name|ObjectType
operator|)
name|t
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|InvokeInstruction
name|createInvoke
parameter_list|(
specifier|final
name|MethodObject
name|m
parameter_list|,
specifier|final
name|short
name|kind
parameter_list|)
block|{
return|return
name|createInvoke
argument_list|(
name|m
operator|.
name|className
argument_list|,
name|m
operator|.
name|name
argument_list|,
name|m
operator|.
name|resultType
argument_list|,
name|m
operator|.
name|argTypes
argument_list|,
name|kind
argument_list|)
return|;
block|}
comment|/**      * Create an invoke instruction. (Except for invokedynamic.)      *      * @param className name of the called class      * @param name name of the called method      * @param retType return type of method      * @param argTypes argument types of method      * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL, or INVOKESPECIAL      * @see Const      */
specifier|public
name|InvokeInstruction
name|createInvoke
parameter_list|(
specifier|final
name|String
name|className
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Type
name|retType
parameter_list|,
specifier|final
name|Type
index|[]
name|argTypes
parameter_list|,
specifier|final
name|short
name|kind
parameter_list|)
block|{
return|return
name|createInvoke
argument_list|(
name|className
argument_list|,
name|name
argument_list|,
name|retType
argument_list|,
name|argTypes
argument_list|,
name|kind
argument_list|,
name|kind
operator|==
name|Const
operator|.
name|INVOKEINTERFACE
argument_list|)
return|;
block|}
comment|/**      * Create an invoke instruction. (Except for invokedynamic.)      *      * @param className name of the called class      * @param name name of the called method      * @param retType return type of method      * @param argTypes argument types of method      * @param kind how to invoke: INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL, or INVOKESPECIAL      * @param useInterface force use of InterfaceMethodref      * @return A new InvokeInstruction.      * @since 6.5.0      */
specifier|public
name|InvokeInstruction
name|createInvoke
parameter_list|(
specifier|final
name|String
name|className
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Type
name|retType
parameter_list|,
specifier|final
name|Type
index|[]
name|argTypes
parameter_list|,
specifier|final
name|short
name|kind
parameter_list|,
specifier|final
name|boolean
name|useInterface
parameter_list|)
block|{
if|if
condition|(
name|kind
operator|!=
name|Const
operator|.
name|INVOKESPECIAL
operator|&&
name|kind
operator|!=
name|Const
operator|.
name|INVOKEVIRTUAL
operator|&&
name|kind
operator|!=
name|Const
operator|.
name|INVOKESTATIC
operator|&&
name|kind
operator|!=
name|Const
operator|.
name|INVOKEINTERFACE
operator|&&
name|kind
operator|!=
name|Const
operator|.
name|INVOKEDYNAMIC
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown invoke kind: "
operator|+
name|kind
argument_list|)
throw|;
block|}
name|int
name|index
decl_stmt|;
name|int
name|nargs
init|=
literal|0
decl_stmt|;
specifier|final
name|String
name|signature
init|=
name|Type
operator|.
name|getMethodSignature
argument_list|(
name|retType
argument_list|,
name|argTypes
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Type
name|argType
range|:
name|argTypes
control|)
block|{
name|nargs
operator|+=
name|argType
operator|.
name|getSize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|useInterface
condition|)
block|{
name|index
operator|=
name|cp
operator|.
name|addInterfaceMethodref
argument_list|(
name|className
argument_list|,
name|name
argument_list|,
name|signature
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|index
operator|=
name|cp
operator|.
name|addMethodref
argument_list|(
name|className
argument_list|,
name|name
argument_list|,
name|signature
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|Const
operator|.
name|INVOKESPECIAL
case|:
return|return
operator|new
name|INVOKESPECIAL
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Const
operator|.
name|INVOKEVIRTUAL
case|:
return|return
operator|new
name|INVOKEVIRTUAL
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Const
operator|.
name|INVOKESTATIC
case|:
return|return
operator|new
name|INVOKESTATIC
argument_list|(
name|index
argument_list|)
return|;
case|case
name|Const
operator|.
name|INVOKEINTERFACE
case|:
return|return
operator|new
name|INVOKEINTERFACE
argument_list|(
name|index
argument_list|,
name|nargs
operator|+
literal|1
argument_list|)
return|;
case|case
name|Const
operator|.
name|INVOKEDYNAMIC
case|:
return|return
operator|new
name|INVOKEDYNAMIC
argument_list|(
name|index
argument_list|)
return|;
default|default:
comment|// Can't happen
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unknown invoke kind: "
operator|+
name|kind
argument_list|)
throw|;
block|}
block|}
specifier|public
name|NEW
name|createNew
parameter_list|(
specifier|final
name|ObjectType
name|t
parameter_list|)
block|{
return|return
operator|new
name|NEW
argument_list|(
name|cp
operator|.
name|addClass
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|NEW
name|createNew
parameter_list|(
specifier|final
name|String
name|s
parameter_list|)
block|{
return|return
name|createNew
argument_list|(
name|ObjectType
operator|.
name|getInstance
argument_list|(
name|s
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Create new array of given size and type.      *      * @return an instruction that creates the corresponding array at runtime, i.e. is an AllocationInstruction      */
specifier|public
name|Instruction
name|createNewArray
parameter_list|(
specifier|final
name|Type
name|t
parameter_list|,
specifier|final
name|short
name|dim
parameter_list|)
block|{
if|if
condition|(
name|dim
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|ObjectType
condition|)
block|{
return|return
operator|new
name|ANEWARRAY
argument_list|(
name|cp
operator|.
name|addClass
argument_list|(
operator|(
name|ObjectType
operator|)
name|t
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
block|{
return|return
operator|new
name|ANEWARRAY
argument_list|(
name|cp
operator|.
name|addArrayClass
argument_list|(
operator|(
name|ArrayType
operator|)
name|t
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|new
name|NEWARRAY
argument_list|(
name|t
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
name|ArrayType
name|at
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ArrayType
condition|)
block|{
name|at
operator|=
operator|(
name|ArrayType
operator|)
name|t
expr_stmt|;
block|}
else|else
block|{
name|at
operator|=
operator|new
name|ArrayType
argument_list|(
name|t
argument_list|,
name|dim
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|MULTIANEWARRAY
argument_list|(
name|cp
operator|.
name|addArrayClass
argument_list|(
name|at
argument_list|)
argument_list|,
name|dim
argument_list|)
return|;
block|}
comment|/**      * Create a call to the most popular System.out.println() method.      *      * @param s the string to print      */
specifier|public
name|InstructionList
name|createPrintln
parameter_list|(
specifier|final
name|String
name|s
parameter_list|)
block|{
specifier|final
name|InstructionList
name|il
init|=
operator|new
name|InstructionList
argument_list|()
decl_stmt|;
name|il
operator|.
name|append
argument_list|(
name|createGetStatic
argument_list|(
literal|"java.lang.System"
argument_list|,
literal|"out"
argument_list|,
name|Type
operator|.
name|getType
argument_list|(
literal|"Ljava/io/PrintStream;"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|il
operator|.
name|append
argument_list|(
operator|new
name|PUSH
argument_list|(
name|cp
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|MethodObject
name|methodObject
init|=
operator|new
name|MethodObject
argument_list|(
literal|"java.io.PrintStream"
argument_list|,
literal|"println"
argument_list|,
name|Type
operator|.
name|VOID
argument_list|,
operator|new
name|Type
index|[]
block|{
name|Type
operator|.
name|getType
argument_list|(
literal|"Ljava/lang/String;"
argument_list|)
block|}
argument_list|)
decl_stmt|;
name|il
operator|.
name|append
argument_list|(
name|createInvoke
argument_list|(
name|methodObject
argument_list|,
name|Const
operator|.
name|INVOKEVIRTUAL
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|il
return|;
block|}
specifier|public
name|PUTFIELD
name|createPutField
parameter_list|(
specifier|final
name|String
name|className
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Type
name|t
parameter_list|)
block|{
return|return
operator|new
name|PUTFIELD
argument_list|(
name|cp
operator|.
name|addFieldref
argument_list|(
name|className
argument_list|,
name|name
argument_list|,
name|t
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|PUTSTATIC
name|createPutStatic
parameter_list|(
specifier|final
name|String
name|className
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Type
name|t
parameter_list|)
block|{
return|return
operator|new
name|PUTSTATIC
argument_list|(
name|cp
operator|.
name|addFieldref
argument_list|(
name|className
argument_list|,
name|name
argument_list|,
name|t
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|ClassGen
name|getClassGen
parameter_list|()
block|{
return|return
name|cg
return|;
block|}
specifier|public
name|ConstantPoolGen
name|getConstantPool
parameter_list|()
block|{
return|return
name|cp
return|;
block|}
specifier|public
name|void
name|setClassGen
parameter_list|(
specifier|final
name|ClassGen
name|c
parameter_list|)
block|{
name|cg
operator|=
name|c
expr_stmt|;
block|}
specifier|public
name|void
name|setConstantPool
parameter_list|(
specifier|final
name|ConstantPoolGen
name|c
parameter_list|)
block|{
name|cp
operator|=
name|c
expr_stmt|;
block|}
block|}
end_class

end_unit

