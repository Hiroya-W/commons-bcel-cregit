begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|bcel6
operator|.
name|generic
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|bcel6
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|bcel6
operator|.
name|classfile
operator|.
name|Constant
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|bcel6
operator|.
name|util
operator|.
name|ByteSequence
import|;
end_import

begin_comment
comment|/**   * This class is a container for a list of<a  * href="Instruction.html">Instruction</a> objects. Instructions can  * be appended, inserted, moved, deleted, etc.. Instructions are being  * wrapped into<a  * href="InstructionHandle.html">InstructionHandles</a> objects that  * are returned upon append/insert operations. They give the user  * (read only) access to the list structure, such that it can be traversed and  * manipulated in a controlled way.  *  * A list is finally dumped to a byte code array with<a  * href="#getByteCode()">getByteCode</a>.  *  * @version $Id$  * @author<A HREF="mailto:m.dahm@gmx.de">M. Dahm</A>  * @see     Instruction  * @see     InstructionHandle  * @see BranchHandle  */
end_comment

begin_class
specifier|public
class|class
name|InstructionList
implements|implements
name|Serializable
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2651389055345707857L
decl_stmt|;
specifier|private
name|InstructionHandle
name|start
init|=
literal|null
decl_stmt|,
name|end
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|length
init|=
literal|0
decl_stmt|;
comment|// number of elements in list
specifier|private
name|int
index|[]
name|byte_positions
decl_stmt|;
comment|// byte code offsets corresponding to instructions
comment|/**      * Create (empty) instruction list.      */
specifier|public
name|InstructionList
parameter_list|()
block|{
block|}
comment|/**      * Create instruction list containing one instruction.      * @param i initial instruction      */
specifier|public
name|InstructionList
parameter_list|(
name|Instruction
name|i
parameter_list|)
block|{
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create instruction list containing one instruction.      * @param i initial instruction      */
specifier|public
name|InstructionList
parameter_list|(
name|BranchInstruction
name|i
parameter_list|)
block|{
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/**      * Initialize list with (nonnull) compound instruction. Consumes argument      * list, i.e., it becomes empty.      *      * @param c compound instruction (list)      */
specifier|public
name|InstructionList
parameter_list|(
name|CompoundInstruction
name|c
parameter_list|)
block|{
name|append
argument_list|(
name|c
operator|.
name|getInstructionList
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Test for empty list.      */
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|start
operator|==
literal|null
return|;
block|}
comment|//&& end == null
comment|/**      * Find the target instruction (handle) that corresponds to the given target      * position (byte code offset).      *      * @param ihs array of instruction handles, i.e. il.getInstructionHandles()      * @param pos array of positions corresponding to ihs, i.e. il.getInstructionPositions()      * @param count length of arrays      * @param target target position to search for      * @return target position's instruction handle if available      */
specifier|public
specifier|static
name|InstructionHandle
name|findHandle
parameter_list|(
name|InstructionHandle
index|[]
name|ihs
parameter_list|,
name|int
index|[]
name|pos
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|int
name|l
init|=
literal|0
decl_stmt|,
name|r
init|=
name|count
operator|-
literal|1
decl_stmt|;
comment|/* Do a binary search since the pos array is orderd.          */
do|do
block|{
name|int
name|i
init|=
operator|(
name|l
operator|+
name|r
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|j
init|=
name|pos
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|j
operator|==
name|target
condition|)
block|{
return|return
name|ihs
index|[
name|i
index|]
return|;
block|}
if|else if
condition|(
name|target
operator|<
name|j
condition|)
block|{
name|r
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|l
operator|<=
name|r
condition|)
do|;
return|return
literal|null
return|;
block|}
comment|/**      * Get instruction handle for instruction at byte code position pos.      * This only works properly, if the list is freshly initialized from a byte array or      * setPositions() has been called before this method.      *      * @param pos byte code position to search for      * @return target position's instruction handle if available      */
specifier|public
name|InstructionHandle
name|findHandle
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|int
index|[]
name|positions
init|=
name|byte_positions
decl_stmt|;
name|InstructionHandle
name|ih
init|=
name|start
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|positions
index|[
name|i
index|]
operator|==
name|pos
condition|)
block|{
return|return
name|ih
return|;
block|}
name|ih
operator|=
name|ih
operator|.
name|next
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Initialize instruction list from byte array.      *      * @param code byte array containing the instructions      */
specifier|public
name|InstructionList
parameter_list|(
name|byte
index|[]
name|code
parameter_list|)
block|{
name|ByteSequence
name|bytes
init|=
operator|new
name|ByteSequence
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|InstructionHandle
index|[]
name|ihs
init|=
operator|new
name|InstructionHandle
index|[
name|code
operator|.
name|length
index|]
decl_stmt|;
name|int
index|[]
name|pos
init|=
operator|new
name|int
index|[
name|code
operator|.
name|length
index|]
decl_stmt|;
comment|// Can't be more than that
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|// Contains actual length
comment|/* Pass 1: Create an object for each byte code and append them          * to the list.          */
try|try
block|{
while|while
condition|(
name|bytes
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Remember byte offset and associate it with the instruction
name|int
name|off
init|=
name|bytes
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|pos
index|[
name|count
index|]
operator|=
name|off
expr_stmt|;
comment|/* Read one instruction from the byte stream, the byte position is set                  * accordingly.                  */
name|Instruction
name|i
init|=
name|Instruction
operator|.
name|readInstruction
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|InstructionHandle
name|ih
decl_stmt|;
if|if
condition|(
name|i
operator|instanceof
name|BranchInstruction
condition|)
block|{
name|ih
operator|=
name|append
argument_list|(
operator|(
name|BranchInstruction
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ih
operator|=
name|append
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|ih
operator|.
name|setPosition
argument_list|(
name|off
argument_list|)
expr_stmt|;
name|ihs
index|[
name|count
index|]
operator|=
name|ih
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|byte_positions
operator|=
operator|new
name|int
index|[
name|count
index|]
expr_stmt|;
comment|// Trim to proper size
name|System
operator|.
name|arraycopy
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|,
name|byte_positions
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Pass 2: Look for BranchInstruction and update their targets, i.e.,          * convert offsets to instruction handles.          */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ihs
index|[
name|i
index|]
operator|instanceof
name|BranchHandle
condition|)
block|{
name|BranchInstruction
name|bi
init|=
operator|(
name|BranchInstruction
operator|)
name|ihs
index|[
name|i
index|]
operator|.
name|instruction
decl_stmt|;
name|int
name|target
init|=
name|bi
operator|.
name|position
operator|+
name|bi
operator|.
name|getIndex
argument_list|()
decl_stmt|;
comment|/* Byte code position:                  * relative -> absolute. */
comment|// Search for target position
name|InstructionHandle
name|ih
init|=
name|findHandle
argument_list|(
name|ihs
argument_list|,
name|pos
argument_list|,
name|count
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|ih
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Couldn't find target for branch: "
operator|+
name|bi
argument_list|)
throw|;
block|}
name|bi
operator|.
name|setTarget
argument_list|(
name|ih
argument_list|)
expr_stmt|;
comment|// Update target
comment|// If it is a Select instruction, update all branch targets
if|if
condition|(
name|bi
operator|instanceof
name|Select
condition|)
block|{
comment|// Either LOOKUPSWITCH or TABLESWITCH
name|Select
name|s
init|=
operator|(
name|Select
operator|)
name|bi
decl_stmt|;
name|int
index|[]
name|indices
init|=
name|s
operator|.
name|getIndices
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|indices
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|target
operator|=
name|bi
operator|.
name|position
operator|+
name|indices
index|[
name|j
index|]
expr_stmt|;
name|ih
operator|=
name|findHandle
argument_list|(
name|ihs
argument_list|,
name|pos
argument_list|,
name|count
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|ih
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Couldn't find target for switch: "
operator|+
name|bi
argument_list|)
throw|;
block|}
name|s
operator|.
name|setTarget
argument_list|(
name|j
argument_list|,
name|ih
argument_list|)
expr_stmt|;
comment|// Update target
block|}
block|}
block|}
block|}
block|}
comment|/**      * Append another list after instruction (handle) ih contained in this list.      * Consumes argument list, i.e., it becomes empty.      *      * @param ih where to append the instruction list       * @param il Instruction list to append to this one      * @return instruction handle pointing to the<B>first</B> appended instruction      */
specifier|public
name|InstructionHandle
name|append
parameter_list|(
name|InstructionHandle
name|ih
parameter_list|,
name|InstructionList
name|il
parameter_list|)
block|{
if|if
condition|(
name|il
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Appending null InstructionList"
argument_list|)
throw|;
block|}
if|if
condition|(
name|il
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ih
return|;
block|}
name|InstructionHandle
name|next
init|=
name|ih
operator|.
name|next
decl_stmt|,
name|ret
init|=
name|il
operator|.
name|start
decl_stmt|;
name|ih
operator|.
name|next
operator|=
name|il
operator|.
name|start
expr_stmt|;
name|il
operator|.
name|start
operator|.
name|prev
operator|=
name|ih
expr_stmt|;
name|il
operator|.
name|end
operator|.
name|next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|!=
literal|null
condition|)
block|{
name|next
operator|.
name|prev
operator|=
name|il
operator|.
name|end
expr_stmt|;
block|}
else|else
block|{
name|end
operator|=
name|il
operator|.
name|end
expr_stmt|;
comment|// Update end ...
block|}
name|length
operator|+=
name|il
operator|.
name|length
expr_stmt|;
comment|// Update length
name|il
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**      * Append another list after instruction i contained in this list.      * Consumes argument list, i.e., it becomes empty.      *      * @param i  where to append the instruction list       * @param il Instruction list to append to this one      * @return instruction handle pointing to the<B>first</B> appended instruction      */
specifier|public
name|InstructionHandle
name|append
parameter_list|(
name|Instruction
name|i
parameter_list|,
name|InstructionList
name|il
parameter_list|)
block|{
name|InstructionHandle
name|ih
decl_stmt|;
if|if
condition|(
operator|(
name|ih
operator|=
name|findInstruction2
argument_list|(
name|i
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Instruction "
operator|+
name|i
operator|+
literal|" is not contained in this list."
argument_list|)
throw|;
block|}
return|return
name|append
argument_list|(
name|ih
argument_list|,
name|il
argument_list|)
return|;
block|}
comment|/**      * Append another list to this one.      * Consumes argument list, i.e., it becomes empty.      *      * @param il list to append to end of this list      * @return instruction handle of the<B>first</B> appended instruction      */
specifier|public
name|InstructionHandle
name|append
parameter_list|(
name|InstructionList
name|il
parameter_list|)
block|{
if|if
condition|(
name|il
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Appending null InstructionList"
argument_list|)
throw|;
block|}
if|if
condition|(
name|il
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
name|start
operator|=
name|il
operator|.
name|start
expr_stmt|;
name|end
operator|=
name|il
operator|.
name|end
expr_stmt|;
name|length
operator|=
name|il
operator|.
name|length
expr_stmt|;
name|il
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|start
return|;
block|}
else|else
block|{
return|return
name|append
argument_list|(
name|end
argument_list|,
name|il
argument_list|)
return|;
comment|// was end.instruction
block|}
block|}
comment|/**      * Append an instruction to the end of this list.      *      * @param ih instruction to append      */
specifier|private
name|void
name|append
parameter_list|(
name|InstructionHandle
name|ih
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
name|start
operator|=
name|end
operator|=
name|ih
expr_stmt|;
name|ih
operator|.
name|next
operator|=
name|ih
operator|.
name|prev
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|end
operator|.
name|next
operator|=
name|ih
expr_stmt|;
name|ih
operator|.
name|prev
operator|=
name|end
expr_stmt|;
name|ih
operator|.
name|next
operator|=
literal|null
expr_stmt|;
name|end
operator|=
name|ih
expr_stmt|;
block|}
name|length
operator|++
expr_stmt|;
comment|// Update length
block|}
comment|/**      * Append an instruction to the end of this list.      *      * @param i instruction to append      * @return instruction handle of the appended instruction      */
specifier|public
name|InstructionHandle
name|append
parameter_list|(
name|Instruction
name|i
parameter_list|)
block|{
name|InstructionHandle
name|ih
init|=
name|InstructionHandle
operator|.
name|getInstructionHandle
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|append
argument_list|(
name|ih
argument_list|)
expr_stmt|;
return|return
name|ih
return|;
block|}
comment|/**      * Append a branch instruction to the end of this list.      *      * @param i branch instruction to append      * @return branch instruction handle of the appended instruction      */
specifier|public
name|BranchHandle
name|append
parameter_list|(
name|BranchInstruction
name|i
parameter_list|)
block|{
name|BranchHandle
name|ih
init|=
name|BranchHandle
operator|.
name|getBranchHandle
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|append
argument_list|(
name|ih
argument_list|)
expr_stmt|;
return|return
name|ih
return|;
block|}
comment|/**      * Append a single instruction j after another instruction i, which      * must be in this list of course!      *      * @param i Instruction in list      * @param j Instruction to append after i in list      * @return instruction handle of the first appended instruction      */
specifier|public
name|InstructionHandle
name|append
parameter_list|(
name|Instruction
name|i
parameter_list|,
name|Instruction
name|j
parameter_list|)
block|{
return|return
name|append
argument_list|(
name|i
argument_list|,
operator|new
name|InstructionList
argument_list|(
name|j
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Append a compound instruction, after instruction i.      *      * @param i Instruction in list      * @param c The composite instruction (containing an InstructionList)      * @return instruction handle of the first appended instruction      */
specifier|public
name|InstructionHandle
name|append
parameter_list|(
name|Instruction
name|i
parameter_list|,
name|CompoundInstruction
name|c
parameter_list|)
block|{
return|return
name|append
argument_list|(
name|i
argument_list|,
name|c
operator|.
name|getInstructionList
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Append a compound instruction.      *      * @param c The composite instruction (containing an InstructionList)      * @return instruction handle of the first appended instruction      */
specifier|public
name|InstructionHandle
name|append
parameter_list|(
name|CompoundInstruction
name|c
parameter_list|)
block|{
return|return
name|append
argument_list|(
name|c
operator|.
name|getInstructionList
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Append a compound instruction.      *      * @param ih where to append the instruction list       * @param c The composite instruction (containing an InstructionList)      * @return instruction handle of the first appended instruction      */
specifier|public
name|InstructionHandle
name|append
parameter_list|(
name|InstructionHandle
name|ih
parameter_list|,
name|CompoundInstruction
name|c
parameter_list|)
block|{
return|return
name|append
argument_list|(
name|ih
argument_list|,
name|c
operator|.
name|getInstructionList
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Append an instruction after instruction (handle) ih contained in this list.      *      * @param ih where to append the instruction list       * @param i Instruction to append      * @return instruction handle pointing to the<B>first</B> appended instruction      */
specifier|public
name|InstructionHandle
name|append
parameter_list|(
name|InstructionHandle
name|ih
parameter_list|,
name|Instruction
name|i
parameter_list|)
block|{
return|return
name|append
argument_list|(
name|ih
argument_list|,
operator|new
name|InstructionList
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Append an instruction after instruction (handle) ih contained in this list.      *      * @param ih where to append the instruction list       * @param i Instruction to append      * @return instruction handle pointing to the<B>first</B> appended instruction      */
specifier|public
name|BranchHandle
name|append
parameter_list|(
name|InstructionHandle
name|ih
parameter_list|,
name|BranchInstruction
name|i
parameter_list|)
block|{
name|BranchHandle
name|bh
init|=
name|BranchHandle
operator|.
name|getBranchHandle
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|InstructionList
name|il
init|=
operator|new
name|InstructionList
argument_list|()
decl_stmt|;
name|il
operator|.
name|append
argument_list|(
name|bh
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|ih
argument_list|,
name|il
argument_list|)
expr_stmt|;
return|return
name|bh
return|;
block|}
comment|/**      * Insert another list before Instruction handle ih contained in this list.      * Consumes argument list, i.e., it becomes empty.      *      * @param ih  where to append the instruction list       * @param il Instruction list to insert      * @return instruction handle of the first inserted instruction      */
specifier|public
name|InstructionHandle
name|insert
parameter_list|(
name|InstructionHandle
name|ih
parameter_list|,
name|InstructionList
name|il
parameter_list|)
block|{
if|if
condition|(
name|il
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Inserting null InstructionList"
argument_list|)
throw|;
block|}
if|if
condition|(
name|il
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ih
return|;
block|}
name|InstructionHandle
name|prev
init|=
name|ih
operator|.
name|prev
decl_stmt|,
name|ret
init|=
name|il
operator|.
name|start
decl_stmt|;
name|ih
operator|.
name|prev
operator|=
name|il
operator|.
name|end
expr_stmt|;
name|il
operator|.
name|end
operator|.
name|next
operator|=
name|ih
expr_stmt|;
name|il
operator|.
name|start
operator|.
name|prev
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
block|{
name|prev
operator|.
name|next
operator|=
name|il
operator|.
name|start
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|il
operator|.
name|start
expr_stmt|;
comment|// Update start ...
block|}
name|length
operator|+=
name|il
operator|.
name|length
expr_stmt|;
comment|// Update length
name|il
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**      * Insert another list.         *      * @param il list to insert before start of this list      * @return instruction handle of the first inserted instruction      */
specifier|public
name|InstructionHandle
name|insert
parameter_list|(
name|InstructionList
name|il
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
name|append
argument_list|(
name|il
argument_list|)
expr_stmt|;
comment|// Code is identical for this case
return|return
name|start
return|;
block|}
else|else
block|{
return|return
name|insert
argument_list|(
name|start
argument_list|,
name|il
argument_list|)
return|;
block|}
block|}
comment|/**      * Insert an instruction at start of this list.      *      * @param ih instruction to insert      */
specifier|private
name|void
name|insert
parameter_list|(
name|InstructionHandle
name|ih
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|()
condition|)
block|{
name|start
operator|=
name|end
operator|=
name|ih
expr_stmt|;
name|ih
operator|.
name|next
operator|=
name|ih
operator|.
name|prev
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|start
operator|.
name|prev
operator|=
name|ih
expr_stmt|;
name|ih
operator|.
name|next
operator|=
name|start
expr_stmt|;
name|ih
operator|.
name|prev
operator|=
literal|null
expr_stmt|;
name|start
operator|=
name|ih
expr_stmt|;
block|}
name|length
operator|++
expr_stmt|;
block|}
comment|/**      * Insert another list before Instruction i contained in this list.      * Consumes argument list, i.e., it becomes empty.      *      * @param i  where to append the instruction list       * @param il Instruction list to insert      * @return instruction handle pointing to the first inserted instruction,      * i.e., il.getStart()      */
specifier|public
name|InstructionHandle
name|insert
parameter_list|(
name|Instruction
name|i
parameter_list|,
name|InstructionList
name|il
parameter_list|)
block|{
name|InstructionHandle
name|ih
decl_stmt|;
if|if
condition|(
operator|(
name|ih
operator|=
name|findInstruction1
argument_list|(
name|i
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Instruction "
operator|+
name|i
operator|+
literal|" is not contained in this list."
argument_list|)
throw|;
block|}
return|return
name|insert
argument_list|(
name|ih
argument_list|,
name|il
argument_list|)
return|;
block|}
comment|/**      * Insert an instruction at start of this list.      *      * @param i instruction to insert      * @return instruction handle of the inserted instruction      */
specifier|public
name|InstructionHandle
name|insert
parameter_list|(
name|Instruction
name|i
parameter_list|)
block|{
name|InstructionHandle
name|ih
init|=
name|InstructionHandle
operator|.
name|getInstructionHandle
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|insert
argument_list|(
name|ih
argument_list|)
expr_stmt|;
return|return
name|ih
return|;
block|}
comment|/**      * Insert a branch instruction at start of this list.      *      * @param i branch instruction to insert      * @return branch instruction handle of the appended instruction      */
specifier|public
name|BranchHandle
name|insert
parameter_list|(
name|BranchInstruction
name|i
parameter_list|)
block|{
name|BranchHandle
name|ih
init|=
name|BranchHandle
operator|.
name|getBranchHandle
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|insert
argument_list|(
name|ih
argument_list|)
expr_stmt|;
return|return
name|ih
return|;
block|}
comment|/**      * Insert a single instruction j before another instruction i, which      * must be in this list of course!      *      * @param i Instruction in list      * @param j Instruction to insert before i in list      * @return instruction handle of the first inserted instruction      */
specifier|public
name|InstructionHandle
name|insert
parameter_list|(
name|Instruction
name|i
parameter_list|,
name|Instruction
name|j
parameter_list|)
block|{
return|return
name|insert
argument_list|(
name|i
argument_list|,
operator|new
name|InstructionList
argument_list|(
name|j
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Insert a compound instruction before instruction i.      *      * @param i Instruction in list      * @param c The composite instruction (containing an InstructionList)      * @return instruction handle of the first inserted instruction      */
specifier|public
name|InstructionHandle
name|insert
parameter_list|(
name|Instruction
name|i
parameter_list|,
name|CompoundInstruction
name|c
parameter_list|)
block|{
return|return
name|insert
argument_list|(
name|i
argument_list|,
name|c
operator|.
name|getInstructionList
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Insert a compound instruction.      *      * @param c The composite instruction (containing an InstructionList)      * @return instruction handle of the first inserted instruction      */
specifier|public
name|InstructionHandle
name|insert
parameter_list|(
name|CompoundInstruction
name|c
parameter_list|)
block|{
return|return
name|insert
argument_list|(
name|c
operator|.
name|getInstructionList
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Insert an instruction before instruction (handle) ih contained in this list.      *      * @param ih where to insert to the instruction list       * @param i Instruction to insert      * @return instruction handle of the first inserted instruction      */
specifier|public
name|InstructionHandle
name|insert
parameter_list|(
name|InstructionHandle
name|ih
parameter_list|,
name|Instruction
name|i
parameter_list|)
block|{
return|return
name|insert
argument_list|(
name|ih
argument_list|,
operator|new
name|InstructionList
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Insert a compound instruction.      *      * @param ih where to insert the instruction list       * @param c The composite instruction (containing an InstructionList)      * @return instruction handle of the first inserted instruction      */
specifier|public
name|InstructionHandle
name|insert
parameter_list|(
name|InstructionHandle
name|ih
parameter_list|,
name|CompoundInstruction
name|c
parameter_list|)
block|{
return|return
name|insert
argument_list|(
name|ih
argument_list|,
name|c
operator|.
name|getInstructionList
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Insert an instruction before instruction (handle) ih contained in this list.      *      * @param ih where to insert to the instruction list       * @param i Instruction to insert      * @return instruction handle of the first inserted instruction      */
specifier|public
name|BranchHandle
name|insert
parameter_list|(
name|InstructionHandle
name|ih
parameter_list|,
name|BranchInstruction
name|i
parameter_list|)
block|{
name|BranchHandle
name|bh
init|=
name|BranchHandle
operator|.
name|getBranchHandle
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|InstructionList
name|il
init|=
operator|new
name|InstructionList
argument_list|()
decl_stmt|;
name|il
operator|.
name|append
argument_list|(
name|bh
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|ih
argument_list|,
name|il
argument_list|)
expr_stmt|;
return|return
name|bh
return|;
block|}
comment|/**      * Take all instructions (handles) from "start" to "end" and append them after the      * new location "target". Of course, "end" must be after "start" and target must      * not be located withing this range. If you want to move something to the start of      * the list use null as value for target.<br>      * Any instruction targeters pointing to handles within the block, keep their targets.      *      * @param start  of moved block      * @param end    of moved block      * @param target of moved block      */
specifier|public
name|void
name|move
parameter_list|(
name|InstructionHandle
name|start
parameter_list|,
name|InstructionHandle
name|end
parameter_list|,
name|InstructionHandle
name|target
parameter_list|)
block|{
comment|// Step 1: Check constraints
if|if
condition|(
operator|(
name|start
operator|==
literal|null
operator|)
operator|||
operator|(
name|end
operator|==
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Invalid null handle: From "
operator|+
name|start
operator|+
literal|" to "
operator|+
name|end
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|target
operator|==
name|start
operator|)
operator|||
operator|(
name|target
operator|==
name|end
operator|)
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Invalid range: From "
operator|+
name|start
operator|+
literal|" to "
operator|+
name|end
operator|+
literal|" contains target "
operator|+
name|target
argument_list|)
throw|;
block|}
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|start
init|;
name|ih
operator|!=
name|end
operator|.
name|next
condition|;
name|ih
operator|=
name|ih
operator|.
name|next
control|)
block|{
if|if
condition|(
name|ih
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Invalid range: From "
operator|+
name|start
operator|+
literal|" to "
operator|+
name|end
argument_list|)
throw|;
block|}
if|else if
condition|(
name|ih
operator|==
name|target
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Invalid range: From "
operator|+
name|start
operator|+
literal|" to "
operator|+
name|end
operator|+
literal|" contains target "
operator|+
name|target
argument_list|)
throw|;
block|}
block|}
comment|// Step 2: Temporarily remove the given instructions from the list
name|InstructionHandle
name|prev
init|=
name|start
operator|.
name|prev
decl_stmt|,
name|next
init|=
name|end
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
block|{
name|prev
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|start
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
literal|null
condition|)
block|{
name|next
operator|.
name|prev
operator|=
name|prev
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|end
operator|=
name|prev
expr_stmt|;
block|}
name|start
operator|.
name|prev
operator|=
name|end
operator|.
name|next
operator|=
literal|null
expr_stmt|;
comment|// Step 3: append after target
if|if
condition|(
name|target
operator|==
literal|null
condition|)
block|{
comment|// append to start of list
if|if
condition|(
name|this
operator|.
name|start
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|start
operator|.
name|prev
operator|=
name|end
expr_stmt|;
block|}
name|end
operator|.
name|next
operator|=
name|this
operator|.
name|start
expr_stmt|;
name|this
operator|.
name|start
operator|=
name|start
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|target
operator|.
name|next
expr_stmt|;
name|target
operator|.
name|next
operator|=
name|start
expr_stmt|;
name|start
operator|.
name|prev
operator|=
name|target
expr_stmt|;
name|end
operator|.
name|next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|!=
literal|null
condition|)
block|{
name|next
operator|.
name|prev
operator|=
name|end
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|end
operator|=
name|end
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Move a single instruction (handle) to a new location.      *      * @param ih     moved instruction      * @param target new location of moved instruction      */
specifier|public
name|void
name|move
parameter_list|(
name|InstructionHandle
name|ih
parameter_list|,
name|InstructionHandle
name|target
parameter_list|)
block|{
name|move
argument_list|(
name|ih
argument_list|,
name|ih
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove from instruction `prev' to instruction `next' both contained      * in this list. Throws TargetLostException when one of the removed instruction handles      * is still being targeted.      *      * @param prev where to start deleting (predecessor, exclusive)      * @param next where to end deleting (successor, exclusive)      */
specifier|private
name|void
name|remove
parameter_list|(
name|InstructionHandle
name|prev
parameter_list|,
name|InstructionHandle
name|next
parameter_list|)
throws|throws
name|TargetLostException
block|{
name|InstructionHandle
name|first
decl_stmt|,
name|last
decl_stmt|;
comment|// First and last deleted instruction
if|if
condition|(
operator|(
name|prev
operator|==
literal|null
operator|)
operator|&&
operator|(
name|next
operator|==
literal|null
operator|)
condition|)
block|{
name|first
operator|=
name|start
expr_stmt|;
name|last
operator|=
name|end
expr_stmt|;
name|start
operator|=
name|end
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prev
operator|==
literal|null
condition|)
block|{
comment|// At start of list
name|first
operator|=
name|start
expr_stmt|;
name|start
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
name|prev
operator|.
name|next
expr_stmt|;
name|prev
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
comment|// At end of list
name|last
operator|=
name|end
expr_stmt|;
name|end
operator|=
name|prev
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|next
operator|.
name|prev
expr_stmt|;
name|next
operator|.
name|prev
operator|=
name|prev
expr_stmt|;
block|}
block|}
name|first
operator|.
name|prev
operator|=
literal|null
expr_stmt|;
comment|// Completely separated from rest of list
name|last
operator|.
name|next
operator|=
literal|null
expr_stmt|;
name|List
argument_list|<
name|InstructionHandle
argument_list|>
name|target_vec
init|=
operator|new
name|ArrayList
argument_list|<
name|InstructionHandle
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|first
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|next
control|)
block|{
name|ih
operator|.
name|getInstruction
argument_list|()
operator|.
name|dispose
argument_list|()
expr_stmt|;
comment|// e.g. BranchInstructions release their targets
block|}
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"{ "
argument_list|)
decl_stmt|;
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|first
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ih
operator|.
name|next
expr_stmt|;
name|length
operator|--
expr_stmt|;
if|if
condition|(
name|ih
operator|.
name|hasTargeters
argument_list|()
condition|)
block|{
comment|// Still got targeters?
name|target_vec
operator|.
name|add
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|ih
operator|.
name|toString
argument_list|(
literal|true
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|ih
operator|.
name|next
operator|=
name|ih
operator|.
name|prev
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ih
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_vec
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|InstructionHandle
index|[]
name|targeted
init|=
operator|new
name|InstructionHandle
index|[
name|target_vec
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|target_vec
operator|.
name|toArray
argument_list|(
name|targeted
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|TargetLostException
argument_list|(
name|targeted
argument_list|,
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Remove instruction from this list. The corresponding Instruction      * handles must not be reused!      *      * @param ih instruction (handle) to remove       */
specifier|public
name|void
name|delete
parameter_list|(
name|InstructionHandle
name|ih
parameter_list|)
throws|throws
name|TargetLostException
block|{
name|remove
argument_list|(
name|ih
operator|.
name|prev
argument_list|,
name|ih
operator|.
name|next
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove instruction from this list. The corresponding Instruction      * handles must not be reused!      *      * @param i instruction to remove      */
specifier|public
name|void
name|delete
parameter_list|(
name|Instruction
name|i
parameter_list|)
throws|throws
name|TargetLostException
block|{
name|InstructionHandle
name|ih
decl_stmt|;
if|if
condition|(
operator|(
name|ih
operator|=
name|findInstruction1
argument_list|(
name|i
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Instruction "
operator|+
name|i
operator|+
literal|" is not contained in this list."
argument_list|)
throw|;
block|}
name|delete
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove instructions from instruction `from' to instruction `to' contained      * in this list. The user must ensure that `from' is an instruction before      * `to', or risk havoc. The corresponding Instruction handles must not be reused!      *      * @param from where to start deleting (inclusive)      * @param to   where to end deleting (inclusive)      */
specifier|public
name|void
name|delete
parameter_list|(
name|InstructionHandle
name|from
parameter_list|,
name|InstructionHandle
name|to
parameter_list|)
throws|throws
name|TargetLostException
block|{
name|remove
argument_list|(
name|from
operator|.
name|prev
argument_list|,
name|to
operator|.
name|next
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove instructions from instruction `from' to instruction `to' contained      * in this list. The user must ensure that `from' is an instruction before      * `to', or risk havoc. The corresponding Instruction handles must not be reused!      *      * @param from where to start deleting (inclusive)      * @param to   where to end deleting (inclusive)      */
specifier|public
name|void
name|delete
parameter_list|(
name|Instruction
name|from
parameter_list|,
name|Instruction
name|to
parameter_list|)
throws|throws
name|TargetLostException
block|{
name|InstructionHandle
name|from_ih
decl_stmt|,
name|to_ih
decl_stmt|;
if|if
condition|(
operator|(
name|from_ih
operator|=
name|findInstruction1
argument_list|(
name|from
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Instruction "
operator|+
name|from
operator|+
literal|" is not contained in this list."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|to_ih
operator|=
name|findInstruction2
argument_list|(
name|to
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Instruction "
operator|+
name|to
operator|+
literal|" is not contained in this list."
argument_list|)
throw|;
block|}
name|delete
argument_list|(
name|from_ih
argument_list|,
name|to_ih
argument_list|)
expr_stmt|;
block|}
comment|/**      * Search for given Instruction reference, start at beginning of list.      *      * @param i instruction to search for      * @return instruction found on success, null otherwise      */
specifier|private
name|InstructionHandle
name|findInstruction1
parameter_list|(
name|Instruction
name|i
parameter_list|)
block|{
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|start
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|next
control|)
block|{
if|if
condition|(
name|ih
operator|.
name|instruction
operator|==
name|i
condition|)
block|{
return|return
name|ih
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Search for given Instruction reference, start at end of list      *      * @param i instruction to search for      * @return instruction found on success, null otherwise      */
specifier|private
name|InstructionHandle
name|findInstruction2
parameter_list|(
name|Instruction
name|i
parameter_list|)
block|{
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|end
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|prev
control|)
block|{
if|if
condition|(
name|ih
operator|.
name|instruction
operator|==
name|i
condition|)
block|{
return|return
name|ih
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|boolean
name|contains
parameter_list|(
name|InstructionHandle
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|start
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|next
control|)
block|{
if|if
condition|(
name|ih
operator|==
name|i
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|contains
parameter_list|(
name|Instruction
name|i
parameter_list|)
block|{
return|return
name|findInstruction1
argument_list|(
name|i
argument_list|)
operator|!=
literal|null
return|;
block|}
specifier|public
name|void
name|setPositions
parameter_list|()
block|{
name|setPositions
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Give all instructions their position number (offset in byte stream), i.e.,      * make the list ready to be dumped.      *      * @param check Perform sanity checks, e.g. if all targeted instructions really belong      * to this list      */
specifier|public
name|void
name|setPositions
parameter_list|(
name|boolean
name|check
parameter_list|)
block|{
name|int
name|max_additional_bytes
init|=
literal|0
decl_stmt|,
name|additional_bytes
init|=
literal|0
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|int
index|[]
name|pos
init|=
operator|new
name|int
index|[
name|length
index|]
decl_stmt|;
comment|/* Pass 0: Sanity checks          */
if|if
condition|(
name|check
condition|)
block|{
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|start
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|next
control|)
block|{
name|Instruction
name|i
init|=
name|ih
operator|.
name|instruction
decl_stmt|;
if|if
condition|(
name|i
operator|instanceof
name|BranchInstruction
condition|)
block|{
comment|// target instruction within list?
name|Instruction
name|inst
init|=
operator|(
operator|(
name|BranchInstruction
operator|)
name|i
operator|)
operator|.
name|getTarget
argument_list|()
operator|.
name|instruction
decl_stmt|;
if|if
condition|(
operator|!
name|contains
argument_list|(
name|inst
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Branch target of "
operator|+
name|Constants
operator|.
name|OPCODE_NAMES
index|[
name|i
operator|.
name|opcode
index|]
operator|+
literal|":"
operator|+
name|inst
operator|+
literal|" not in instruction list"
argument_list|)
throw|;
block|}
if|if
condition|(
name|i
operator|instanceof
name|Select
condition|)
block|{
name|InstructionHandle
index|[]
name|targets
init|=
operator|(
operator|(
name|Select
operator|)
name|i
operator|)
operator|.
name|getTargets
argument_list|()
decl_stmt|;
for|for
control|(
name|InstructionHandle
name|target
range|:
name|targets
control|)
block|{
name|inst
operator|=
name|target
operator|.
name|instruction
expr_stmt|;
if|if
condition|(
operator|!
name|contains
argument_list|(
name|inst
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Branch target of "
operator|+
name|Constants
operator|.
name|OPCODE_NAMES
index|[
name|i
operator|.
name|opcode
index|]
operator|+
literal|":"
operator|+
name|inst
operator|+
literal|" not in instruction list"
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|ih
operator|instanceof
name|BranchHandle
operator|)
condition|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
literal|"Branch instruction "
operator|+
name|Constants
operator|.
name|OPCODE_NAMES
index|[
name|i
operator|.
name|opcode
index|]
operator|+
literal|":"
operator|+
name|inst
operator|+
literal|" not contained in BranchHandle."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/* Pass 1: Set position numbers and sum up the maximum number of bytes an          * instruction may be shifted.          */
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|start
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|next
control|)
block|{
name|Instruction
name|i
init|=
name|ih
operator|.
name|instruction
decl_stmt|;
name|ih
operator|.
name|setPosition
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|pos
index|[
name|count
operator|++
index|]
operator|=
name|index
expr_stmt|;
comment|/* Get an estimate about how many additional bytes may be added, because              * BranchInstructions may have variable length depending on the target              * offset (short vs. int) or alignment issues (TABLESWITCH and              * LOOKUPSWITCH).              */
switch|switch
condition|(
name|i
operator|.
name|getOpcode
argument_list|()
condition|)
block|{
case|case
name|Constants
operator|.
name|JSR
case|:
case|case
name|Constants
operator|.
name|GOTO
case|:
name|max_additional_bytes
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|Constants
operator|.
name|TABLESWITCH
case|:
case|case
name|Constants
operator|.
name|LOOKUPSWITCH
case|:
name|max_additional_bytes
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
name|index
operator|+=
name|i
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
comment|/* Pass 2: Expand the variable-length (Branch)Instructions depending on          * the target offset (short or int) and ensure that branch targets are          * within this list.          */
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|start
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|next
control|)
block|{
name|additional_bytes
operator|+=
name|ih
operator|.
name|updatePosition
argument_list|(
name|additional_bytes
argument_list|,
name|max_additional_bytes
argument_list|)
expr_stmt|;
block|}
comment|/* Pass 3: Update position numbers (which may have changed due to the          * preceding expansions), like pass 1.          */
name|index
operator|=
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|start
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|next
control|)
block|{
name|Instruction
name|i
init|=
name|ih
operator|.
name|instruction
decl_stmt|;
name|ih
operator|.
name|setPosition
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|pos
index|[
name|count
operator|++
index|]
operator|=
name|index
expr_stmt|;
name|index
operator|+=
name|i
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
name|byte_positions
operator|=
operator|new
name|int
index|[
name|count
index|]
expr_stmt|;
comment|// Trim to proper size
name|System
operator|.
name|arraycopy
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|,
name|byte_positions
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
comment|/**      * When everything is finished, use this method to convert the instruction      * list into an array of bytes.      *      * @return the byte code ready to be dumped      */
specifier|public
name|byte
index|[]
name|getByteCode
parameter_list|()
block|{
comment|// Update position indices of instructions
name|setPositions
argument_list|()
expr_stmt|;
name|ByteArrayOutputStream
name|b
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
name|b
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|start
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|next
control|)
block|{
name|Instruction
name|i
init|=
name|ih
operator|.
name|instruction
decl_stmt|;
name|i
operator|.
name|dump
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// Traverse list
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|new
name|byte
index|[
literal|0
index|]
return|;
block|}
return|return
name|b
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|/**      * @return an array of instructions without target information for branch instructions.      */
specifier|public
name|Instruction
index|[]
name|getInstructions
parameter_list|()
block|{
name|ByteSequence
name|bytes
init|=
operator|new
name|ByteSequence
argument_list|(
name|getByteCode
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Instruction
argument_list|>
name|instructions
init|=
operator|new
name|ArrayList
argument_list|<
name|Instruction
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
while|while
condition|(
name|bytes
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|instructions
operator|.
name|add
argument_list|(
name|Instruction
operator|.
name|readInstruction
argument_list|(
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ClassGenException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|instructions
operator|.
name|toArray
argument_list|(
operator|new
name|Instruction
index|[
name|instructions
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|toString
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|/**      * @param verbose toggle output format      * @return String containing all instructions in this list.      */
specifier|public
name|String
name|toString
parameter_list|(
name|boolean
name|verbose
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|start
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|next
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|ih
operator|.
name|toString
argument_list|(
name|verbose
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * @return iterator that lists all instructions (handles)      */
specifier|public
name|Iterator
argument_list|<
name|InstructionHandle
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|InstructionHandle
argument_list|>
argument_list|()
block|{
specifier|private
name|InstructionHandle
name|ih
init|=
name|start
decl_stmt|;
specifier|public
name|InstructionHandle
name|next
parameter_list|()
throws|throws
name|NoSuchElementException
block|{
if|if
condition|(
name|ih
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|InstructionHandle
name|i
init|=
name|ih
decl_stmt|;
name|ih
operator|=
name|ih
operator|.
name|next
expr_stmt|;
return|return
name|i
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|ih
operator|!=
literal|null
return|;
block|}
block|}
return|;
block|}
comment|/**      * @return array containing all instructions (handles)      */
specifier|public
name|InstructionHandle
index|[]
name|getInstructionHandles
parameter_list|()
block|{
name|InstructionHandle
index|[]
name|ihs
init|=
operator|new
name|InstructionHandle
index|[
name|length
index|]
decl_stmt|;
name|InstructionHandle
name|ih
init|=
name|start
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ihs
index|[
name|i
index|]
operator|=
name|ih
expr_stmt|;
name|ih
operator|=
name|ih
operator|.
name|next
expr_stmt|;
block|}
return|return
name|ihs
return|;
block|}
comment|/**      * Get positions (offsets) of all instructions in the list. This relies on that      * the list has been freshly created from an byte code array, or that setPositions()      * has been called. Otherwise this may be inaccurate.      *      * @return array containing all instruction's offset in byte code      */
specifier|public
name|int
index|[]
name|getInstructionPositions
parameter_list|()
block|{
return|return
name|byte_positions
return|;
block|}
comment|/**      * @return complete, i.e., deep copy of this list      */
specifier|public
name|InstructionList
name|copy
parameter_list|()
block|{
name|Map
argument_list|<
name|InstructionHandle
argument_list|,
name|InstructionHandle
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|InstructionHandle
argument_list|,
name|InstructionHandle
argument_list|>
argument_list|()
decl_stmt|;
name|InstructionList
name|il
init|=
operator|new
name|InstructionList
argument_list|()
decl_stmt|;
comment|/* Pass 1: Make copies of all instructions, append them to the new list          * and associate old instruction references with the new ones, i.e.,          * a 1:1 mapping.          */
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|start
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|next
control|)
block|{
name|Instruction
name|i
init|=
name|ih
operator|.
name|instruction
decl_stmt|;
name|Instruction
name|c
init|=
name|i
operator|.
name|copy
argument_list|()
decl_stmt|;
comment|// Use clone for shallow copy
if|if
condition|(
name|c
operator|instanceof
name|BranchInstruction
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|ih
argument_list|,
name|il
operator|.
name|append
argument_list|(
operator|(
name|BranchInstruction
operator|)
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|map
operator|.
name|put
argument_list|(
name|ih
argument_list|,
name|il
operator|.
name|append
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Pass 2: Update branch targets.          */
name|InstructionHandle
name|ih
init|=
name|start
decl_stmt|;
name|InstructionHandle
name|ch
init|=
name|il
operator|.
name|start
decl_stmt|;
while|while
condition|(
name|ih
operator|!=
literal|null
condition|)
block|{
name|Instruction
name|i
init|=
name|ih
operator|.
name|instruction
decl_stmt|;
name|Instruction
name|c
init|=
name|ch
operator|.
name|instruction
decl_stmt|;
if|if
condition|(
name|i
operator|instanceof
name|BranchInstruction
condition|)
block|{
name|BranchInstruction
name|bi
init|=
operator|(
name|BranchInstruction
operator|)
name|i
decl_stmt|;
name|BranchInstruction
name|bc
init|=
operator|(
name|BranchInstruction
operator|)
name|c
decl_stmt|;
name|InstructionHandle
name|itarget
init|=
name|bi
operator|.
name|getTarget
argument_list|()
decl_stmt|;
comment|// old target
comment|// New target is in hash map
name|bc
operator|.
name|setTarget
argument_list|(
name|map
operator|.
name|get
argument_list|(
name|itarget
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bi
operator|instanceof
name|Select
condition|)
block|{
comment|// Either LOOKUPSWITCH or TABLESWITCH
name|InstructionHandle
index|[]
name|itargets
init|=
operator|(
operator|(
name|Select
operator|)
name|bi
operator|)
operator|.
name|getTargets
argument_list|()
decl_stmt|;
name|InstructionHandle
index|[]
name|ctargets
init|=
operator|(
operator|(
name|Select
operator|)
name|bc
operator|)
operator|.
name|getTargets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|itargets
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
comment|// Update all targets
name|ctargets
index|[
name|j
index|]
operator|=
name|map
operator|.
name|get
argument_list|(
name|itargets
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ih
operator|=
name|ih
operator|.
name|next
expr_stmt|;
name|ch
operator|=
name|ch
operator|.
name|next
expr_stmt|;
block|}
return|return
name|il
return|;
block|}
comment|/** Replace all references to the old constant pool with references to the new      *  constant pool      */
specifier|public
name|void
name|replaceConstantPool
parameter_list|(
name|ConstantPoolGen
name|old_cp
parameter_list|,
name|ConstantPoolGen
name|new_cp
parameter_list|)
block|{
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|start
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|next
control|)
block|{
name|Instruction
name|i
init|=
name|ih
operator|.
name|instruction
decl_stmt|;
if|if
condition|(
name|i
operator|instanceof
name|CPInstruction
condition|)
block|{
name|CPInstruction
name|ci
init|=
operator|(
name|CPInstruction
operator|)
name|i
decl_stmt|;
name|Constant
name|c
init|=
name|old_cp
operator|.
name|getConstant
argument_list|(
name|ci
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|ci
operator|.
name|setIndex
argument_list|(
name|new_cp
operator|.
name|addConstant
argument_list|(
name|c
argument_list|,
name|old_cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|clear
parameter_list|()
block|{
name|start
operator|=
name|end
operator|=
literal|null
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Delete contents of list. Provides better memory utilization,      * because the system then may reuse the instruction handles. This      * method is typically called right after {@link MethodGen#getMethod()}.      */
specifier|public
name|void
name|dispose
parameter_list|()
block|{
comment|// Traverse in reverse order, because ih.next is overwritten
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|end
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|prev
control|)
block|{
comment|/* Causes BranchInstructions to release target and targeters, because it              * calls dispose() on the contained instruction.              */
name|ih
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**      * @return start of list      */
specifier|public
name|InstructionHandle
name|getStart
parameter_list|()
block|{
return|return
name|start
return|;
block|}
comment|/**      * @return end of list      */
specifier|public
name|InstructionHandle
name|getEnd
parameter_list|()
block|{
return|return
name|end
return|;
block|}
comment|/**      * @return length of list (Number of instructions, not bytes)      */
specifier|public
name|int
name|getLength
parameter_list|()
block|{
return|return
name|length
return|;
block|}
comment|/**      * @return length of list (Number of instructions, not bytes)      */
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|length
return|;
block|}
comment|/**      * Redirect all references from old_target to new_target, i.e., update targets       * of branch instructions.      *      * @param old_target the old target instruction handle      * @param new_target the new target instruction handle      */
specifier|public
name|void
name|redirectBranches
parameter_list|(
name|InstructionHandle
name|old_target
parameter_list|,
name|InstructionHandle
name|new_target
parameter_list|)
block|{
for|for
control|(
name|InstructionHandle
name|ih
init|=
name|start
init|;
name|ih
operator|!=
literal|null
condition|;
name|ih
operator|=
name|ih
operator|.
name|next
control|)
block|{
name|Instruction
name|i
init|=
name|ih
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|instanceof
name|BranchInstruction
condition|)
block|{
name|BranchInstruction
name|b
init|=
operator|(
name|BranchInstruction
operator|)
name|i
decl_stmt|;
name|InstructionHandle
name|target
init|=
name|b
operator|.
name|getTarget
argument_list|()
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|old_target
condition|)
block|{
name|b
operator|.
name|setTarget
argument_list|(
name|new_target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|instanceof
name|Select
condition|)
block|{
comment|// Either LOOKUPSWITCH or TABLESWITCH
name|InstructionHandle
index|[]
name|targets
init|=
operator|(
operator|(
name|Select
operator|)
name|b
operator|)
operator|.
name|getTargets
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|targets
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|targets
index|[
name|j
index|]
operator|==
name|old_target
condition|)
block|{
operator|(
operator|(
name|Select
operator|)
name|b
operator|)
operator|.
name|setTarget
argument_list|(
name|j
argument_list|,
name|new_target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**      * Redirect all references of local variables from old_target to new_target.      *      * @param lg array of local variables      * @param old_target the old target instruction handle      * @param new_target the new target instruction handle      * @see MethodGen      */
specifier|public
name|void
name|redirectLocalVariables
parameter_list|(
name|LocalVariableGen
index|[]
name|lg
parameter_list|,
name|InstructionHandle
name|old_target
parameter_list|,
name|InstructionHandle
name|new_target
parameter_list|)
block|{
for|for
control|(
name|LocalVariableGen
name|element
range|:
name|lg
control|)
block|{
name|InstructionHandle
name|start
init|=
name|element
operator|.
name|getStart
argument_list|()
decl_stmt|;
name|InstructionHandle
name|end
init|=
name|element
operator|.
name|getEnd
argument_list|()
decl_stmt|;
if|if
condition|(
name|start
operator|==
name|old_target
condition|)
block|{
name|element
operator|.
name|setStart
argument_list|(
name|new_target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|==
name|old_target
condition|)
block|{
name|element
operator|.
name|setEnd
argument_list|(
name|new_target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Redirect all references of exception handlers from old_target to new_target.      *      * @param exceptions array of exception handlers      * @param old_target the old target instruction handle      * @param new_target the new target instruction handle      * @see MethodGen      */
specifier|public
name|void
name|redirectExceptionHandlers
parameter_list|(
name|CodeExceptionGen
index|[]
name|exceptions
parameter_list|,
name|InstructionHandle
name|old_target
parameter_list|,
name|InstructionHandle
name|new_target
parameter_list|)
block|{
for|for
control|(
name|CodeExceptionGen
name|exception
range|:
name|exceptions
control|)
block|{
if|if
condition|(
name|exception
operator|.
name|getStartPC
argument_list|()
operator|==
name|old_target
condition|)
block|{
name|exception
operator|.
name|setStartPC
argument_list|(
name|new_target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exception
operator|.
name|getEndPC
argument_list|()
operator|==
name|old_target
condition|)
block|{
name|exception
operator|.
name|setEndPC
argument_list|(
name|new_target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exception
operator|.
name|getHandlerPC
argument_list|()
operator|==
name|old_target
condition|)
block|{
name|exception
operator|.
name|setHandlerPC
argument_list|(
name|new_target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|List
argument_list|<
name|InstructionListObserver
argument_list|>
name|observers
decl_stmt|;
comment|/** Add observer for this object.      */
specifier|public
name|void
name|addObserver
parameter_list|(
name|InstructionListObserver
name|o
parameter_list|)
block|{
if|if
condition|(
name|observers
operator|==
literal|null
condition|)
block|{
name|observers
operator|=
operator|new
name|ArrayList
argument_list|<
name|InstructionListObserver
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|observers
operator|.
name|add
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
comment|/** Remove observer for this object.      */
specifier|public
name|void
name|removeObserver
parameter_list|(
name|InstructionListObserver
name|o
parameter_list|)
block|{
if|if
condition|(
name|observers
operator|!=
literal|null
condition|)
block|{
name|observers
operator|.
name|remove
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Call notify() method on all observers. This method is not called      * automatically whenever the state has changed, but has to be      * called by the user after he has finished editing the object.      */
specifier|public
name|void
name|update
parameter_list|()
block|{
if|if
condition|(
name|observers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|InstructionListObserver
name|observer
range|:
name|observers
control|)
block|{
name|observer
operator|.
name|notify
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

